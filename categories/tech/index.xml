<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tech on Yuantops&#39; Blog</title>
    <link>https://blog.yuantops.com/categories/tech/</link>
    <description>Recent content in Tech on Yuantops&#39; Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>yuan.tops@gmail.com (yuantops)</managingEditor>
    <webMaster>yuan.tops@gmail.com (yuantops)</webMaster>
    <copyright>All rights reserved.</copyright>
    <lastBuildDate>Sun, 29 Jul 2018 17:48:19 +0000</lastBuildDate>
    <atom:link href="https://blog.yuantops.com/categories/tech/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[译文]让Siri变身完美家庭助手：兼容Apple Homekit不支持的设备</title>
      <link>https://blog.yuantops.com/tech/homebridge-plugin-tutorial/</link>
      <pubDate>Sun, 29 Jul 2018 17:48:19 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/homebridge-plugin-tutorial/</guid>
      <description>

&lt;p&gt;译文一篇,
原文地址：&lt;a href=&#34;http://blog.theodo.fr/2017/08/make-siri-perfect-home-companion-devices-not-supported-apple-homekit/&#34;&gt;http://blog.theodo.fr/2017/08/make-siri-perfect-home-companion-devices-not-supported-apple-homekit/&lt;/a&gt;
。&lt;/p&gt;

&lt;p&gt;Apple推出Homekit已有一段时间，作为智能家具解决布局的重要一环，Homekit在中文互联网上的资料可算寥寥。这篇文章介绍了Homekit平台抽象的关键概念，以及Homebridge这一款破解了Homekit协议、并支持插件化开发扩展的优秀程序。&lt;/p&gt;

&lt;p&gt;文章还包含了一个详细教程，一步步教你写简单的Homebridge插件。&lt;/p&gt;

&lt;p&gt;即使不是开发者，读完这篇文章，最起码可以让你打开iOS
“家庭”应用时不至于一头雾水。&lt;/p&gt;

&lt;p&gt;========================分割线，以下是正文===============================&lt;/p&gt;

&lt;h1 id=&#34;为什么是homekit&#34;&gt;为什么是Homekit?&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/homekit/&#34;&gt;Homekit&lt;/a&gt;是Apple开发的家庭配件管理框架。有了Homekit，Apple设备用户可以使用同一套界面，管理不同厂商的接入设备。它使Siri变得更强，能听懂发给这些设备的指令。&lt;/p&gt;

&lt;p&gt;如果你有一部iPhone或者Apple TV，Homekit可以在Home
Assistant等互联协议的基础上做更多好玩的事。iPhone原生支持Homekit，你可以通过&amp;rdquo;家庭&amp;rdquo;app
或者快速访问标签，方便地管理设备。Apple
    TV则可以作为设备中枢，让你设置自动化任务，并且让你在非家庭网络下也能掌控家中情况。&lt;/p&gt;

&lt;h1 id=&#34;工作原理&#34;&gt;工作原理&lt;/h1&gt;

&lt;h2 id=&#34;homekit-accessory-protocol&#34;&gt;Homekit Accessory Protocol&lt;/h2&gt;

&lt;p&gt;Homekit为家庭和各种连接设备定义了一组布局(layout)：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;家庭(Home)：家庭是一处住所，它有一个由各种配件组成的网络。&lt;/li&gt;
&lt;li&gt;房间(Room)：每个家庭有一个或多个房间，每个房间有一个或多个配件。&lt;/li&gt;
&lt;li&gt;平台(Platform)：平台指的是一组配件。&lt;/li&gt;
&lt;li&gt;配件(Accessory)：配件指的是一台支持自动化的物理设备。&lt;/li&gt;
&lt;li&gt;桥(Bridge)：桥是一种特殊配件，通过它可以和那些不能与Homekit直接通信的配件通信。举例来说，桥可能是一个灯光的中枢，灯光之间通信时并不使用Homekit
Accessory Protocol协议。&lt;/li&gt;
&lt;li&gt;服务(Service)：一个服务对应配件的一种功能。车库门除了提供开关门的服务，还可能额外提供开关车库灯的服务。&lt;/li&gt;
&lt;li&gt;特征(Characteristic)：每个服务都有一些被称为特征的属性。对车库门而言，它有 &lt;code&gt;Current Door State&lt;/code&gt; 和
&lt;code&gt;Target Door State&lt;/code&gt;
两个boolean值。服务的所有特征共同定义了它的当前状态。特征有3种权限：读，写，通知。&lt;a href=&#34;https://github.com/KhaosT/HAP-NodeJS/blob/master/lib/gen/HomeKitTypes.js&#34;&gt;这里&lt;/a&gt;能找到各种服务列表，以及与之关联的特征。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了确定要操作的设备以及要触发的动作，iOS的&amp;rdquo;家庭&amp;rdquo;应用和Siri发出的每一个请求，都会使用上面的布局。&lt;/p&gt;

&lt;p&gt;然而，当前市面上只有少量设备支持Homekit。对其他设备来说，需要在Homekit和设备间设置一个代理(proxy)。大多数厂商会自己定义一套与设备交互的方式(API或者协议)。代理接收Homekit请求，然后将它们翻译成设备能听懂的语言。&lt;/p&gt;

&lt;h2 id=&#34;homebridge&#34;&gt;Homebridge&lt;/h2&gt;

&lt;p&gt;本文使用的代理是&lt;a href=&#34;https://github.com/nfarina/homebridge&#34;&gt;Homebridge&lt;/a&gt;，一款用&lt;a href=&#34;https://github.com/KhaosT/HAP-NodeJS&#34;&gt;HAP-node.js&lt;/a&gt;写的NodeJS服务器。Homebridge实例化出一个
&lt;code&gt;桥&lt;/code&gt;
，然后你用iOS的&amp;rdquo;家庭&amp;rdquo;应用把它添加到Homekit。Homebridge支持社区开发的插件，从而在Homekit和五花八门的&amp;rdquo;智能家居&amp;rdquo;设备间建立连接。&lt;/p&gt;

&lt;p&gt;社区开发者已经为很多家庭自动化设备开发了插件(例如&lt;a href=&#34;https://github.com/KraigM/homebridge-nest&#34;&gt;Nest&lt;/a&gt;,
&lt;a href=&#34;https://github.com/devbobo/homebridge-lifx-lan&#34;&gt;Lifx&lt;/a&gt;, 甚至是&lt;a href=&#34;https://github.com/home-assistant/homebridge-homeassistant&#34;&gt;所有兼容Home
Assitant的设备&lt;/a&gt;)。如果你没找到要找的插件，这篇教程正是为你而写。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.theodo.fr/wp-content/uploads/2017/08/workflow.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;自己开发插件&#34;&gt;自己开发插件&lt;/h1&gt;

&lt;h2 id=&#34;要求&#34;&gt;要求&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;你已经在LAN中一台设备上安装了Homebridge，而且处于运行状态。参考&lt;a href=&#34;https://github.com/nfarina/homebridge#installation&#34;&gt;这些教程&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;你已经在iOS的&amp;rdquo;家庭&amp;rdquo;应用中，添加了Homebridge配件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;教程&#34;&gt;教程&lt;/h2&gt;

&lt;p&gt;我们来动手写一个假的开关插件。&lt;/p&gt;

&lt;p&gt;新建一个目录，包含2个文件：管理依赖的 &lt;code&gt;package.json&lt;/code&gt; 文件，以及放插件核心逻辑的 &lt;code&gt;index.js&lt;/code&gt; 文件。&lt;/p&gt;

&lt;p&gt;我们对开关API的设定如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在LAN里，能通过HTTP协议层的RESTful API控制它&lt;/li&gt;
&lt;li&gt;在LAN里，开关的IP地址是192.168.0.10&lt;/li&gt;
&lt;li&gt;对 &lt;code&gt;/api/status&lt;/code&gt; 的GET请求返回一个boolean值，代表开关的当前状态。这个请求会读取开关的 &lt;code&gt;On&lt;/code&gt; 特征&lt;/li&gt;
&lt;li&gt;对 &lt;code&gt;/api/order&lt;/code&gt; 的POST请求里携带一个代表开关目标的boolean值，将触发对应动作。这个请求会写入开关的 &lt;code&gt;On&lt;/code&gt;
特征&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个Homebridge插件将提供一个新配件，包含两个服务：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AccessoryInformation&lt;/code&gt; 服务。不管什么类型的配件都必须提供的服务，用来广播设备相关的信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Switch&lt;/code&gt; 服务，对应我们实际的开关。这个服务需要的特征只包含一个boolean值 &lt;code&gt;On&lt;/code&gt;
(参考&lt;a href=&#34;https://github.com/KhaosT/HAP-NodeJS/blob/master/lib/gen/HomeKitTypes.js#L3219&#34;&gt;服务和特征的对应关系表&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一步，把插件注入homebridge。控制逻辑在javascript对象 &lt;code&gt;mySwitch&lt;/code&gt; 里：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Service, Characteristic;

module.exports = function (homebridge) {
  Service = homebridge.hap.Service;
  Characteristic = homebridge.hap.Characteristic;
  homebridge.registerAccessory(&amp;quot;switch-plugin&amp;quot;, &amp;quot;MyAwesomeSwitch&amp;quot;, mySwitch);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在HAP-node.js和Homebridge框架下，把核心逻辑放到 &lt;code&gt;mySwitch&lt;/code&gt; 对象的 &lt;code&gt;getService&lt;/code&gt;
函数。在这个函数里实例化服务。我们还要在这个函数里定义，当Homekit请求到来时，要调用哪个服务哪个特征的getter和setter。&lt;/p&gt;

&lt;p&gt;我们需要实现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AccessoryInformation&lt;/code&gt; 服务，包含：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Manufacturer&lt;/code&gt; 特征&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Model&lt;/code&gt; 特征&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SerialNumber&lt;/code&gt; 特征&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Switch&lt;/code&gt; 服务，保护：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;On&lt;/code&gt; 特征 —— 这个服务仅需包含这一个特征&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;AccesoryInformation&lt;/code&gt; 的特征是可读的，可以在插件初始化时设置。特征 &lt;code&gt;On&lt;/code&gt;
不同，它是可写的，需要getter和setter。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;mySwitch.prototype = {
  getServices: function () {
    let informationService = new Service.AccessoryInformation();
    informationService
      .setCharacteristic(Characteristic.Manufacturer, &amp;quot;My switch manufacturer&amp;quot;)
      .setCharacteristic(Characteristic.Model, &amp;quot;My switch model&amp;quot;)
      .setCharacteristic(Characteristic.SerialNumber, &amp;quot;123-456-789&amp;quot;);

    let switchService = new Service.Switch(&amp;quot;My switch&amp;quot;);
    switchService
      .getCharacteristic(Characteristic.On)
  .on(&#39;get&#39;, this.getSwitchOnCharacteristic.bind(this))
  .on(&#39;set&#39;, this.setSwitchOnCharacteristic.bind(this));

    this.informationService = informationService;
    this.switchService = switchService;
    return [informationService, switchService];
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面，我们来实现 &lt;code&gt;On&lt;/code&gt; 特征的getter和setter。把这部分逻辑放到 &lt;code&gt;mySwitch&lt;/code&gt; 对象的原型函数里。&lt;/p&gt;

&lt;p&gt;基于开关提供的RESTful API，做出如下假设：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对 &lt;a href=&#34;http://192.168.0.10/api/status&#34;&gt;http://192.168.0.10/api/status&lt;/a&gt; 的GET请求，将返回 &lt;code&gt;{ currentState: }&lt;/code&gt;
，反映开关当前状态&lt;/li&gt;
&lt;li&gt;对 &lt;a href=&#34;http://192.168.0.10/api/order&#34;&gt;http://192.168.0.10/api/order&lt;/a&gt; 的POST请求，发送 &lt;code&gt;{ targetState: }&lt;/code&gt;
，代表想让开关达到的目标状态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们使用 &lt;code&gt;request&lt;/code&gt; 和 &lt;code&gt;url&lt;/code&gt; 模块处理HTTP请求。&lt;/p&gt;

&lt;p&gt;上面的URL要配置在Homebridge的全局JSON配置文件里，然后变成配置对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const request = require(&#39;request&#39;);
const url = require(&#39;url&#39;);

function mySwitch(log, config) {
  this.log = log;
  this.getUrl = url.parse(config[&#39;getUrl&#39;]);
  this.postUrl = url.parse(config[&#39;postUrl&#39;]);
}

mySwitch.prototype = {

  getSwitchOnCharacteristic: function (next) {
    const me = this;
    request({
  url: me.getUrl,
  method: &#39;GET&#39;,
    }, 
    function (error, response, body) {
      if (error) {
  me.log(&#39;STATUS: &#39; + response.statusCode);
  me.log(error.message);
  return next(error);
      }
      return next(null, body.currentState);
    });
  },

  setSwitchOnCharacteristic: function (on, next) {
    const me = this;
    request({
      url: me.postUrl,
      body: {&#39;targetState&#39;: on},
      method: &#39;POST&#39;,
      headers: {&#39;Content-type&#39;: &#39;application/json&#39;}
    },
    function (error, response) {
      if (error) {
  me.log(&#39;STATUS: &#39; + response.statusCode);
  me.log(error.message);
  return next(error);
      }
      return next();
    });
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，通过全局安装方式，把插件添加到Homebridge：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npm install -g switch-plugin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用你最爱的文本编辑器，打开位于Homebridge目录的config.json文件。在accessory部分，把下面内容添加到数组:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;accessory&amp;quot;: &amp;quot;MyAwesomeSwitch&amp;quot;,
  &amp;quot;getUrl&amp;quot;: &amp;quot;http://192.168.0.10/api/status&amp;quot;,
  &amp;quot;postUrl&amp;quot;: &amp;quot;http://192.168.0.10/api/order&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启Homebridge。打开iOS的&amp;rdquo;家庭&amp;rdquo;应用，现在你应该可以开、关这个假开关了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>树莓派连接DHT11温度湿度传感器</title>
      <link>https://blog.yuantops.com/tech/rasp-pi-dht11/</link>
      <pubDate>Sat, 28 Jul 2018 20:30:45 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/rasp-pi-dht11/</guid>
      <description>

&lt;p&gt;记录一下给树莓派安装温度湿度传感器的过程。&lt;/p&gt;

&lt;p&gt;树莓派主板有一排GPIO扩展口，可以方便地驱动硬件。温度湿度传感器DHT11是一种常见传感器，很适合作为入门器件，探索树莓派的硬件能力。&lt;/p&gt;

&lt;p&gt;我上次接触硬件知识还是在大二的单片机小学期，几乎已经忘光，正好趁机抢救性回忆一下。&lt;/p&gt;

&lt;h1 id=&#34;目标&#34;&gt;目标&lt;/h1&gt;

&lt;p&gt;在树莓派上读到温度和湿度数据。&lt;/p&gt;

&lt;h1 id=&#34;元件清单&#34;&gt;元件清单&lt;/h1&gt;

&lt;p&gt;除了传感器DHT11，还需要连接线、面包板等元件，在淘宝上很好买到。&lt;/p&gt;

&lt;p&gt;我额外买了一块树莓派特制GPIO扩展板，用它把树莓派的40根针脚延长到面包板，类似USB延长线。很怀疑这是来自中国的&amp;rdquo;微创新&amp;rdquo;，值得赞美，因为确实解决了树莓派针脚空间狭小不便于插线的小痛点。&lt;/p&gt;

&lt;p&gt;下面是元件清单：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;树莓派Model 3 B&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;DHT11传感器。我用的是三脚型号。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;面包板&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;杜邦线/连接线&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;插线&#34;&gt;插线&lt;/h1&gt;

&lt;p&gt;在实际插线之前，有必要先来认识树莓派针脚。树莓派3代一共40根针脚，这么辨认物理编号：横着放，让2排针脚在上面，上面那排是偶数，从左到右是2到40；下面那排是奇数，从左到右是1到39。&lt;/p&gt;

&lt;p&gt;40根针脚里，有28根GPIO针脚。这28根针脚，又有两种命名规则：BCM编号，WiringPi编号。还要注意，树莓派2代和3代的对应关系不一样，参考网上资料时要看清针脚图的型号。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BCM编号，就是我们常看见的 &lt;code&gt;GPIOxx&lt;/code&gt; 里面的 &lt;code&gt;xx&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;WiringPi编号，是 &lt;a href=&#34;http://wiringpi.com/&#34;&gt;WiringPi库&lt;/a&gt;
使用的编号。除非是用WiringPi库驱动针脚，否则不需关注。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对我这样的新手而言，最初物理编号和BCM编号两套规则切换起来有些烦人，需要一些细心。&lt;/p&gt;

&lt;p&gt;下面的接线方案，用的是物理编号：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;左边 &lt;code&gt;+&lt;/code&gt; 接3.3V电源，选择 &lt;code&gt;1&lt;/code&gt; 口。&lt;/li&gt;
&lt;li&gt;中间 &lt;code&gt;DATA&lt;/code&gt; ，选择 &lt;code&gt;7&lt;/code&gt; 口。&lt;/li&gt;
&lt;li&gt;右边 &lt;code&gt;-&lt;/code&gt; 接地，选择 &lt;code&gt;14&lt;/code&gt; 口。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;安装命令&#34;&gt;安装命令&lt;/h1&gt;

&lt;p&gt;DHT11是非常成熟通用的传感器，对它的驱动封装也特别多，不需再造轮子。货比三家，我发现Adafruit公司开源的代码质量最高，运行起来最稳定。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装Adadruit公司的开源库：&lt;a href=&#34;https://github.com/adafruit/Adafruit_Python_DHT&#34;&gt;Adafruit Python DHT&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在安装目录下, 进入example目录，运行 &lt;code&gt;AdafruitDHT.py&lt;/code&gt;
文件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pi@raspberrypi:~/Adafruit_Python_DHT/examples $ python AdafruitDHT.py 
0 30.0 C 70.0%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我房间此时是30摄氏度，湿度70%。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至此DHT11温度湿度传感器的安装完成。&lt;/p&gt;

&lt;p&gt;更进一步，在手机上查看，或者在LCD显示屏上展示，请期待后续文章。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go从GitHub安装命令时指定commit/tag</title>
      <link>https://blog.yuantops.com/tech/go-install-cmd-on-specific-git-tag/</link>
      <pubDate>Mon, 14 May 2018 09:49:03 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/go-install-cmd-on-specific-git-tag/</guid>
      <description>&lt;p&gt;Go的版本管理是一大痛点，最近我就亲身经历了一遭。在&lt;a href=&#34;https://blog.yuantops.com/tech/hugo-travis-ci-auto-deploy-to-gh-pages/&#34;&gt;Blog自动部署实践&lt;/a&gt;一文中，我把部署博客的工作流交给了Travis
CI。第二天，我照例打开Google Analytics查看访问量，发现前一天的访问量跌到0：一定出了什么问题。&lt;/p&gt;

&lt;p&gt;我从GitHub上把 &lt;code&gt;gh-pages&lt;/code&gt; 分支pull下来，grep我的Google Analysis跟踪码，居然没有。在本地用 &lt;code&gt;hugo&lt;/code&gt;
命令生成静态文件，在public目录里发现每篇文章的html页面都包含Google Analytics跟踪代码。到此基本确定问题：Travis
CI build生成的静态网页货不对版，因为默认使用最新版本 &lt;code&gt;hugo&lt;/code&gt; 命令，所以绝对是 &lt;code&gt;hugo&lt;/code&gt; 版本更新导致的兼容问题。&lt;/p&gt;

&lt;p&gt;解法也很简单，在 &lt;code&gt;.travis.yml&lt;/code&gt; 文件里安装指定版本的 &lt;code&gt;hugo&lt;/code&gt; 命令，让它和我本地&lt;code&gt;hugo&lt;/code&gt;命令的版本号保持一致。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.travis.yml&lt;/code&gt; 用go get安装Go命令。虽然官方不支持指定commit，但我在&lt;a href=&#34;https://stackoverflow.com/questions/30188499/how-to-do-go-get-on-a-specific-tag-of-a-github-repository&#34;&gt;Stackoverflow:How to do
“go get” on a specific tag of a github
repository&lt;/a&gt;
上找到了曲线救国方法，摘录如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. Run the get command without the tag - it should clone the master branch.
2. Move to the clone directory and checkout the tag or branch that you want.
3. Run the go get command again, it should process the command on the checked out branch.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事实上，这个方法行之有效。更新后， &lt;code&gt;.travis.yml&lt;/code&gt; 文件的install部分长这样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;install:
  - go get -d github.com/spf13/hugo 
  - cd $GOPATH/src/github.com/spf13/hugo
  - git checkout tags/v0.20.7
  - go get github.com/spf13/hugo
  - cd $TRAVIS_BUILD_DIR
  - hugo version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我指定安装v0.20.7版本的hugo，并手工打出版本号确认。重新部署后，Google Analytics统计恢复正常。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>本博客现已支持HTTPS</title>
      <link>https://blog.yuantops.com/tech/announcement-blog-https-supported/</link>
      <pubDate>Sat, 12 May 2018 12:59:10 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/announcement-blog-https-supported/</guid>
      <description>&lt;p&gt;赶个晚集，给博客加上了HTTPS支持。现在以&lt;code&gt;http://&lt;/code&gt;访问博客，会自动跳转到&lt;code&gt;https://&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;感谢Cloudflare提供的福利，让个人博客也能免费享受SSL。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Blog自动部署实践: Hugo &#43; Travis CI -&gt; GitHub Pages</title>
      <link>https://blog.yuantops.com/tech/hugo-travis-ci-auto-deploy-to-gh-pages/</link>
      <pubDate>Sat, 12 May 2018 08:45:52 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/hugo-travis-ci-auto-deploy-to-gh-pages/</guid>
      <description>

&lt;p&gt;这个博客托管在GitHub
Pages上已经有一段时间。最初使用的静态站点生成工具是Jekyll，后来&lt;a href=&#34;http://blog.yuantops.com/tech/transfer-from-jekyll-to-hugo/&#34;&gt;换成Hugo&lt;/a&gt;，因为是免费，一直都还比较满意。只有一个小痛点，博客从写完到部署的步骤多：写文章
-&amp;gt; build -&amp;gt;
deploy…&lt;/p&gt;

&lt;p&gt;我之前&lt;a href=&#34;http://blog.yuantops.com/tech/emacs-orgmode-hugo-with-oxpandoc/&#34;&gt;写过一篇用Emacs写博客的workflow&lt;/a&gt;，把&amp;rdquo;写文章&amp;rdquo;的流程优化了一把。之后又小打小闹，用GitHub的webhook做了一个commit
message关键字触发的小服务，把&amp;rdquo;build&amp;rdquo;和&amp;rdquo;deploy&amp;rdquo;做成自动化。这个服务跑在免费的Google
Cloud上，使用体验还不错，可惜主机没续费，服务直接停掉，源码也丢失了。&lt;/p&gt;

&lt;p&gt;随手Google一把GitHub Page的持续集成，才后知后觉地发现自己想要的东东已经有了成熟解决方案，而且还可以 &lt;strong&gt;免费&lt;/strong&gt;
用：&lt;a href=&#34;https://travis-ci.org/&#34;&gt;Travis CI&lt;/a&gt;。于是我颇愉快地接受它，并简单地在这里记录下来。&lt;/p&gt;

&lt;h1 id=&#34;什么是travis-ci&#34;&gt;什么是Travis CI&lt;/h1&gt;

&lt;p&gt;一个持续化集成平台，类似Jenkins。功能强大，和GitHub的集成尤其好，我们用它部署个人博客算大材小用。它有两个版本:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://travis-ci.org/&#34;&gt;https://travis-ci.org/&lt;/a&gt; 免费版本，可以集成GitHub的public项目&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://travis-ci.com/&#34;&gt;https://travis-ci.com/&lt;/a&gt; 商业版本，可以集成GitHub的private项目&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们使用第一个，免费版本。&lt;/p&gt;

&lt;h1 id=&#34;本博客现状回顾&#34;&gt;本博客现状回顾&lt;/h1&gt;

&lt;p&gt;在进一步描述具体步骤之前，有必要先简要回顾本博客的现状：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;生成静态站点文件&lt;/li&gt;
&lt;li&gt;两个git分支, &lt;code&gt;hugo&lt;/code&gt;: 存放博客源码, &lt;code&gt;gh-pages&lt;/code&gt;: 存放Hugo生成的静态站点文件&lt;/li&gt;
&lt;li&gt;自定义域名: `blog.yuantops.com`, 而不是默认的yuantops.github.io&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;配置travis-ci&#34;&gt;配置Travis CI&lt;/h1&gt;

&lt;h2 id=&#34;为travis-ci生成github-token&#34;&gt;为Travis CI生成GitHub Token&lt;/h2&gt;

&lt;p&gt;打开GitHub。路径: &amp;ldquo;Settings&amp;rdquo;-&amp;gt;&amp;ldquo;Developer settings&amp;rdquo;-&amp;gt;&amp;ldquo;Personal access
tokens&amp;rdquo;-&amp;gt;&amp;ldquo;Generate new token&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;因为是public项目，而且Travis CI是用来push代码，所以只需勾选 &lt;code&gt;public_repo&lt;/code&gt;, &lt;code&gt;repo:status&lt;/code&gt;,
&lt;code&gt;repo_deployment&lt;/code&gt; 三项。&lt;/p&gt;

&lt;p&gt;Token一会儿就会隐藏，不能找回，所以拷贝好，进入下一步。&lt;/p&gt;

&lt;h2 id=&#34;配置travis-ci构建选项&#34;&gt;配置Travis CI构建选项&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;用GitHub方式登录Travis CI(&lt;a href=&#34;https://travis-ci.org/&#34;&gt;https://travis-ci.org/&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Settings&amp;rdquo;-&amp;ldquo;General&amp;rdquo; 勾选&amp;rdquo;Build only if .travis.yml is present&amp;rdquo;和&amp;rdquo;Build
pushed branches&amp;rdquo;两项。&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Settings&amp;rdquo;-&amp;ldquo;Environment Variables&amp;rdquo;
添加&amp;rdquo;GITHUB&lt;sub&gt;TOKEN&lt;/sub&gt;&amp;ldquo;，值是上一步得到的Token&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;在git根目录下添加-travis-yml-文件&#34;&gt;在git根目录下添加 &lt;code&gt;.travis.yml&lt;/code&gt; 文件&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;language: go

go:
  - &amp;quot;1.8&amp;quot;  # 指定Golang 1.8

# Specify which branches to build using a safelist
# 分支白名单限制: 只有hugo分支的提交才会触发构建
branches:
  only:
    - hugo 

install:
# 安装最新的hugo
  - go get github.com/spf13/hugo 

script:
# 运行hugo命令
  - hugo

deploy:
  provider: pages # 重要，指定这是一份github pages的部署配置
  skip-cleanup: true # 重要，不能省略
  local-dir: public # 静态站点文件所在目录
  target-branch: gh-pages # 要将静态站点文件发布到哪个分支
  github-token: $GITHUB_TOKEN # 重要，$GITHUB_TOKEN是变量，需要在GitHub上申请、再到配置到Travis
  fqdn: blog.yuantops.com # 如果是自定义域名，此处要填
  keep-history: true # 是否保持target-branch分支的提交记录
  on:
    branch: hugo # 博客源码的分支
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把 &lt;code&gt;.travis.yml&lt;/code&gt; 放到hugo分支，push到GitHub。&lt;/p&gt;

&lt;h1 id=&#34;自动部署&#34;&gt;自动部署&lt;/h1&gt;

&lt;p&gt;上述操作完成后，自动部署就生效了。我们写完一篇博客，只需在hugo分支提交commit、再push到GitHub，Travis
CI会自动触发后续的构建、部署动作。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用Benchmark验证sync.Pool对GC latency的优化效果</title>
      <link>https://blog.yuantops.com/tech/sync-pool-benchmark/</link>
      <pubDate>Fri, 11 May 2018 10:33:25 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/sync-pool-benchmark/</guid>
      <description>

&lt;p&gt;可能是为了避免重复造轮子，Go官方库推出了sync.Pool:一个thread-safe、可回收/重用对象的内存池。对性能优化狂魔而言，sync.Pool无疑是一个优化GC的好工具，因为理论上重用对象会减少了GC次数，缩短latency。这篇文章是sync.Pool的性能验证报告：sync.Pool确实能极大减少GC次数。&lt;/p&gt;

&lt;h1 id=&#34;benchmark关注什么&#34;&gt;Benchmark关注什么？&lt;/h1&gt;

&lt;p&gt;在写Benchmark代码之前，要先确定如何衡量GC效果。很直观地，GC次数越少，效果越好。但GC次数的粒度太大，说服力不够，还需要其他的指标。&lt;/p&gt;

&lt;p&gt;这篇文章&lt;a href=&#34;https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/&#34;&gt;Golang real time
gc&lt;/a&gt;
给我了答案。不断往一个size固定的buffer里覆盖写入数据，记录写入耗时。被覆盖掉的数据会变成垃圾，继而触发GC，所以耗时就是latency。&lt;/p&gt;

&lt;p&gt;原文引述如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The benchmark program repeatedly pushes messages into a size-limited buffer. Old messages constantly expire and become garbage.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是，Benchmark的实现，以及关注的指标就确定了：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;GC次数&lt;/li&gt;
&lt;li&gt;数据写入耗时&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;代码实现&#34;&gt;代码实现&lt;/h1&gt;

&lt;h2 id=&#34;不用sync-pool的实现&#34;&gt;不用sync.Pool的实现&lt;/h2&gt;

&lt;p&gt;见&lt;a href=&#34;https://play.golang.org/p/049Xmy1lTfV&#34;&gt;https://play.golang.org/p/049Xmy1lTfV&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;   package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;time&amp;quot;
)

const (
  windowSize = 200000
  msgCount   = 100000000
)

type (
  message []byte
  buffer  map[int]message
)

var worst time.Duration

func mkMessage(n int) message {
  m := make(message, 1024)
  for i := range m {
      m[i] = byte(n)
  }
  return m
}

func pushMsg(b *buffer, highID int) {
  start := time.Now()
  m := mkMessage(highID)
  (*b)[highID%windowSize] = m
  elapsed := time.Since(start)
  if elapsed &amp;gt; worst {
      worst = elapsed
  }
}

func main() {
  b := make(buffer, windowSize)
  for i := 0; i &amp;lt; msgCount; i++ {
      pushMsg(&amp;amp;b, i)
  }
  fmt.Println(&amp;quot;Worst push time: &amp;quot;, worst)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;用sync-pool的实现&#34;&gt;用sync.Pool的实现&lt;/h2&gt;

&lt;p&gt;见&lt;a href=&#34;https://play.golang.org/p/Wop29wN7&#34;&gt;https://play.golang.org/p/Wop29wN7&lt;/a&gt;&lt;sub&gt;Dp&lt;/sub&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;   package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;sync&amp;quot;
  &amp;quot;time&amp;quot;
)

const (
  windowSize = 200000
  msgCount   = 100000000
)

type (
  message []byte
  buffer  map[int]message
)

var worst time.Duration

//pool for statistics model
var statModelPool = sync.Pool{
  New: func() interface{} {
      return make(message, 1024)
  },
}

func mkMessage(n int) message {
  m := statModelPool.Get().(message)
  for i := range m {
      m[i] = byte(n)
  }
  return m
}

func pushMsg(b *buffer, highID int) {
  start := time.Now()
  m := mkMessage(highID)
  if highID &amp;gt; windowSize {
      statModelPool.Put((*b)[highID%windowSize])
  }

  (*b)[highID%windowSize] = m
  elapsed := time.Since(start)
  if elapsed &amp;gt; worst {
      worst = elapsed
  }
}

func main() {
  b := make(buffer, windowSize)
  for i := 0; i &amp;lt; msgCount; i++ {
      pushMsg(&amp;amp;b, i)
  }
  fmt.Println(&amp;quot;Worst push time: &amp;quot;, worst)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;运行代码&#34;&gt;运行代码&lt;/h1&gt;

&lt;p&gt;因为要观察GC次数，我们需要打开GODEBUG的GCTRACE开关`GODEBUG=gctrace=1`。&lt;/p&gt;

&lt;p&gt;(下面的数据是在我的Thinkpad T450上跑出来的。)&lt;/p&gt;

&lt;h2 id=&#34;不使用sync-pool的实现&#34;&gt;不使用sync.Pool的实现&lt;/h2&gt;

&lt;p&gt;触发454次GC，最差写入耗时50.40ms。&lt;/p&gt;

&lt;p&gt;摘录一部分output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ GODEBUG=gctrace=1 go run benchmark_gc.go
gc 1 @0.041s 0%: 0.044+0.39+0.037 ms clock, 0.13+0.19/0.26/0.40+0.11 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 4 P
...
gc 454 @106.994s 4%: 0.012+29+0.045 ms clock, 0.048+1.6/26/39+0.18 ms cpu, 422-&amp;gt;437-&amp;gt;219 MB, 439 MB goal, 4 P
Worst push time:  50.401524ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;用sync-pool的实现-1&#34;&gt;用sync.Pool的实现&lt;/h2&gt;

&lt;p&gt;触发22次GC，最差写入耗时36.14ms&lt;/p&gt;

&lt;p&gt;摘录一部分output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; GODEBUG=gctrace=1 go run benchmark_gc_pool.go 
gc 1 @0.045s 0%: 0.047+1.2+0.077 ms clock, 0.19+0.12/1.1/0.50+0.30 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 4 P
# command-line-arguments
gc 1 @0.007s 6%: 0.051+2.2+0.024 ms clock, 0.15+0.32/2.1/1.5+0.073 ms cpu, 4-&amp;gt;4-&amp;gt;3 MB, 5 MB goal, 4 P
.....
gc 22 @76.006s 0%: 0.015+53+0.039 ms clock, 0.062+1.7/32/0.62+0.15 ms cpu, 401-&amp;gt;401-&amp;gt;205 MB, 411 MB goal, 4 P
Worst push time:  36.141858ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;结论&#34;&gt;结论&lt;/h1&gt;

&lt;p&gt;sync.Pool的效果很不错，值得尝试。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Emacs Golang开发环境配置指南</title>
      <link>https://blog.yuantops.com/tech/emacs-config-go-dev-environ/</link>
      <pubDate>Thu, 04 Jan 2018 00:31:08 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/emacs-config-go-dev-environ/</guid>
      <description>

&lt;h1 id=&#34;安装go&#34;&gt;安装Go&lt;/h1&gt;

&lt;p&gt;虽然像是废话，但为了配置过程的完整性，还是记下来吧。&lt;/p&gt;

&lt;p&gt;官网install链接: &lt;a href=&#34;https://golang.org/doc/install&#34;&gt;https://golang.org/doc/install&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;装好后记得配置 &lt;code&gt;$GOPATH&lt;/code&gt; 。为了能在任何地方使用Go编译出来的命令，还可以把 &lt;code&gt;$GOPATH/bin&lt;/code&gt; 附到环境变量$PATH。&lt;/p&gt;

&lt;p&gt;我在Mac上使用iTerm2+oh-my-zsh，所以把它们写到 &lt;code&gt;.zshrc&lt;/code&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# go path
export GOPATH=~/go
# add go commands to system path
export PATH=$GOPATH/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;让go-get命令绕过great-wall的束缚&#34;&gt;让go get命令绕过Great Wall的束缚&lt;/h1&gt;

&lt;p&gt;有了Go的开发环境，我们就可以用它编译、安装一些十分有用的小命令了。但在此之前，还有一些客观存在的技术障碍需要扫除。&lt;/p&gt;

&lt;p&gt;一般 &lt;code&gt;go get&lt;/code&gt;
命令会自动帮我们下载源码、编译、安装命令，如果托管源码的网站被block了(如gopkg.in)，整个过程就会卡住，卡到人抓狂(记得在内心f**k
GFW哦~)。&lt;/p&gt;

&lt;p&gt;这时，如果电脑上刚好运行着shadowsocks，事情就变得简单了。go get
支持http_proxy和https_proxy，我们需要动一点手脚，把sock5协议转换成http协议。&lt;/p&gt;

&lt;p&gt;(以下步骤的前提是电脑上运行着shadowsocks。)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装 polipo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install polipo   
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置 polipo 在家目录下新建 &lt;code&gt;.polipo&lt;/code&gt; 文件，内容如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#必填
socksParentProxy = &amp;quot;localhost:1080&amp;quot;
socksProxyType = socks5
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行 polipo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;polipo &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认会监听8123端口的http请求。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在go get命令前加上http_proxy参数&lt;/p&gt;

&lt;p&gt;以不幸被墙的cobra命令为例,它的代码网址是https协议,用:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https_proxy=127.0.0.1:8123 go get -v github.com/spf13/cobra/cobra
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是http_proxy, 用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http_proxy=127.0.0.1:8123 go get -v github.com/blah/blah
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;安装goimports-gocode等有用工具&#34;&gt;安装goimports，gocode等有用工具&lt;/h1&gt;

&lt;h2 id=&#34;goimports&#34;&gt;goimports&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;goimports命令能自动格式化代码，自动添加、移除imports，而且与Emacs集成良好。可以替代官方gofmt命令。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get -u golang.org/x/tools/cmd/goimports
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;gocode&#34;&gt;gocode&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;gocode命令能为代码自动补全提供后台支持，是Emacs下Go代码补全必不可少的backend。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get -u github.com/nsf/gocode  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;godef&#34;&gt;godef&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;godef命令能在Go源码变量、函数定义间跳转，是查看变量、函数、文件定义的好助手。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/rogpeppe/godef
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;安装emacs&#34;&gt;安装Emacs&lt;/h1&gt;

&lt;p&gt;呃。。。这一步就略过吧&lt;/p&gt;

&lt;h1 id=&#34;emacs配置go-mode&#34;&gt;Emacs配置Go mode&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装go-mode&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加自动格式化的hook(需要安装goimports命令)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;;; Call Gofmt before saving
 (setq gofmt-command &amp;quot;goimports&amp;quot;)
 (add-hook &#39;before-save-hook &#39;gofmt-before-save)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置自动补齐(需要安装gocode命令)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;;;autocomplete
(set (make-local-variable &#39;company-backends) &#39;(company-go))
(company-mode)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置自动跳转按键(需要安装godef命令)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;;; Godef jump key binding
 (local-set-key (kbd &amp;quot;M-,&amp;quot;) &#39;godef-jump)
 (local-set-key (kbd &amp;quot;M-.&amp;quot;) &#39;pop-tag-mark)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Orgmode利用ox-pandoc导出hugo博客的workflow</title>
      <link>https://blog.yuantops.com/tech/emacs-orgmode-hugo-with-oxpandoc/</link>
      <pubDate>Sun, 10 Dec 2017 13:16:22 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/emacs-orgmode-hugo-with-oxpandoc/</guid>
      <description>

&lt;p&gt;使用Emacs有一年多了吧，终于开始体会到它的强大。这段盘旋上升的磨合期，值得写几篇文章记录一下。这篇博客就是我用orgmode + hugo写博客的个人实践，希望对orgmode中文用户/hugo blogger有所启发。&lt;/p&gt;

&lt;h1 id=&#34;之前的workflow&#34;&gt;之前的workflow&lt;/h1&gt;

&lt;p&gt;自从转到hugo后，我发博客的workflow是这样的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在org文件里添加内容&lt;/li&gt;
&lt;li&gt;按下 &lt;code&gt;C-c C-e&lt;/code&gt; （export命令），再按 &lt;code&gt;C-s&lt;/code&gt; (只导出当前subtree)，再按 &lt;code&gt;m o&lt;/code&gt;
(导出格式markdown)，生成markdown 内容&lt;/li&gt;
&lt;li&gt;把markdown内容保存到 &lt;code&gt;hugo/content/&lt;/code&gt; 目录，手动加上文件头(front matter)&lt;/li&gt;
&lt;li&gt;本地部署hugo server，检查效果。无误则运行部署脚本 &lt;code&gt;deploy.sh&lt;/code&gt; push到github仓库的 &lt;code&gt;hugo&lt;/code&gt; 分支&lt;/li&gt;
&lt;li&gt;github上我给 &lt;code&gt;hugo&lt;/code&gt; 分支加了webhook，会触发构建，部署生成的html内容到 &lt;code&gt;gh-pages&lt;/code&gt; 分支&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这段流程一直还凑合，直到我的博客里出现表格：org导出的markdown表格会变成一坨翔，我要在第4步浪费很多时间人肉调整格式。&lt;/p&gt;

&lt;p&gt;怒google一把，发现是&lt;a href=&#34;http://orgmode.org/manual/Markdown-export.html&#34;&gt;org markdown官方导出引擎不支持table&lt;/a&gt;导致的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Since md is built on top of the HTML back-end, any Org constructs not supported by Markdown, such as tables, the underlying html back-end (see HTML export) converts them.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搜索时我发现有网友提到 &lt;code&gt;ox-pandoc&lt;/code&gt;
，点进去github主页看了看，pandoc和orgmode的天作之合啊。pandoc对表格的支持无懈可击，还有啥好说，马上就决定是它了！&lt;/p&gt;

&lt;h1 id=&#34;emacs安装ox-pandoc&#34;&gt;Emacs安装ox-pandoc&lt;/h1&gt;

&lt;h2 id=&#34;安装pandoc&#34;&gt;安装pandoc&lt;/h2&gt;

&lt;p&gt;因为ox-pandoc是对pandoc的调用封装，所以首先得装上pandoc。pandoc可能是haskell语言最著名的作品了，支持非常多种文件格式的互转，极其强大。官网有安装文档，不再赘述。
确认已装好:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pandoc -v
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;安装ox-pandoc&#34;&gt;安装ox-pandoc&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;官方github: &lt;a href=&#34;https://github.com/kawabata/ox-pandoc&#34;&gt;ox-pandoc主页&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;init.el&lt;/code&gt; 加上elpa源:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;(setq package-archives
   &#39;((&amp;quot;melpa&amp;quot; . &amp;quot;http://melpa.milkbox.net/packages/&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加hook:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;(with-eval-after-load &#39;ox
(require &#39;ox-pandoc))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删掉旧的markdown导出：&lt;/p&gt;

&lt;p&gt;找到类似配置，删掉&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;&#39;(require &#39;ox-md nil t)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重启emacs&lt;/p&gt;

&lt;p&gt;打开org文件，按下 &lt;code&gt;C-c C-e&lt;/code&gt; ，弹出的orgmode export dispather窗口中应该出现了 &lt;code&gt;p&lt;/code&gt;
开头的很多选项，而且原来 &lt;code&gt;m&lt;/code&gt; 开头的markdown选项不见了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;配置ox-pandoc-参数&#34;&gt;配置ox-pandoc 参数&lt;/h2&gt;

&lt;p&gt;ox-pandoc的导出选项可以配置在文档头部，就像org原生的导出选项配置一样。将官方wiki上关于文档的描述翻译如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Value nil overrides preceding option setting.
nil会覆盖之前为某个选项设置的值。

Value t means only specify option, but not its value.
t会打开某个选项的开关，而不会设置它的值。

Options are delimited by space.
多个选项间用空格分隔。

#+PANDOC_OPTIONS: can be specified multiple times. 
#+PANDOC_OPTIONS: 能多次使用。

If you want to specify the option value which include space character, quote entire option-value pair.
如果某个选项的值包含空格，那么要将“选项-值”都放到引号里。

Specifying Multiple values to single options by using colon-sparated lists.
给一个选项指定多个值，要使用逗号分隔的列表。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如，ox-pandoc给导出文档添加目录:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#+PANDOC_OPTIONS: toc-depth:3
#+PANDOC_OPTIONS: toc:t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再例如，使用ox-pandoc &lt;code&gt;C-c C-e p l&lt;/code&gt; 导出latex文档，如果中文不能正常显示，需要加上这两行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#+PANDOC_OPTIONS: pdf-engine:xelatex
#+PANDOC_OPTIONS: &amp;quot;variable:CJKmainfont:Noto Sans CJK SC&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;xelatex&lt;/em&gt; 是latex的一种处理引擎，对中文支持不错。如何安装xelatex，这里不赘述。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Noto Sans CJK SC&lt;/em&gt; 是我系统(Ubuntu)上安装的中文字体。用下面的命令查看安装了哪些中文字体:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fc-list :lang=zh
# 命令output: 字体名是两个冒号之间的、第一个逗号前的内容
# /usr/share/fonts/opentype/noto/NotoSansCJK-Light.ttc: Noto Sans CJK SC,Noto Sans CJK SC Light:style=Light,Regular
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置hugo-front-matter的snippet&#34;&gt;配置hugo front-matter的snippet&lt;/h2&gt;

&lt;p&gt;如果你像我一样正在用Emacs的 &lt;code&gt;yasnippet&lt;/code&gt;
包，可以参考我的做法，迅速添加带标题和日期的hugo文件头。这里参考了：&lt;a href=&#34;http://whyarethingsthewaytheyare.com/setting-up-the-blog/#workflow&#34;&gt;setting-up-the-blog&lt;/a&gt;
。&lt;/p&gt;

&lt;p&gt;添加yasnippet模板文件，然后在org的subtree开头按下 &lt;code&gt;hmatter [TAB]&lt;/code&gt; 即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# key: hmatter
# name: hugo-blog-matter
# --
#+BEGIN_SRC xxx
+++
title = &amp;quot;`(cdr (assoc &amp;quot;ITEM&amp;quot; (org-entry-properties)))`&amp;quot;
date = &amp;quot;`(format-time-string &amp;quot;%Y-%m-%dT%H:%M:%S&amp;quot;)`Z&amp;quot;
Categories = [&amp;quot;Tech&amp;quot;]
Tags = [&amp;quot;&amp;quot;]
Description = &amp;quot;&amp;quot;
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;现在的workflow&#34;&gt;现在的workflow&lt;/h1&gt;

&lt;p&gt;基本和之前的一样，但是现在导出按键顺序变成了&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;hmatter [TAB]&lt;/code&gt; 插入front-matter，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C-c C-e&lt;/code&gt; export命令，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C-s&lt;/code&gt; 只导出当前subtree，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p g&lt;/code&gt; 用pandoc导出github风格的markdown.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在导出的格式堪称完美，达到了我的预期。&lt;/p&gt;

&lt;p&gt;其实，最理想的workflow应该是写一个function把上述几步串起来，而且已经有人这么做了。等我哪天开始学elisp了，再来自己造轮子吧！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Emacs macOS配置中文字体</title>
      <link>https://blog.yuantops.com/tech/emacs-macos-chn-font-conf/</link>
      <pubDate>Sun, 10 Dec 2017 00:50:07 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/emacs-macos-chn-font-conf/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;从网上攒来的emacs字体配置地址&lt;br /&gt;
&lt;a href=&#34;https://github.com/yuantops/emacs.d/blob/universal/lisp/init-fonts.el&#34;&gt;https://github.com/yuantops/emacs.d/blob/universal/lisp/init-fonts.el&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;列出系统提供的所有字体&lt;br /&gt;
参考链接 &lt;a href=&#34;http://cnborn.net/blog/2014/10/emacs-chinese-font-on-osx/&#34;&gt;http://cnborn.net/blog/2014/10/emacs-chinese-font-on-osx/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;(print (font-family-list))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;找到中文字体，添加到chn font list 开头&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>sed和awk学习笔记</title>
      <link>https://blog.yuantops.com/tech/sed_awk_notes/</link>
      <pubDate>Sat, 09 Dec 2017 17:12:59 +0800</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/sed_awk_notes/</guid>
      <description>

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;为什么加上单引号: 防止shell
    expansion&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Enclosing the instruction in single quotes is not requir ed in all cases but you should get in the habit of always doing it. The enclosing single quotes prevent the shell from interpreting special characters or spaces found in the editing instruction.(The shell uses spaces to determine individual arguments submitted to a program;characters that are special to the shell are expanded before the command is invoked.)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通用语法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;awk -f scriptfile file
sed -f sedscript file
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;命令的组成: pattern和procedure&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;sed&#34;&gt;sed&lt;/h2&gt;

&lt;h3 id=&#34;sed里的模式空间-pattern-space&#34;&gt;sed里的模式空间 pattern space&lt;/h3&gt;

&lt;p&gt;Sed maintains a pattern space, a workspace or temporary buffer where a
single line of input is held while the editing commands are applied.*&lt;/p&gt;

&lt;p&gt;pattern space的内容是动态的(dynamic)，sed脚本中的任何一条命令都可能改变其中内容。&lt;/p&gt;

&lt;p&gt;As a consequence, any sed command might change the contents of the
pattern space for the next command.&lt;/p&gt;

&lt;h3 id=&#34;sed的addressing策略&#34;&gt;sed的addressing策略&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;vim中的替换命令默认只对当前行生效；sed不一样，sed命令默认对所有行生效。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以在命令前指定address。address可以是一个正则表达式,a line number,或者line addressing
symbol&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If no address is specified, then the command is applied to each
line.&lt;/li&gt;
&lt;li&gt;If there is only one address, the command is applied to any line
matching the address.&lt;/li&gt;
&lt;li&gt;If two comma-separated addresses are specified, the command is
performed on the first line matching the first address and all
succeeding lines up to and including a line matching the second
address.&lt;/li&gt;
&lt;li&gt;If an address is followed by an exclamation mark (!), the
command is applied to all lines that do not match the address.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于行号：sed 内部维护的行号，不是文件的行号。输入是多个文件时，只会有一个行号1。 The line number refers
to an internal line count maintained by sed. This counter is not
reset for multiple input files. Thus, no matter how many files were
specified as input, there is only one line 1 in the input stream&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果指定了两个address,那么命令只会在它们组成的range内生效。理解为：第一个address enable，第二个address
disable。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;地址后面出现的惊叹号，作用是反转地址匹配结果。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;sed的命令分组&#34;&gt;sed的命令分组&lt;/h3&gt;

&lt;p&gt;用花括号给命令行分组{}，用来在命令里嵌套命令，或者对同一个地址应用多个命令。to nest one address inside
another or to apply multiple commands at the same address.&lt;/p&gt;

&lt;h3 id=&#34;sed常用命令&#34;&gt;sed常用命令&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;替换s&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;syntaxt: [address]s/pattern/replacement/flags&lt;/li&gt;
&lt;li&gt;As a metacharacter, the ampersand (&amp;amp;) represents the extent of
the pattern match, not the line that was matched.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除d&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;变形Transform y&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;syntax: [address] y/abc/xyz&lt;/li&gt;
&lt;li&gt;逐个字符替换，而不是逐个单词替换&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打印p&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;输出pattern space的内容&lt;/li&gt;
&lt;li&gt;常用来debug&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打印行号= 跟在address后面的等号(=)会打印出匹配行的行号。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;读取文件内容r&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;syntax: [address]r file&lt;/li&gt;
&lt;li&gt;The read command reads the contents of file into the pattern
space after the addr essed line&lt;/li&gt;
&lt;li&gt;No subsequent command will affect the lines read from the file.
For instance, you can’t make any changes to the list of
companies that you’ve read into the file. However, commands that
address the original line will work.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;退出命令q&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;syntax: [line-address]q&lt;/li&gt;
&lt;li&gt;The quit command (q) causes sed to stop reading new input lines
(and stop sending them to the output)&lt;/li&gt;
&lt;li&gt;例子:
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- end list --&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 类似head -n 3
sed &#39;3q&#39; a.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;awk&#34;&gt;awk&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;awk是&amp;rdquo;输入驱动&amp;rdquo; input-driven. That is, nothing happens unless there are
lines of input on which to act. When you invoke the awk program, it
reads the script that you supply, checking the syntax of your
instructions. Then awk attempts to execute the instructions for each
line of input.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;假定“输入是结构化的”&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;begin-end-pattern&#34;&gt;BEGIN/END pattern&lt;/h3&gt;

&lt;p&gt;The &lt;strong&gt;BEGIN&lt;/strong&gt; pattern specifies actions that are performed before the
first line of input is read.&lt;/p&gt;

&lt;p&gt;If a program has only a BEGIN pattern, and no other statements, awk will
not process any input files.&lt;/p&gt;

&lt;p&gt;A BEGIN rule is executed once only, before the first input record is
read. Likewise, an END rule is executed once only, after all the input
is read.&lt;/p&gt;

&lt;h3 id=&#34;basic-programming-model&#34;&gt;Basic programming model&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;main input loop&lt;/strong&gt;: a routine that reads one line of input from a file
and makes it available for processing. Awk 默认提供，不需要手动实现。&lt;/p&gt;

&lt;p&gt;每一行都会执行。没有可读行时停止。&lt;/p&gt;

&lt;h3 id=&#34;模式匹配-pattern-matching&#34;&gt;模式匹配 pattern matching&lt;/h3&gt;

&lt;p&gt;与sed 类似，匹配到某种模式后才会执行命令。&lt;/p&gt;

&lt;p&gt;When awk reads an input line, it attempts to match each pattern-matching
rule in a script. Only the lines matching the particular pattern are the
object of an action.&lt;/p&gt;

&lt;p&gt;If no action is specified, the line that matches the pattern is printed
(executing the print statement is the default action)&lt;/p&gt;

&lt;h3 id=&#34;分隔符-fs-file-separator&#34;&gt;分隔符 FS file separator&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;默认FS: 空格&lt;/li&gt;
&lt;li&gt;单字符作分隔符&lt;/li&gt;
&lt;li&gt;多字符作分隔符: 被当做正则表达式&lt;/li&gt;
&lt;li&gt;一般在BEGIN section中定义FS。 Typically, the field and record separators
are defined in the BEGIN procedure because you want these values set
before the first input line is read.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;系统变量-system-variables&#34;&gt;系统变量 System Variables&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;FS: Field Seperator&lt;/li&gt;
&lt;li&gt;NF: 当前输入行的field count&lt;/li&gt;
&lt;li&gt;RS: record separator, 默认是换行符&lt;/li&gt;
&lt;li&gt;NR: 当前输入行的行号 the number of the current input record&lt;/li&gt;
&lt;li&gt;OFS: print 命令中，逗号会输出一个OFS。The output field separator (OFS) is
generated when a comma is used to separate the arguments in a print
statement.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;格式化输出-formatted-printing-printf&#34;&gt;格式化输出 Formatted Printing: &lt;strong&gt;printf&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;syntax: printf(format-expression[,arguments])&lt;/li&gt;
&lt;li&gt;format-expression: %-width.precision format-specifier。“-”表示左对齐&lt;/li&gt;
&lt;li&gt;The precision modifier, used for decimal or floating-point values,
controls the number of digits that appear to the right of the
decimal point. For string values, it controls the maximum number of
characters from the string that will be printed.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;向脚本中传递参数&#34;&gt;向脚本中传递参数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;awk &#39;script_content&#39; var=value datafile
awk -f scriptfile var=value datafile
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;字符串操作函数&#34;&gt;字符串操作函数&lt;/h3&gt;

&lt;p&gt;Awk Function
Description&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;gsub(r,s,t)&lt;/td&gt;
&lt;td&gt;Globally substitutes s for each match of the regular expression r in the string t. Returns the number of substitutions. If t is not supplied,defaults to $0.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;index(s,t)&lt;/td&gt;
&lt;td&gt;Returns position of substring t in string s or zero if not present.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;length(s)&lt;/td&gt;
&lt;td&gt;Returns length of string s or length of $0 if no string is supplied.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;match(s,r)&lt;/td&gt;
&lt;td&gt;Returns either the position in s wher e the regular expression r begins, or 0 if no occurrences are found. Sets the values of RSTART and RLENGTH.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;split(s,a,sep)&lt;/td&gt;
&lt;td&gt;Parses string s into elements of array a using field separator sep;retur ns number of elements. If sep is not supplied, FS is used. Array splitting works the same way as field splitting.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;sprintf(“fmt”,expr)&lt;/td&gt;
&lt;td&gt;Uses pr intf for mat specification for expr.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;sub(r,s,t)&lt;/td&gt;
&lt;td&gt;Substitutes s for first match of the regular expression r in the string t.Retur ns 1 if successful; 0 otherwise. If t is not supplied, defaults to$0.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;substr(s,p,n)&lt;/td&gt;
&lt;td&gt;Returns substring of string s at beginning position p up to amaximum length of n. If n is not supplied, the rest of the string from p is used.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tolower(s)&lt;/td&gt;
&lt;td&gt;Translates all uppercase characters in string s to lowercase and returns the new string.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;toupper(s)&lt;/td&gt;
&lt;td&gt;Translates all lowercase characters in string s to uppercase and returns the new string&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;使用-语法调用awk脚本&#34;&gt;使用#!语法调用awk脚本&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在脚本开头加上 #!/bin/awk -f&lt;/li&gt;
&lt;li&gt;用法: $ awkscript datafile&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>《Maven实战》摘抄</title>
      <link>https://blog.yuantops.com/tech/maven-in-action-notes/</link>
      <pubDate>Tue, 28 Nov 2017 19:16:30 +0800</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/maven-in-action-notes/</guid>
      <description>

&lt;h2 id=&#34;关键词-a-id-sec-1-1-name-sec-1-1-a&#34;&gt;关键词&lt;a id=&#34;sec-1-1&#34; name=&#34;sec-1-1&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;“约定优于配置” Convention Over Configuration&lt;/li&gt;
&lt;li&gt;生命周期管理&lt;/li&gt;
&lt;li&gt;依赖管理：GAV坐标+scope&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;术语翻译-a-id-sec-1-2-name-sec-1-2-a&#34;&gt;术语翻译&lt;a id=&#34;sec-1-2&#34; name=&#34;sec-1-2&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;table border=&#34;2&#34; cellpadding=&#34;6&#34; &gt;

&lt;thead&gt;
&lt;tr&gt;
&lt;th &gt;英文&lt;/th&gt;
&lt;th &gt;中文&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td &gt;artifact&lt;/td&gt;
&lt;td &gt;构件&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td &gt;build&lt;/td&gt;
&lt;td &gt;构建&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td &gt;project&lt;/td&gt;
&lt;td &gt;项目&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td &gt;group&lt;/td&gt;
&lt;td &gt;组&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td &gt;module&lt;/td&gt;
&lt;td &gt;模块&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td &gt;archetype&lt;/td&gt;
&lt;td &gt;骨架&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td &gt;dependency mediation&lt;/td&gt;
&lt;td &gt;依赖调解&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td &gt;repository&lt;/td&gt;
&lt;td &gt;仓库&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td &gt;phase&lt;/td&gt;
&lt;td &gt;阶段&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td &gt;aggregation&lt;/td&gt;
&lt;td &gt;聚合&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td &gt;reactor&lt;/td&gt;
&lt;td &gt;反应堆&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td &gt;property&lt;/td&gt;
&lt;td &gt;属性&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;关于主代码和测试代码位置-a-id-sec-1-3-name-sec-1-3-a&#34;&gt;关于主代码和测试代码位置&lt;a id=&#34;sec-1-3&#34; name=&#34;sec-1-3&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;在绝大多数情况下，应该把项目主代码放到src/main/java 目录下(遵循Maven的约定)，而无需额外的配置，Maven会自动搜寻该目录找到项目主代码。其次，该Java类的包名是com.juvenxu.mvnbook.helloword，这与之前在POM中定义的groupId和artifactId相吻合。一般来说，项目中Java类的包都应该基于项目的groupId和artifactId，这样更清晰，更加符合逻辑，也方便搜索构建或者Java类。

为了使项目结构保持清晰，主代码与测试代码应该分别位于独立的目录中。Maven项目中默认的主代码目录是src/main/java, 对应的，Maven项目中默认的测试代码目录是src/test/java。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关于pom配置中的scope-a-id-sec-1-4-name-sec-1-4-a&#34;&gt;关于POM配置中的scope&lt;a id=&#34;sec-1-4&#34; name=&#34;sec-1-4&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Maven 在编译项目主代码的时候需要使用一套classpath。其次，Maven在编译和执行测试时会使用另外一套classpath。上例中的JUnit就是一个很好的例子，该文件也以依赖的方式引入测试使用的classpath中，不同的是这里的依赖范围是test。最后，实际运行Maven项目的时候，又会使用一套classpath。
依赖范围就是用来控制依赖与这三种classpath(编译classpath, 测试classpath, 运行classpath)的关系。

scope为依赖范围，若依赖范围为test则表示该依赖只对测试有效(该依赖只会被加入到测试代码的classpath中)。换句话说，测试代码中的import JUnit代码是没有问题的，但是如果在主代码中用import JUnit代码，就会造成编译错误。如果不声明依赖范围，那么默认值就是compile，表示该依赖对主代码和测试代码都有效。
&lt;/code&gt;&lt;/pre&gt;

&lt;table border=&#34;2&#34; cellspacing=&#34;0&#34; cellpadding=&#34;6&#34; rules=&#34;groups&#34; frame=&#34;hsides&#34;&gt;

&lt;thead&gt;
&lt;tr&gt;
&lt;th scope=&#34;col&#34; &gt;scope&lt;/th&gt;
&lt;th scope=&#34;col&#34; &gt;编译classpath有效&lt;/th&gt;
&lt;th scope=&#34;col&#34; &gt;测试classpath有效&lt;/th&gt;
&lt;th scope=&#34;col&#34; &gt;运行时classpath有效&lt;/th&gt;
&lt;th scope=&#34;col&#34; &gt;例子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td  &gt;compile&lt;/td&gt;
&lt;td  &gt;Y&lt;/td&gt;
&lt;td  &gt;Y&lt;/td&gt;
&lt;td  &gt;Y&lt;/td&gt;
&lt;td  &gt;spring-core&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td  &gt;test&lt;/td&gt;
&lt;td  &gt;-&lt;/td&gt;
&lt;td  &gt;Y&lt;/td&gt;
&lt;td  &gt;-&lt;/td&gt;
&lt;td  &gt;JUnit&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td  &gt;provided&lt;/td&gt;
&lt;td  &gt;Y&lt;/td&gt;
&lt;td  &gt;Y&lt;/td&gt;
&lt;td  &gt;-&lt;/td&gt;
&lt;td  &gt;servlet-api&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td  &gt;runtime&lt;/td&gt;
&lt;td  &gt;-&lt;/td&gt;
&lt;td  &gt;Y&lt;/td&gt;
&lt;td  &gt;Y&lt;/td&gt;
&lt;td  &gt;JDBC驱动实现&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td  &gt;system&lt;/td&gt;
&lt;td  &gt;Y&lt;/td&gt;
&lt;td  &gt;Y&lt;/td&gt;
&lt;td  &gt;-&lt;/td&gt;
&lt;td  &gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;关于打包生成可直接运行的jar-a-id-sec-1-5-name-sec-1-5-a&#34;&gt;关于打包生成可直接运行的jar&lt;a id=&#34;sec-1-5&#34; name=&#34;sec-1-5&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;默认打包生成的jar是不能够直接运行的，因为带有main方法的类信息不会添加到manifest中(打开jar文件中的META-INF/MANIFEST.MF文件，将无法看到Main-Class一行)。为了生成可执行的jar文件，需要借助maven-shade-plugin.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关于maven的坐标-a-id-sec-1-6-name-sec-1-6-a&#34;&gt;关于Maven的坐标&lt;a id=&#34;sec-1-6&#34; name=&#34;sec-1-6&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Maven 坐标为各种构件引入了秩序，任何一个构件都必须明确定义自己的坐标，而一组Maven坐标是通过一些元素定义的，它们是groupId, artifactId，version, packaging, classifier。
上述5个元素中，groupId, artifactId, version是必须定义的，packaging是可选的(默认为Jar)，而classifier是不能直接定义的。

groupId: 定义当前Maven项目隶属的实际项目。首先，Maven项目和实际项目不一定是一对一的关系。比如SpringFramework这一实际项目，其对应的Maven项目会有很多，如spring-core, spring-context等。这是由于Maven中模块的概念，因此，一个实际项目往往会被划分成很多模块。其次，groupId不应该对应项目隶属的组织或公司。原因很简单，一个组织下会有很多实际项目，如果groupId只定义到组织级别，而后面我们将看到，artifactId只能定义Maven项目(模块)，那么实际项目这个层将难以定义。最后，groupId的表示方式与Java包名的表示方式类似，通常与域名反向一一对应。

artifactId:该元素定义实际项目中的一个Maven项目(模块)，推荐的做法是使用实际项目名称作为artifactId的前缀。比如上例中的artifactId是nexus-indexer，使用了实际项目名nexus作为前缀，这样做的好处是方便寻找实际构件。

classifier:该元素用来帮助定义构建输出的一些附属附件。附属构件与主构件对应，。。。.javadoc和sources就是这两个附属构件的classifier。这样，附属构件也就拥有了自己唯一的坐标。。。。注意，不能直接定义项目的classifier，因为附属构件不是项目默认生成的，而是由附加的插件帮助生成的。

一般来说，一个项目的子模块都应该使用同样的groupId,如果它们一起开发和发布，还应该使用同样的version。此外，它们的artifactId还应该使用一致的前缀，以方便和其他项目区分。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关于maven构件的文件名-a-id-sec-1-7-name-sec-1-7-a&#34;&gt;关于Maven构件的文件名&lt;a id=&#34;sec-1-7&#34; name=&#34;sec-1-7&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;项目构件的文件名是与坐标相对应的，一般的规则为artifactId-version[-classifier].packaging, [-classifier]表示可选。
这里还要强调的一点是，packaging并非一定与构件扩展名对应，比如packaging为maven-plugin的构件构件扩展名为jar。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关于maven仓库-a-id-sec-1-8-name-sec-1-8-a&#34;&gt;关于Maven仓库&lt;a id=&#34;sec-1-8&#34; name=&#34;sec-1-8&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;得益于坐标机制，任何Maven项目使用任何一个构件的方式都是完全相同的。在此基础上，Maven可以在某个位置统一存储所有Maven项目共享的构件，这个统一的位置就是仓库。实际的Maven项目将不再各自存储其依赖文件，它们只需要声明这些依赖的坐标，在需要的时候（例如，编译项目的时候需要将依赖加入到classpath中），Maven会自动根据坐标找到仓库中的构件，并使用它们。

仓库布局：仓库路径与坐标的大致对应关系为groupId/artifactid/version/artifactId-verison.packaging

对于Maven来说，仓库只分两类：本地仓库和远程仓库。当Maven根据坐标寻找构件的时候，它首选会查看本地仓库，如果本地仓库存在此构件，则直接使用；如果本地仓库不存在此构件，或者需要查看是否有更新的构件版本，Maven仓库就会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。如果本地仓库和远程仓库都没有需要的构件，Maven就会报错。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关于快照版本-a-id-sec-1-9-name-sec-1-9-a&#34;&gt;关于快照版本&lt;a id=&#34;sec-1-9&#34; name=&#34;sec-1-9&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;在Maven的世界中，任何一个项目或者构件都必须有自己的版本。版本的的值可能是1.0.0,1.3-alpha-4,2.0,2.1-SNAPSHOT或者2.1-20091212.221212-12。其中，2.0,2.1-SNAPSHOT或者2.1-20091212.221212-12是不稳定的快照版本。

快照版本只应该在组织内部的项目或模块间依赖使用，因为这时，组织对于这些快照版本的依赖具有完全的理解以及控制权。项目不应该依赖于任何组织外部的快照版本依赖，由于快照版本的不稳定性，这样的依赖会造成现在的危险。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关于生命周期与插件绑定-a-id-sec-1-10-name-sec-1-10-a&#34;&gt;关于生命周期与插件绑定&lt;a id=&#34;sec-1-10&#34; name=&#34;sec-1-10&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Maven 拥有三套相互独立的生命周期，它们分别是clean, default和site。clean生命周期的目的是清理项目，default生命周期的目的是构建项目，而site生命周期的目的是建立项目站点。
每个生命周期包含一些阶段(phase),这些阶段是有顺序，并且后面的阶段依赖于前面的阶段，用户和Maven最直接的交互方式就是调用这些生命周期阶段。

Maven的生命周期与插件相互绑定，用以完成实际的构建任务。具体而言，是生命周期的阶段与插件的目标相互绑定，以完成某个具体的构建任务。

Maven在核心为一些主要的生命周期阶段绑定了很多插件的目标，当用户通过命令行调用生命周期阶段的时候，对应的插件目标就会执行相应的任务。

如果多个目标被绑定到同一个阶段的时候，这些插件声明的先后顺序决定了目标的执行顺序。

插件解析机制
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关于聚合-多模块-a-id-sec-1-11-name-sec-1-11-a&#34;&gt;关于聚合(多模块)&lt;a id=&#34;sec-1-11&#34; name=&#34;sec-1-11&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;为了方便用户构建项目，通常将聚合模块放在项目目录的最顶层，其他模块则作为聚合模块的子目录存在，这样当用户得到源码的时候，第一眼发现的就是聚合模块的POM，不用从多个模块中去寻找聚合模块来构建整个项目。

Maven会首先解析聚合模块的POM、分析要构建的模块、并计算出一个反应堆构建顺序(Reactor Build Order)，然后根据这个顺序依次构建各个模块。反应堆是所有模块组成的一个构建结构。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关于继承与聚合的关系-a-id-sec-1-12-name-sec-1-12-a&#34;&gt;关于继承与聚合的关系&lt;a id=&#34;sec-1-12&#34; name=&#34;sec-1-12&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;多模块项目中的聚合与继承其实是两个概念，其目的是完全不同的。前者主要是为了方便快速构建项目，后者主要是为了消除重复配置。

对于聚合模块来说，它知道有哪些被聚合的模块，但那些被聚合的模块不知道这个聚合模块的存在。

对于继承关系的父POM来说，它不知道有哪些子模块继承于它，但那些子模块都必须知道自己的父POM是什么。

在现有的实际项目中，读者往往发现一个POM既是聚合POM，又是父POM，这么做主要是为了方便。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关于反应堆的构建顺序-a-id-sec-1-13-name-sec-1-13-a&#34;&gt;关于反应堆的构建顺序&lt;a id=&#34;sec-1-13&#34; name=&#34;sec-1-13&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;在一个多模块的Maven项目中，反应堆(Reactor)是指所有模块组成的一个构建结构。对于单模块的项目，反应堆就是该模块本身，但对于多模块项目来说，反应堆就包含了各模块之间继承与依赖的关系，从而能够自动计算出合理的模块构建顺序。

模块间的依赖关系会将反应堆构成一个有向非循环图(DAG)，各个模块是该图的节点，依赖关系构成了有向边。这个图不允许出现循环，因此，当出现模块A依赖于B，而B又依赖于A的情况出现时，Maven就会报错。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关于选择性构建单个多个模块-a-id-sec-1-14-name-sec-1-14-a&#34;&gt;关于选择性构建单个多个模块&lt;a id=&#34;sec-1-14&#34; name=&#34;sec-1-14&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;-am, --also-make 同时构建所列模块的依赖模块

-amd, --also-make-dependencies 同时构建依赖于所列模块的模块

-pl, --projects &amp;lt;args&amp;gt; 构建指定的模块，模块间用逗号隔开
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关于maven灵活构建-属性-a-id-sec-1-15-name-sec-1-15-a&#34;&gt;关于Maven灵活构建-&amp;gt;属性&lt;a id=&#34;sec-1-15&#34; name=&#34;sec-1-15&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Maven支持的6类属性分别为：
1. 内置属性：主要有两个内置属性--${basedir}表示项目根目录，即包含pom.xml文件的目录；${version}表示项目版本
2. POM属性：用户可以使用该类属性引用POM文件中对应元素的值。例如，${project.artifactId}就对应了&amp;lt;project&amp;gt;&amp;lt;artifactId&amp;gt;元素的值。
3. 自定义属性：用户可以在POM的&amp;lt;properties&amp;gt;元素下自定义的Maven属性。
4. Settings属性：与POM属性同理，用户使用以setting. 开头的属性引用settings.xml 文件中XML元素的值，如常用的${settings.localRepository}指向用户本地仓库的地址。
5. Java系统属性：所有Java系统属性都可以使用Maven属性引用。例如${user.home}指向了用户目录。用户可以使用mvn help:system 查看所有的Java系统属性。
6. 环境变量属性：所有环境变量都可以使用以env. 开头的Maven属性引用。例如${env.JAVA_HOME}指代了JAVA_HOME环境变量的值。用户可以使用mvn help:system 查看所有的环境变量
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关于maven灵活构建-资源过滤-a-id-sec-1-16-name-sec-1-16-a&#34;&gt;关于Maven灵活构建-&amp;gt;资源过滤&lt;a id=&#34;sec-1-16&#34; name=&#34;sec-1-16&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Maven属性默认只有在POM中才会被解析。也就是说，${db.username}放到POM中会变成test，但是如果放到src/main/resources/目录下的文件中，构建的时候它仍然还是${db.username}。

资源文件的处理其实是maven-resource-plugin做的事情。它默认的行为只是将项目主资源文件复制到主代码编译输出目录中，将测试资源文件复制到测试代码编译输出目录中。不过只要通过一些简单的POM配置，该插件就能够解析资源文件中的Maven属性，即开启资源过滤。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关于maven灵活构建-profile-a-id-sec-1-17-name-sec-1-17-a&#34;&gt;关于Maven灵活构建-&amp;gt;Profile&lt;a id=&#34;sec-1-17&#34; name=&#34;sec-1-17&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;为了能让构建在各个环境下方便地移植，Maven引入了profile的概念。profile能够在构建的时候修改POM的一个子集，或者添加额外的配置元素。用户可以通过使用很多方式激活profile，以实现构建在不同环境下的移植。

Maven 支持很多种激活Profile的方式。
1. 命令行激活
2. settings文件激活
3. 系统属性激活
4. 操作系统环境激活
5. 文件存在与否激活
6. 默认激活
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>MyBatis generator生成Dao和Mapper小记</title>
      <link>https://blog.yuantops.com/tech/mybatis-mbg-cmd/</link>
      <pubDate>Tue, 17 Oct 2017 10:30:53 +0800</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/mybatis-mbg-cmd/</guid>
      <description>

&lt;h2 id=&#34;需下载文件-a-id-sec-1-1-name-sec-1-1-a&#34;&gt;需下载文件&lt;a id=&#34;sec-1-1&#34; name=&#34;sec-1-1&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Mybatis Generator jar包&lt;/p&gt;

&lt;p&gt;下载地址 &lt;a href=&#34;https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core&#34;&gt;https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;JDBC 驱动jar 包&lt;/p&gt;

&lt;p&gt;对MySQL数据库而言，下载MySQL connector。下载地址 &lt;a href=&#34;https://mvnrepository.com/artifact/mysql/mysql-connector-java&#34;&gt;https://mvnrepository.com/artifact/mysql/mysql-connector-java&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;配置config-xml-a-id-sec-1-2-name-sec-1-2-a&#34;&gt;配置config.xml&lt;a id=&#34;sec-1-2&#34; name=&#34;sec-1-2&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;config.xml 文件指定自动生成代码时的一些配置项：数据库的url, 用户名密码，生成类名、导出地址等。&lt;/p&gt;

&lt;p&gt;数据库url, 用户名，密码是最重要的配置。&lt;/p&gt;

&lt;p&gt;下面是示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE generatorConfiguration
  PUBLIC &amp;quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&amp;quot;
  &amp;quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&amp;quot;&amp;gt;
&amp;lt;generatorConfiguration&amp;gt;
    &amp;lt;!--数据库驱动, 注意jar包版本号与实际下载的版本号一致--&amp;gt;
    &amp;lt;classPathEntry    location=&amp;quot;mysql-connector-java-3.1.13.jar&amp;quot;/&amp;gt;
    &amp;lt;context id=&amp;quot;DB2Tables&amp;quot;    targetRuntime=&amp;quot;MyBatis3&amp;quot;&amp;gt;
        &amp;lt;commentGenerator&amp;gt;
            &amp;lt;property name=&amp;quot;suppressDate&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;suppressAllComments&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;/commentGenerator&amp;gt;
        &amp;lt;!--数据库链接地址账号密码, 更新此处--&amp;gt;
        &amp;lt;jdbcConnection driverClass=&amp;quot;com.mysql.jdbc.Driver&amp;quot; connectionURL=&amp;quot;jdbc:mysql://xx.xxx.xxx.xx:36360/?characterEncoding=UTF-8&amp;quot; userId=&amp;quot;xxx&amp;quot; password=&amp;quot;xxx&amp;quot;&amp;gt;
        &amp;lt;/jdbcConnection&amp;gt;
        &amp;lt;javaTypeResolver&amp;gt;
            &amp;lt;property name=&amp;quot;forceBigDecimals&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
        &amp;lt;/javaTypeResolver&amp;gt;
        &amp;lt;!--生成Model类存放位置--&amp;gt;
        &amp;lt;javaModelGenerator targetPackage=&amp;quot;domain&amp;quot; targetProject=&amp;quot;src&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;trimStrings&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;/javaModelGenerator&amp;gt;
        &amp;lt;!--生成映射文件存放位置--&amp;gt;
        &amp;lt;sqlMapGenerator targetPackage=&amp;quot;dao&amp;quot; targetProject=&amp;quot;src&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;/sqlMapGenerator&amp;gt;
        &amp;lt;!--生成Dao类存放位置--&amp;gt;
        &amp;lt;javaClientGenerator type=&amp;quot;XMLMAPPER&amp;quot; targetPackage=&amp;quot;mapper&amp;quot; targetProject=&amp;quot;src&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;/javaClientGenerator&amp;gt;
        &amp;lt;!--生成对应表及类名--&amp;gt;
        &amp;lt;table tableName=&amp;quot;%&amp;quot;  enableCountByExample=&amp;quot;true&amp;quot; enableUpdateByExample=&amp;quot;true&amp;quot; enableDeleteByExample=&amp;quot;true&amp;quot; enableSelectByExample=&amp;quot;true&amp;quot; selectByExampleQueryId=&amp;quot;true&amp;quot;&amp;gt;
        &amp;lt;/table&amp;gt;
    &amp;lt;/context&amp;gt;
&amp;lt;/generatorConfiguration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;运行命令-a-id-sec-1-3-name-sec-1-3-a&#34;&gt;运行命令&lt;a id=&#34;sec-1-3&#34; name=&#34;sec-1-3&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;将上面的文件放到一个目录，结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tree 
.
├── config.xml
├── mybatis-generator-core-1.3.0.jar
└── mysql-connector-java-3.1.13.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行命令，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -jar mybatis-generator-core-1.3.0.jar -configfile config.xml -overwrite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自动生成的&lt;code&gt;src&lt;/code&gt;目录包含生成的代码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>整理Java有限状态机</title>
      <link>https://blog.yuantops.com/tech/fsm_and_java_implementation/</link>
      <pubDate>Thu, 12 Oct 2017 14:30:53 +0800</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/fsm_and_java_implementation/</guid>
      <description>

&lt;h2 id=&#34;有限状态机fsm及它的构成要素-a-id-sec-1-1-name-sec-1-1-a&#34;&gt;有限状态机FSM及它的构成要素&lt;a id=&#34;sec-1-1&#34; name=&#34;sec-1-1&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition.&lt;/p&gt;

&lt;p&gt;有限状态机由状态集合, 初始状态, 状态转移条件定义。&lt;/p&gt;

&lt;h2 id=&#34;java实现-a-id-sec-1-2-name-sec-1-2-a&#34;&gt;Java实现&lt;a id=&#34;sec-1-2&#34; name=&#34;sec-1-2&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;根据FSM定义，可以抽象出Java的3种数据类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;状态(State)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;事件(Event)&lt;/p&gt;

&lt;p&gt;事件触发状态转移，是状态机的输入。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上下文(Context)&lt;/p&gt;

&lt;p&gt;上下文，可以包含各种Condition。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例子：当前状态A，此时输入事件E，如果满足条件C，会导致状态A转换到状态B。这种情况下，A,B是State，E是Event，C是Context下的Condition。&lt;/p&gt;

&lt;h2 id=&#34;具体代码-a-id-sec-1-3-name-sec-1-3-a&#34;&gt;具体代码&lt;a id=&#34;sec-1-3&#34; name=&#34;sec-1-3&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;状态机运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public State run() {
    for (State s = initState; s != null; s = s.next(context)) {
    // do something here
    }
    return state;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;State, Event用Enum, 且State一定包含next() method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public enum State {

    INIT(0, &amp;quot;未初始化&amp;quot;) {
        @Override
        public State next(Context context) {
            switch (context.getEvent()) {
                case Event1:
                    return context.condition1() ? STATE_1 : STATE_2;
                default:
                    return null;
            }
        }
    },
    STATE_1(1, &amp;quot;状态1&amp;quot;) {
        @Override
        public State next(Context context) {
            context.setState(STATE_1);
            switch (context.getEvent()) {
                case Event1:
                    return context.condition2() ? STATE_3 : null;
                default:
                    return null;
            }
        }
    };

    private Byte code;
    private String desc;

    State(int code, String desc) {
        this.code = (byte) code;
        this.desc = desc;
    }

    public abstract State next(Context context);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Context是一系列Condition组合得到的interface&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface Context {
    void setState(State state);

    /**
     * 得到Event input
     * @return
     */
    EventEnum getEvent();

    /**
     * 是否满足条件1
     * @return
     */
    Boolean condition1();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;组合得到FSM的定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class FSM implements Context {

     private EventEnum event;

     private State    state;

     public FSM(State initState) {
         this.state = initState;
     }

     public State run() {
         for (State s = initState; s != null; s = s.next(this)) {
         }
         return state;
     }

     @Override
     public EventEnum getEvent() {
         return event;
     }

     //implements conditions 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>JMX学习笔记</title>
      <link>https://blog.yuantops.com/tech/jmx-overview/</link>
      <pubDate>Sat, 22 Jul 2017 18:26:25 +0800</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/jmx-overview/</guid>
      <description>

&lt;p&gt;JMX，全称&lt;code&gt;Java Management Extensions&lt;/code&gt;，借用贾宝玉的一句话描述它：「这个妹妹，我曾见过的。」&lt;/p&gt;

&lt;p&gt;见过却不熟悉，它在我心中是Java规范中比较冷门的一个角落。&lt;/p&gt;

&lt;p&gt;几次看到Java的招聘JD要求对JMX的理解，所以，在Oracle官网翻到教程，跟着学习学习。&lt;/p&gt;

&lt;h2 id=&#34;oracle教程地址&#34;&gt;Oracle教程地址&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/jmx/TOC.html&#34;&gt;Java Management Extensions(JMX): Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这份文档讲的内容很基础，介绍了JMX的整体架构、用处、基础组件，以及给出了带代码的简单演示。&lt;/p&gt;

&lt;h2 id=&#34;jmx用来做什么&#34;&gt;JMX用来做什么？&lt;/h2&gt;

&lt;p&gt;JMX是Java 标准规范的一部分，可以用来 &lt;strong&gt;监控&lt;/strong&gt; 和 &lt;strong&gt;管理&lt;/strong&gt; JVM中运行时的资源。除了监控运行时占用的CPU、内核、线程资源，JMX还可以让你直接invoke 方法、修改对象属性（有点暴力了吧。。）。&lt;br /&gt;
- JDK中自带的&lt;code&gt;jconsole&lt;/code&gt;工具，利用的就是JMX。&lt;/p&gt;

&lt;p&gt;JMX可以将管理接口暴露成HTTP调用，这样，通过ip和端口号可以远程监控、管理服务器上的JVM。&lt;br /&gt;
 - 远程调试需要打开服务器上打开某个端口，利用的也是JMX。&lt;br /&gt;
 - Tomcat有个HTTP 的管理页面，用的也是JMX。&lt;/p&gt;

&lt;h2 id=&#34;jmx怎么用&#34;&gt;JMX怎么用&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;监控JVM&lt;br /&gt;
JVM自带支持JMX，开箱即用(&lt;code&gt;out-of-box&lt;/code&gt;)。意味着，不需要额外操作就可以用&lt;code&gt;jconsole&lt;/code&gt;之类的命令监控JVM。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;监控Applicaiton&lt;br /&gt;
Application的实现得满足JMX标准。JMX标准是什么，见下文。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;jmx标准&#34;&gt;JMX标准&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;MBeans&lt;br /&gt;
JMX将它管理的对象称为&lt;code&gt;MBean&lt;/code&gt;。换言之，要使用JMX，就得把要管理的资源封装成MBeans。&lt;/p&gt;

&lt;p&gt;JMX定义了几类&lt;code&gt;MBeans&lt;/code&gt;，就标准MBeans(&lt;code&gt;Standard MBeans&lt;/code&gt;)而言，它是这么定义的：后缀为&lt;code&gt;MBean&lt;/code&gt;的interface(例如&lt;code&gt;HelloMBean&lt;/code&gt;), 以及除去&lt;code&gt;MBean&lt;/code&gt;后缀的实现MBean的实现类(这里就是&lt;code&gt;Hello&lt;/code&gt;)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;JMX Agent&lt;br /&gt;
JMX Agent又称为JMX Server，用来管理MBeans。&lt;/p&gt;

&lt;p&gt;关键的代码类似：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MBeanServer mbs = ManagementFactory.getPlatformMBeanServer(); 
ObjectName name = new ObjectName(&amp;quot;com.example:type=Hello&amp;quot;); 
Hello mbean = new Hello(); 
mbs.registerMBean(mbean, name);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;JMX Connector&lt;br /&gt;
用&lt;code&gt;JVM connector&lt;/code&gt;，MBean可以暴露给远程客户端，然后远程客户端就可以管理它了。&lt;/p&gt;

&lt;p&gt;常用的Connector包括：HTTP，RMI。与之对应的管理client: web浏览器，JMX Client。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;jmx的通知机制&#34;&gt;JMX的通知机制&lt;/h2&gt;

&lt;p&gt;JMX允许MBeans发送通知。&lt;/p&gt;

&lt;p&gt;如果MBeans实现了发送Notification的逻辑，就可以用&lt;code&gt;jconsole&lt;/code&gt;一类的工具收到通知。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>申请Google Voice号码以及帐号充值小记</title>
      <link>https://blog.yuantops.com/tech/apply-gv-no-and-purchase-credit/</link>
      <pubDate>Fri, 21 Jul 2017 22:30:53 +0800</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/apply-gv-no-and-purchase-credit/</guid>
      <description>

&lt;p&gt;现在，各种网站窥探用户隐私时越来越理直气壮：注册帐号，非得验证手机号不可。&lt;br /&gt;
（当然，他们往往打着&lt;a href=&#34;http://news.sina.com.cn/c/2017-05-03/doc-ifyetxec7370675.shtml&#34;&gt;《网络安全法》实施&lt;/a&gt;的旗号。）&lt;/p&gt;

&lt;p&gt;在知乎上看完网友写的&lt;a href=&#34;https://zhuanlan.zhihu.com/p/27807882&#34;&gt;在国内拥有一个美国电话号码的必要性&lt;/a&gt;，我立刻决定，自己也要来一个美国号码。&lt;/p&gt;

&lt;p&gt;下面是我艰辛的折腾记录。&lt;/p&gt;

&lt;h2 id=&#34;google-voice是个不错的选择&#34;&gt;Google Voice是个不错的选择&lt;/h2&gt;

&lt;p&gt;用户可以在Google Voice上申请虚拟美国电话号码，可以将短信转发到Google Voice的App (iOS上可以用Hangouts)。同时，资费良心，打给国内每分钟也才1美分。&lt;/p&gt;

&lt;p&gt;最最重要的，网上申请GV 号码的教程简直汗牛充栋，有了前人栽树，有什么理由不选它乘凉呢？&lt;/p&gt;

&lt;h2 id=&#34;失败-diy-textnow-自己申请&#34;&gt;[失败] DIY: TextNow + 自己申请&lt;/h2&gt;

&lt;p&gt;于是，怀着工科生的自信，我开始按&lt;a href=&#34;https://kn007.net/topics/free-application-for-google-voice-phone-number/&#34;&gt;这份教程&lt;/a&gt;的步骤一步步操作。&lt;/p&gt;

&lt;p&gt;我发现，第一个问题就难倒我：我的TextNow死也注册不成功。全程美国IP，但就是点到&amp;rdquo;submit&amp;rdquo; 就报错。&lt;/p&gt;

&lt;p&gt;其间尝试过TextNow 的手机app 注册，发现手机版好像不支持在线接听电话。&lt;/p&gt;

&lt;p&gt;总之，我被弄得没脾气。然后，我把目光投向了万能的淘宝……&lt;/p&gt;

&lt;h2 id=&#34;成功-淘宝搞定google-voice帐号&#34;&gt;[成功] 淘宝搞定Google Voice帐号&lt;/h2&gt;

&lt;p&gt;淘宝果然没有让人失望。输入&lt;code&gt;Google Voice&lt;/code&gt;关键字，宝贝不要太多。随便选了一家，拍下，然后按客服的指引操作，顺利搞定。&lt;/p&gt;

&lt;p&gt;淘宝卖家的做法还和我想的不太一样(原本我以为他们是现场申请的)。他们囤着很多Google 小号，每个小号申请一个Google Voice号码。你下单，他会把GV号码过户到你的Google帐号。过户全程需要美国IP，需要登录新旧两个Google 帐号，所以要么你把自己的帐号密码给卖家操作，要么卖家把他的小号给你操作。我自己操作的。&lt;/p&gt;

&lt;p&gt;你问工科生的自尊心么？呵呵，当然扔掉啦！&lt;/p&gt;

&lt;h2 id=&#34;下载hangouts&#34;&gt;下载Hangouts&lt;/h2&gt;

&lt;p&gt;iOS App Store中国区 &lt;strong&gt;居然&lt;/strong&gt; 可以下载Hangouts。挂上梯子，点开Hangouts，填刚刚申请到手的号码，此时发送的验证码在Google Voice的网页界面看到。&lt;/p&gt;

&lt;p&gt;到此为止，基本就搞定。&lt;/p&gt;

&lt;h2 id=&#34;给google-voice充钱&#34;&gt;给Google Voice充钱&lt;/h2&gt;

&lt;p&gt;充钱是额外选项，完全可以跳过。充了钱可以打电话，还是充点钱吧。&lt;/p&gt;

&lt;p&gt;我用建行的visa卡充的。开始死活不成功，把信用卡的bill address改成*美国地址*后顺利成功。这真是坑，莫名其妙的问题，误打误撞解了。&lt;/p&gt;

&lt;p&gt;讲真，看到付款邮件的那一刻，眼角有泪划过。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Emacs阅读C/C&#43;&#43;代码——生成TAGS文件</title>
      <link>https://blog.yuantops.com/tech/emacs-create-etags/</link>
      <pubDate>Wed, 19 Jul 2017 21:35:16 +0800</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/emacs-create-etags/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;生成TAGS文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find . -iname &amp;quot;*.[chCHS]&amp;quot; | etags -  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Emacs 导入TAGS文件&lt;br /&gt;
在emacs中，&lt;code&gt;M-x visit-tags-table&lt;/code&gt;，选择刚刚生成的TAG文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;命令：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;跳转到光标所在词对应的标签：&lt;code&gt;M-.&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;回退到上个位置：&lt;code&gt;M-*&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>mkfs 报invalid block count错误</title>
      <link>https://blog.yuantops.com/tech/mkfs-t-not-supported/</link>
      <pubDate>Tue, 27 Jun 2017 10:34:04 +0800</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/mkfs-t-not-supported/</guid>
      <description>

&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;

&lt;p&gt;在rh 5u7 上用mkfs 创建文件系统，命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkfs -q -t ext3 -L disk0 /dev/sdb1  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;居然报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;……invalid blocks count……  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;排查&#34;&gt;排查&lt;/h2&gt;

&lt;p&gt;仔细阅读&lt;code&gt;man mkfs&lt;/code&gt;使用文档，是这样写的，没发现哪里用得不对。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkfs [-V] [-t fstype] [fs-options] filesys [blocks]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Google，发现是&lt;a href=&#34;https://unix.stackexchange.com/questions/39998/creating-an-ext4-partition-fails-with-invalid-blocks-count&#34;&gt;mkfs 解析参数发生了错误&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;原因很简单，&lt;code&gt;mkfs&lt;/code&gt; 其实是&lt;code&gt;mkfs.type&lt;/code&gt; 的快捷方式。5u 的mkfs 版本过低，不支持&lt;code&gt;-t&lt;/code&gt;参数，所以阴差阳错把最后的参数&lt;code&gt;/dev/sdb1&lt;/code&gt; 当作了&lt;code&gt;[blocks]&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;解法&#34;&gt;解法&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;安装&lt;code&gt;e4fsprogs&lt;/code&gt;，这是操作ext4 的工具包。官方文档&lt;a href=&#34;https://rhn.redhat.com/errata/RHEA-2009-0217.html&#34;&gt;在此&lt;/a&gt;。&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;改用&lt;code&gt;mkfs.ext4&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkfs.ext4 -q -t ext3 -L disk0 /dev/sdb1  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>JVM 和Java GC 笔记</title>
      <link>https://blog.yuantops.com/tech/jvm-gc-note-1/</link>
      <pubDate>Wed, 21 Jun 2017 23:32:37 +0800</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/jvm-gc-note-1/</guid>
      <description>

&lt;h2 id=&#34;学习材料&#34;&gt;学习材料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;讲义地址： &lt;a href=&#34;http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html&#34;&gt;http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Youtube 视频地址：  &lt;a href=&#34;https://www.youtube.com/watch?v=DoJr5QQYsl8&#34;&gt;Video The JVM and Java Garbage Collection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;java-jvm概述&#34;&gt;Java &amp;amp; JVM概述&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Garbage Collection is automatic.&lt;/li&gt;
&lt;li&gt;Java source code is compiled into byte code.&lt;/li&gt;
&lt;li&gt;Byte code is stored in .class files&lt;/li&gt;
&lt;li&gt;.class files are loaded into a Java Virtual Machine(JVM) and executed.&lt;/li&gt;
&lt;li&gt;A seperated JVM is created for each Java application. (备注：！每个Java程序都对应着一个单独的JVM)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;gc-的职责&#34;&gt;GC 的职责&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;为新对象分配memory&lt;/li&gt;
&lt;li&gt;确保被引用的对象留在memory Ensuring that any referenced objects(live objects) remain in memory&lt;/li&gt;
&lt;li&gt;回收死掉的对象占用的memory Recovering memory used by objects that no longer reachable(dead objects)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;gc的stages&#34;&gt;GC的stages&lt;/h2&gt;

&lt;p&gt;step 1. marking(标记将被删除的对象)&lt;br /&gt;
step 2. Normal Deletion/sweeping(删除标记的对象)&lt;br /&gt;
step 3. Deletion with Compacting (整理内存，把碎片归拢)&lt;/p&gt;

&lt;h2 id=&#34;generational-collection&#34;&gt;Generational Collection&lt;/h2&gt;

&lt;p&gt;出发点：Java中绝大多数对象的生存周期很短。
因此按generation 来运行GC, 可以将memory 分为三部分：&lt;/p&gt;

&lt;h3 id=&#34;young-generation-for-young-objs&#34;&gt;Young Generation(for young objs)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Eden&lt;/li&gt;
&lt;li&gt;A &amp;ldquo;from&amp;rdquo; survivor space (S0)&lt;/li&gt;
&lt;li&gt;A &amp;ldquo;to&amp;rdquo; survivor space (S1)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;tenured-old-generation&#34;&gt;Tenured (old) Generation&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;for old objs&lt;/li&gt;
&lt;li&gt;超过了Minor GC age theshold的obj, 被挪到这里&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;premanent-generation&#34;&gt;Premanent Generation&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;for meta data, classes, and so on&lt;/li&gt;
&lt;li&gt;Contains metadata required by the JVM&lt;/li&gt;
&lt;li&gt;Class objs and methods&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;minor-gc&#34;&gt;Minor GC&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;发生在Young Generation，频繁发生&lt;/li&gt;
&lt;li&gt;fast，efficient。因为young gen space 通常很小，而且包含很多短命的obj&lt;/li&gt;
&lt;li&gt;熬过几次minor gc的obj，将被 &lt;strong&gt;promote&lt;/strong&gt; 到old generation space&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;major-gc&#34;&gt;Major GC&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;发生在old Generation的GC&lt;/li&gt;
&lt;li&gt;old generation space 比yong gen 大，被占用的space 缓慢增长&lt;/li&gt;
&lt;li&gt;infrequently, 而且花费的时间远多于 minor gc&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;aging-obj-in-yong-gen&#34;&gt;Aging Obj in Yong Gen&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;新Obj 被分配到eden space&lt;/li&gt;
&lt;li&gt;当eden space 满，触发minor GC: &amp;ldquo; &lt;strong&gt;Stop the world&lt;/strong&gt; &amp;ldquo; event (all the application threads stop)&lt;/li&gt;
&lt;li&gt;eden space满，则运行GC，把eden space 中活下来的obj + survivor space 中活下来的obj 移到另一个survivor space(反复来回倒), 并把这些obj 的age + 1&lt;/li&gt;
&lt;li&gt;如果obj的age 超过threshold(一般为15)， 将它挪到Old Gen&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;感受&#34;&gt;感受&lt;/h2&gt;

&lt;p&gt;除了官方的文档、视频，Oracle JDK还提供了demos 和samples, 自己可以实际操作，加深感受。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>放弃Jekyll，拥抱Hugo</title>
      <link>https://blog.yuantops.com/tech/transfer-from-jekyll-to-hugo/</link>
      <pubDate>Sat, 06 May 2017 14:03:44 +0800</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/transfer-from-jekyll-to-hugo/</guid>
      <description>&lt;p&gt;大约半年前，我更换了自己的工作电脑。装完系统后，开始装各种常用程序。&lt;/p&gt;

&lt;p&gt;一切都是那么美好，直到我开始尝试装Jekyll。各种依赖下不下来，或者版本对不上。前者要问候GFW，后者就是Ruby自己的锅了。我，一个Ruby盲，多次被毫不留情的依赖版本问题整崩溃。哪怕一次次长夜痛哭，最终也没有成功。&lt;/p&gt;

&lt;p&gt;直到有一天，我看到小巧精炼的&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Hugo 是用Golang 写的静态网站生成器，只有一个二进制命令，开箱即用。而且，一个命令既可以生成静态文件，又可以直接开http server。所以，那些乱七八糟的gem 包， screw you!&lt;/p&gt;

&lt;p&gt;在将Jekyll迁移到Hugo的过程中，需要重新梳理一下文章的组织结构。不过这些都是小case。&lt;/p&gt;

&lt;p&gt;我的博客托管在Github Pages。Github本身支持Jekyll引擎，以前直接把markdown文件 push上去就可以，Github会自动帮忙渲染源文件。但Github不支持Hugo的文件布局，所以博客内容要先在本地生成html，再push到github。&lt;/p&gt;

&lt;p&gt;我的Github项目地址在&lt;a href=&#34;https://github.com/yuantops/blog/&#34;&gt;这里&lt;/a&gt;。&lt;code&gt;hugo&lt;/code&gt;分支存放源文件，&lt;code&gt;gh-pages&lt;/code&gt;存放编译好的html。&lt;/p&gt;

&lt;p&gt;最后，再次赞美go， 赞美Hugo!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>写一套简易的视频点播系统——API Server</title>
      <link>https://blog.yuantops.com/tech/write-your-own-vod-system-api/</link>
      <pubDate>Wed, 20 Apr 2016 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/write-your-own-vod-system-api/</guid>
      <description>

&lt;div id=&#34;table-of-contents&#34;&gt;
&lt;h2&gt;目录&lt;/h2&gt;
&lt;div id=&#34;text-table-of-contents&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#sec-1-1&#34;&gt;1. 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sec-1-2&#34;&gt;2. 工程代码结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sec-1-3&#34;&gt;3. 数据加载流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;前言-a-id-sec-1-1-name-sec-1-1-a&#34;&gt;前言&lt;a id=&#34;sec-1-1&#34; name=&#34;sec-1-1&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;作为一个视频点播系统的后台，应该为客户端(见 &lt;a href=&#34;http://blog.yuantops.com/tech/write-your-own-vod-system-android&#34;&gt;《写一套简易的视频点播系统&amp;#x2013;Android视频播放器》)&lt;/a&gt; 提供合理良好的API接口。同样，这里我们完成了最简单最基本的功能: 基于Spring MVC结构，当有http请求到来时，从MySQL数据库获取数据，返回json格式的数据。&lt;/p&gt;

&lt;h2 id=&#34;工程代码结构-a-id-sec-1-2-name-sec-1-2-a&#34;&gt;工程代码结构&lt;a id=&#34;sec-1-2&#34; name=&#34;sec-1-2&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;如下所示(省略了一些文件):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── main/
│   ├── java/
│   │   └── com/
│   │       └── yuantops/                 
│   │           ├── exception/             //Exception包
│   │           ├── tv/                    
│   │           │   ├── bean/              //Video对象，对应数据库中数据模型
│   │           │   ├── controller/        //Spring MVC中的C
│   │           │   ├── dao/               //数据库增删改查
│   │           │   ├── impl/              //service接口实现
│   │           │   └── service/           //service接口
│   │           └── utils/                 //工具类
│   ├── resources/
│   │   ├── application-root-context.xml   //Spring MVC启动加载的初始化上下文
│   │   ├── com/
│   │   │   └── yuantops/
│   │   │       └── tv/
│   │   │           ├── dao/               //对应dao java文件的xml文件，属于MyBatis配置
│   │   │           └── settings/          //MyBatis的配置信息
│   │   ├── config/                        //编码、jdbc等配置文件
│   │   ├── front-servlet-context.xml      //有HttpRequest时加载的上下文的配置
│   │   ├── log4j.xml                      //log4j的配置
│   │   └── properties/                    //properties文件
│   │       └── jdbc.properties
│   └── webapp/                            
│       ├── WEB-INF/
│       │   ├── front_page/                //Spring MVC中的V
│       │   └── web.xml                    //整个web app的配置文件
│       └── index.jsp
└── test/                                  //测试文件
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;数据加载流程-a-id-sec-1-3-name-sec-1-3-a&#34;&gt;数据加载流程&lt;a id=&#34;sec-1-3&#34; name=&#34;sec-1-3&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;和所有基于Servlet的Web Application一样，app的入口在web.xml，会加载application-root-context.xml和front-servlet-context.xml两个context。在这两个context中，会分别load一些config/目录下的配置文件。&lt;/p&gt;

&lt;p&gt;项目除了Spring MVC框架，还用了log4j(日志记录)，MyBatis(数据库连接)两个开源插件。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>写一套简易的视频点播系统——Android视频播放器</title>
      <link>https://blog.yuantops.com/tech/write-your-own-vod-system-android/</link>
      <pubDate>Tue, 19 Apr 2016 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/write-your-own-vod-system-android/</guid>
      <description>

&lt;p&gt;作为一个视频点播系统的客户端，播放视频是最基本的功能。本着最精简最偷懒的原则，这个客户端实现的功能包括:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;列表显示服务器上的直播视频、点播视频&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;点击列表条目，播放视频&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;工程代码结构-a-id-sec-1-1-name-sec-1-1-a&#34;&gt;工程代码结构&lt;a id=&#34;sec-1-1&#34; name=&#34;sec-1-1&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;客户端用Android Studio开发，整个项目的结构按gradle风格组织，代码路径是TopsTVPlayer/app/src/main/java。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
└── com
    └── yuantops
        └── tvplayer      
            ├── adapter         加载list的Adapter
            ├── player          播放器组件
            ├── ui              Fragment和Activity显示界面
            └── util            工具类
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在player/包下，为直播视频和点播视频分别建立了一个类，因为Android原生的MediaPlayer组件对RTSP协议的直播流支持不全面，所以用原生的MediaPlayer播放点播视频(http)，用Vitamio提供的MediaPlayer播放直播视频(rtsp)。&lt;/p&gt;

&lt;h2 id=&#34;数据加载流程-a-id-sec-1-2-name-sec-1-2-a&#34;&gt;数据加载流程&lt;a id=&#34;sec-1-2&#34; name=&#34;sec-1-2&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;所有与网络的数据交流方法都封装在util/VolleySingleton.java文件中，使用了Volley这个优秀的开源http包。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;app启动时，首先加载WebAPIServerActivity.java界面，填写web服务器(提供api接口的服务器，不是多媒体服务器)的Base URL。点击确认按钮，会跳转到MainActivity。&lt;/li&gt;
&lt;li&gt;MainActivity包含两个Fragment。在Fragment被加载时，会调用VolleySingleton.java里的方法从web服务器上获取json格式的视频列表数据。数据下载完成后，会以list的形式显示出来。&lt;/li&gt;
&lt;li&gt;点击listView中的item，会跳转到VideoPlayActivity，初始化对应的直播/点播MediaPlayer。MediaPlayer组件根据视频的URL，从视频服务器获取数据，开始播放。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;引用的库-a-id-sec-1-3-name-sec-1-3-a&#34;&gt;引用的库&lt;a id=&#34;sec-1-3&#34; name=&#34;sec-1-3&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://actionbarsherlock.com/&#34;&gt;ActionbarSherlock&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vitamio.org/en/&#34;&gt;Vitamio SDK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mcxiaoke/android-volley&#34;&gt;Android Volley&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>写一套简易的视频点播系统</title>
      <link>https://blog.yuantops.com/tech/write-your-own-vod-system/</link>
      <pubDate>Sat, 09 Apr 2016 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/write-your-own-vod-system/</guid>
      <description>&lt;p&gt;最初实习时，断断续续写Android代码，实现过用Helix架设流媒体服务器、手机播放流媒体视频的功能。后来一份实习，接触到Spring＋MyBatis框架，见识了它们在处理http请求和数据库连接上的便捷。这几天有些时间，想到可以将它们两者糅合到一起，实现一个完整的视频点播系统，既包括服务器(流媒体服务器，数据库，http服务器)，又包括客户端(Android)。虽然简陋，但工作起来毫无问题。&lt;/p&gt;

&lt;p&gt;整个工程运行起来的效果:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打开手机App，填写http服务器提供的api root URL，出现两个列表: 点播视频列表和直播列表。点击列表条目，开始播放视频。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过手动添加视频文件、修改数据库记录，可以更新视频列表。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样一个小系统，代码部分包括:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;http服务器: 暴露api给访问者，返回json数据。使用了Spring＋MyBatis框架，用Apache Tomcat做Web服务的容器。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Android客户端: 访问http服务器获取数据，并播放流媒体服务器推送的流媒体。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了写代码，还有一部分配置操作，主要是流媒体服务器Helix。&lt;/p&gt;

&lt;p&gt;写代码和配置服务器软件的工作量，加起来与计算机专业本科的课程设计工作量相当。这些工作将由三篇文章分别介绍。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用Android 手机玩延时摄影</title>
      <link>https://blog.yuantops.com/tech/timelapse-photography-diy-android/</link>
      <pubDate>Fri, 11 Dec 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/timelapse-photography-diy-android/</guid>
      <description>

&lt;p&gt;延时摄影是一种很精妙细微的展现形式，时间被压缩后有流动的美。每隔固定时间按一次快门，再将照片按某个帧率连续起来，就生成一段流畅的视频。摄影发烧友一般用单反拍照，用快门线控制拍照的周期。鉴于单反不是人人都有（譬如我就没有。。），这里分享一个经济实用的点子，用安卓和电脑来DIY延时摄影。&lt;/p&gt;

&lt;h2 id=&#34;思路&#34;&gt;思路&lt;/h2&gt;

&lt;p&gt;Android 系统开放了一些接口，Debug模式下电脑可以通过Android SDK提供的adb 命令调用它们，模拟启动相机、聚焦、拍照动作，并将照片保存到电脑硬盘。将这一连串操作用脚本记录下来，并设置linux定时任务，周期执行。最后，通过ffmpeg 或者其他视频编辑软件将照片变成视频/gif。&lt;/p&gt;

&lt;h2 id=&#34;器材&#34;&gt;器材&lt;/h2&gt;

&lt;p&gt;一部安卓手机 + 一台电脑(假设为Linux) + 一根USB线&lt;/p&gt;

&lt;h2 id=&#34;拍摄主题&#34;&gt;拍摄主题&lt;/h2&gt;

&lt;p&gt;玫瑰花绽放&lt;/p&gt;

&lt;h2 id=&#34;做法&#34;&gt;做法&lt;/h2&gt;

&lt;p&gt;我手头有一部大概一年前买的红米，测试了下拍照效果，虽然比不上正在用的5c但也相当凑和。笔记本刚刚重装了个系统(Arch)，在官网上下好了新鲜热乎的Android SDK。&lt;/p&gt;

&lt;p&gt;用USB线将手机连到笔记本，打开手机的Debug模式。另外，推荐将手机设置为Debug模式下屏幕常亮。用Android SDK的platform-tools目录下的adb命令检查是否顺利连接了手机。我在自己的机器上折腾红米的挂载还颇费了一点力气，具体操作可以google之，此处不赘述。&lt;/p&gt;

&lt;p&gt;用脚本调用adb命令，实现启动相机、聚焦、拍照、保存照片到电脑、删除手机上的照片等一连串操作。将照片从手机上删除是考虑到手机SD的容量有限。Shell脚本实现起来最简单。这里不得不赞叹adb的强大，不仅可以用&amp;rdquo;adb shell&amp;rdquo;像普通linux系统一样操作Android设备，还可以向设备发送按键动作、模拟触屏动作等。如何发送Keyevent，如何捕捉(capture)、记录(record)、发送屏幕触摸动作，可以Google之，此处不赘述。&lt;/p&gt;

&lt;p&gt;将脚本作为系统的定时任务执行。Linux下用crontab可以非常方便地实现。如何设置定时任务的时间间隔，需要做一点小数学题，用拍摄对象的总耗时与视频的帧率算出来，具体参考&lt;a href=&#34;http://content.photojojo.com/tutorials/ultimate-guide-to-time-lapse-photography/&#34;&gt;博客&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;做完前期的技术准备后，该拍摄主角登场了。我选择的拍摄主题是“鲜花绽放”，所谓一支浓艳露凝香，在我心中玫瑰是坠吼不过的了。在花店用3人民币买了一朵含苞待放的玫瑰花骨朵儿。给它粘个背景，插在一个透明酸奶罐子中，架好灯光（淘宝买的USB LED灯）。固定好手机，缚得牢牢的，不要让它晃动。&lt;/p&gt;

&lt;p&gt;静静地让程序跑，跑，跑。。。。（宿舍晚上会熄灯，这是比较麻烦的，暂时我还没想到解决办法。不过幸亏玫瑰花儿开得快，白天就很饱满了。）&lt;/p&gt;

&lt;p&gt;时间大概过去了五个小时。。。&lt;/p&gt;

&lt;p&gt;好了，花儿开好了。&lt;/p&gt;

&lt;p&gt;打开电脑上存放照片的目录，用ffmpeg或者别的视频编辑软件，将它们合成视频。（我这里为了方便合成的是gif。）&lt;/p&gt;

&lt;h2 id=&#34;github例子&#34;&gt;Github例子&lt;/h2&gt;

&lt;p&gt;我的Shell脚本见&lt;a href=&#34;https://github.com/yuantops/TimelapseAndroid&#34;&gt;这个项目&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;最后是gif效果图，考虑到博客容量我降低了图片尺寸和质量。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;out3.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C语言堆与栈的区别</title>
      <link>https://blog.yuantops.com/tech/c-heap-vs-stack-memory/</link>
      <pubDate>Thu, 17 Sep 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/c-heap-vs-stack-memory/</guid>
      <description>

&lt;p&gt;C语言中动态区域由Stack和Heap两部分组成。简单说来，Stack由编译器自动分配释放，存放函数的参数值、局部变量等值，底层的数据结构是LIFO的栈。Heap由程序员分配释放，如果一不小心忘记了释放申请的内存，可能引起内存泄漏。Heap基于的数据结构比较复杂。&lt;/p&gt;

&lt;h2 id=&#34;区别&#34;&gt;区别&lt;/h2&gt;

&lt;h3 id=&#34;申请方式&#34;&gt;申请方式&lt;/h3&gt;

&lt;p&gt;Stack由系统自动分配，存放局部变量等。
Heap由程序员调用malloc, realloc, calloc申请，并用free释放。&lt;/p&gt;

&lt;h3 id=&#34;申请效率&#34;&gt;申请效率&lt;/h3&gt;

&lt;p&gt;Stack由系统自动分配，速度快，程序员无法控制。&lt;br /&gt;
Heap由程序员申请、释放，容易产生碎片，效率低于Stack。&lt;/p&gt;

&lt;h3 id=&#34;空间大小&#34;&gt;空间大小&lt;/h3&gt;

&lt;p&gt;Stack在Linux内存区域中由高地值向低地址生长，大小固定，地址是连续的。当栈的剩余控件不足时，会提示Overflow。&lt;br /&gt;
Heap在内存区域中由低地址向高地址生长，是不连续的内存区域。堆的大小受制于系统有效的虚拟内存。&lt;/p&gt;

&lt;h3 id=&#34;分配方式&#34;&gt;分配方式&lt;/h3&gt;

&lt;p&gt;Stack是连续的。只要栈的空间大于所申请的空间，系统将为程序分配空间，否则会报Overflow。&lt;br /&gt;
Heap收到程序申请时，操作系统有一个记录空闲内存地址的链表，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲链表中删除，并将该节点的空间分配给程序。另外，如果找到的堆节点大小不一定正好等于申请的大小，系统会自动将多余的部分重新放入空闲链表中。反复的申请/释放，势必会生成大量的内存空间碎片，使程序效率降低。&lt;/p&gt;

&lt;h3 id=&#34;存储内容&#34;&gt;存储内容&lt;/h3&gt;

&lt;p&gt;Stack：当函数调用时，第一个进栈的是主函数中下一条语句的地址，然后是函数的各个参数，参数是从右往左入栈的，然后是函数中的局部变量。静态变量不入栈。&lt;br /&gt;
当本次函数调用结束后，局部变量先出栈，然后是参数，最后是栈顶指针所指向的、主函数中的下一条指令，程序由该点继续执行。&lt;br /&gt;
Heap：往往会在堆的头部用一个字节存放堆的大小，以利于free函数的释放。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java堆内存与栈内存的区别</title>
      <link>https://blog.yuantops.com/tech/java-heap-vs-stack-memory/</link>
      <pubDate>Thu, 17 Sep 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/java-heap-vs-stack-memory/</guid>
      <description>

&lt;p&gt;Java中提供&amp;rdquo;栈&amp;rdquo;这种数据结构的实现，java.util.Stack。但此处我们所讨论的不是数据结构，而是JVM内存中的堆与栈，Java Runtime中存放数据的地方。&lt;/p&gt;

&lt;h3 id=&#34;jvm中的堆&#34;&gt;JVM中的堆&lt;/h3&gt;

&lt;p&gt;Java Runtime使用Heap为Object分配内存。所有的对象，无论是何时何地创建的，都保存在Heap中。垃圾回收(Garbage Collection)在Heap上运行，释放不被引用的Object。Heap中生存的Object能在程序的任何地方被引用。&lt;/p&gt;

&lt;h3 id=&#34;jvm中的栈&#34;&gt;JVM中的栈&lt;/h3&gt;

&lt;p&gt;Stack memory是为执行的thread分配的，包含一些生存时间短的值和指向Heap中对象的引用。Stack Memory总是LIFO的。当调用一个Method时，Stack Memory会为它分配一块区域，用来存储本地的primitive value和对Object的引用。一旦这个method结束，这块区域将变得不可用，下一次Method调用时又可以使用它。&lt;/p&gt;

&lt;p&gt;相比Heap，Stack要小得多。&lt;/p&gt;

&lt;h3 id=&#34;区别&#34;&gt;区别&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;存储内容：栈存放局部变量以及引用，堆存放&lt;strong&gt;所有&lt;/strong&gt;对象。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;被谁占有：堆被整个程序共享，栈中的对象被所有线程可见；栈属于单个线程，存储的变量只在其所属的线程中可见。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;空间管理：Stack内存满足LIFO，但Heap就复杂多了。Heap被分为Young Generation, Old Generation, Permanent Generation，在它基础上会运行垃圾回收机制。&lt;/li&gt;
&lt;li&gt;生存时间：Stack Memory伴随调用它的Method存在、消失，而Heap Memory从程序的开始一直存活到终止。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;体积大小：Stack Memory体积远大于Heap Memory。由于Stack用LIFO调度，它的访问速度也快得多。可以用-Xms或者-Xmx定义Heap的初始大小，用-Xss定义Stack的初始大小。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;异常错误：当Stack满了，Java Runtime会抛出java.lang.StackOverFlowError。当Heap满了，会抛出java.lang.OutOfMemoryError: Java Heap Space Error。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>LaTeX安装以及生成pdf时字体找不到的处理办法</title>
      <link>https://blog.yuantops.com/tech/latex-installation-and-basics/</link>
      <pubDate>Tue, 08 Sep 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/latex-installation-and-basics/</guid>
      <description>

&lt;h2 id=&#34;安装软件包&#34;&gt;安装软件包&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;$ sudo apt-get install texlive texlive-science&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;编译命令&#34;&gt;编译命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;tex编译: &lt;code&gt;$ latex hello.tex&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;输出为pdf: &lt;code&gt;$ dvipdf hello.dvi&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;输出为ps: &lt;code&gt;$ dvips hello.dvi&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;如果生成pdf时报-font-helvetica-is-not-in-the-mapping-file-类似错误&#34;&gt;如果生成pdf时报&amp;rdquo;Font Helvetica is not in the mapping file&amp;rdquo; 类似错误&lt;/h2&gt;

&lt;p&gt;出现这种情况，原因可能有几种，最可能的是系统没有安装这个字体。具体解释见&lt;a href=&#34;http://www.wkiri.com/today/?p=60&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;处理办法：安装ghostscript命令，用它自带的命令，先将pdf转成ps，再以强制嵌入字体的方式将ps回转为pdf。详细的步骤见&lt;a href=&#34;http://www.grassbook.org/wp-content/uploads/neteler/highres_pdf.html&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;具体命令:&lt;br /&gt;
1. covert to postscript:&lt;br /&gt;
&lt;code&gt;$ pdftops origin.pdf origin.ps&lt;/code&gt;&lt;br /&gt;
2. reconvert to pdf, but enforce font embedding:&lt;br /&gt;
&lt;code&gt;$ ps2pdf14 -dPDFSETTINGS=/prepress -dEmbedAllFonts=true origin.ps new.pdf&lt;/code&gt;&lt;br /&gt;
3. verify format of new file:&lt;br /&gt;
&lt;code&gt;$ pdffonts new.pdf&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android SurfaceView双缓存机制与闪屏现象分析</title>
      <link>https://blog.yuantops.com/tech/surfaceview-dual-cache/</link>
      <pubDate>Sun, 26 Jul 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/surfaceview-dual-cache/</guid>
      <description>&lt;p&gt;##理解SurfaceView&lt;br /&gt;
SurfaceView是View的子类，所以View有的特点它都有。但它有特殊之处：它引入了缓存机制，优化了内容刷新的过程，使UI Thread不至于崩溃。更新它的内容，我们要用到与之关联的SurfaceHolder。&lt;/p&gt;

&lt;p&gt;比较特殊的在于SurfaceView的“双缓存”(Double-buffer)机制。更新SurfaceView的常见流程是&amp;rdquo;lockCanvas-drawCanvas-unlockCanvasAndPost&amp;rdquo;, 如果你遇到SurfaceView闪烁的情况，像鬼片里电视机的那种闪法，那十之八九是栽倒在双缓存的坑里了。Google告诉了我这个问题的答案，希望你能用上。&lt;/p&gt;

&lt;p&gt;##双缓存(Double-buffer)与黑屏闪烁&lt;br /&gt;
以下内容来自&lt;a href=&#34;http://markmail.org/message/mxserqvi37hnajp5&#34;&gt;邮件列表的讨论&lt;/a&gt;，我对它们进行一点梳理。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;每个SurfaceView 对象有两个独立的graphic buffer，官方SDK将它们称作&amp;rdquo;front buffer&amp;rdquo;和&amp;rdquo;back buffer&amp;rdquo;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;常规的&amp;rdquo;double-buffer&amp;rdquo;会这么做：每一帧的数据都被绘制到back buffer，然后back buffer的内容被持续翻转(flip)到front buffer；屏幕一直显示front buffer。但Android SurfaceView的&amp;rdquo;double-buffer&amp;rdquo;却是这么做的：在buffer A里绘制内容，然后让屏幕显示buffer A; 下一个循环，在buffer B里绘制内容，然后让屏幕显示buffer B; 如此往复。于是，屏幕上显示的内容依次来自buffer A, B, A, B,&amp;hellip;.这样看来，两个buffer其实没有主从的分别，与其称之为&amp;rdquo;front buffer&amp;rdquo;&amp;ldquo;back buffer&amp;rdquo;，毋宁称之为&amp;rdquo;buffer A&amp;rdquo;&amp;ldquo;buffer B&amp;rdquo;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Android中&amp;rdquo;double-buffer&amp;rdquo;的实现机制，可以很好地解释闪屏现象。在第一个&amp;rdquo;lockCanvas-drawCanvas-unlockCanvasAndPost&amp;rdquo;循环中，更新的是buffer A的内容；到下一个&amp;rdquo;lockCanvas-drawCanvas-unlockCanvasAndPost&amp;rdquo;循环中，更新的是buffer B的内容。如果buffer A与buffer B中某个buffer内容为空，当屏幕轮流显示它们时，就会出现画面黑屏闪烁现象。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;##解决方法
出现黑屏是因为buffer A与buffer B中一者内容为空，而且为空的一方还被post到了屏幕。于是有两种解决思路：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不让空buffer出现：每次向一个buffer写完内容并post之后，顺便用这个buffer的内容填充另一个buffer。这样能保证两个buffer的内容是同步的，缺点是做了无用功，耗费性能。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不post空buffer到屏幕：当准备更新内容时，先判断内容是否为空，只有非空时才启动&amp;rdquo;lockCanvas-drawCanvas-unlockCanvasAndPost&amp;rdquo;这个流程。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>用Helix Server建立点播流/直播流的方法</title>
      <link>https://blog.yuantops.com/tech/helix-server-streaming-guide/</link>
      <pubDate>Thu, 23 Jul 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/helix-server-streaming-guide/</guid>
      <description>

&lt;h2 id=&#34;视频文件预处理&#34;&gt;视频文件预处理&lt;/h2&gt;

&lt;p&gt;Helix Server支持的视频格式很多，我只使用过MP4格式，其余的格式请自行探索。&lt;/p&gt;

&lt;p&gt;一个MP4格式的视频文件要想被Helix流化，必须具有符合要求的头部信息。mp4box这个小命令正是用来做这件事的，它是开源软件GPAC内提供的命令。先安装GPAC(&lt;a href=&#34;https://gpac.wp.mines-telecom.fr/mp4box/)，&#34;&gt;https://gpac.wp.mines-telecom.fr/mp4box/)，&lt;/a&gt; 后在安装目录下找到MP4BOX.exe。如何调用命令不赘言。它的使用格式是：&lt;br /&gt;
&lt;code&gt;mp4box mymovie.mp4 -hint&lt;/code&gt;&lt;br /&gt;
在安装Helix Server前，将所有的视频文件都用这条命令处理一遍。&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;Helix Server是收费的，但在官网能申请到一个试用版license，免费使用一段时间。当然，如果你在网上找到了破解版，请在使用时自觉忏悔。&lt;/p&gt;

&lt;p&gt;安装过程不多说，只是要注意记忆所设的帐号和密码。安装完成后，在桌面会生成两个图标：一个指向web控制台，还有一个是启动Helix的快捷方式。我们双击web控制台的图标，输入帐号和密码，进入Web Console。&lt;/p&gt;

&lt;h2 id=&#34;参数配置&#34;&gt;参数配置&lt;/h2&gt;

&lt;p&gt;进入Web Console后，左侧是一栏设置菜单，右侧是对应菜单条目的详情。在Web Console上我们能完成&lt;strong&gt;点播流&lt;/strong&gt;的所有配置,以及直播流的必要配置。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;添加服务器的IP地址&lt;br /&gt;
左侧：&amp;rdquo;服务器设置&amp;rdquo;-&amp;ldquo;IP绑定&amp;rdquo;&lt;br /&gt;
右侧：点击小加号，输入服务器的IP地址。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置流服务的端口号&lt;br /&gt;
Helix 的点播支持Http协议、RTSP协议，直播支持RTSP协议。Helix为这些协议分配了默认的端口号，如果有需要的话我们可以修改它们。&lt;br /&gt;
左侧：&amp;rdquo;服务器设置&amp;rdquo;-&amp;ldquo;端口&amp;rdquo;&lt;br /&gt;
右侧：修改&amp;rdquo;RTSP端口&amp;rdquo;，&amp;rdquo;HTTP端口&amp;rdquo;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加视频加载点&lt;br /&gt;
左侧：&amp;rdquo;服务器设置&amp;rdquo;-&amp;ldquo;配置加载点&amp;rdquo;&lt;br /&gt;
右侧：点击&amp;rdquo;加载点描述&amp;rdquo;右边的小加号&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;编辑描述&amp;rdquo;随便给这个配置取一个描述性的名字；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;加载点&amp;rdquo;设置视频目录的加载点（它将作为视频流URL的一部分出现），输入内容形如&amp;rdquo;/NGB/&amp;ldquo;（注意有两个左斜杠）；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;基于路径&amp;rdquo;输入视频文件所在目录的绝对路径，形如&amp;rdquo;E:\Videos&amp;rdquo;。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将加载点添加到HTTP 分发目录&lt;br /&gt;
左侧：&amp;rdquo;服务器设置&amp;rdquo;-&amp;ldquo;HTTP分发&amp;rdquo;&lt;br /&gt;
右侧：点击&amp;rdquo;路径&amp;rdquo;右边的小加号，在&amp;rdquo;编辑路径&amp;rdquo;中填入上面设置的视频加载点，形如&amp;rdquo;/NGB&amp;rdquo;(注意此处只有一个左斜杠)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将MP4格式加到HTTP协议支持的MIME类型列表&lt;br /&gt;
左侧：&amp;rdquo;服务器设置&amp;rdquo;-&amp;ldquo;MIME类型&amp;rdquo;&lt;br /&gt;
右侧：点击&amp;rdquo;MIME类型&amp;rdquo;右边的小加号&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;编辑MIME类型&amp;rdquo;填入&amp;rdquo;video/mp4&amp;rdquo;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;扩展名&amp;rdquo;填入&amp;rdquo;mp4&amp;rdquo;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;测试配置是否成功&lt;br /&gt;
假设视频文件目录有文件&amp;rdquo;E:\Videos\akame.mp4&amp;rdquo;,视频目录挂载点为&amp;rdquo;/NGB/&amp;ldquo;,配置的Http协议端口为80，Rtsp协议端口为554。在PC上打开一个能播放网络媒体流的视频播放器（推荐VLC），输入下面的URL播放视频：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://192.168.1.100:80/NGB/akame.mp4&#34;&gt;http://192.168.1.100:80/NGB/akame.mp4&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;rtsp://192.168.1.100:554/NGB/akame.mp4&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;点播流的创建到此结束了。完成上述步骤后，下面再来介绍如何用Helix 提供的小命令，由视频文件生成模拟直播流。&lt;/p&gt;

&lt;h3 id=&#34;生成模拟直播流&#34;&gt;生成模拟直播流&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;准备命令&lt;br /&gt;
在Helix Server的安装路径下找到/bin目录，将slta.bat和slta.exe文件拷贝到视频目录（此处为&amp;rdquo;E:\Videos\&amp;ldquo;）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置Helix为Receiver模式&lt;br /&gt;
打开Web Console。左侧：“广播分发”-“接受服务器”，在右侧“加载点”框内输入直播流的挂载点，例如&amp;rdquo;/broadcast/&amp;ldquo;（注意有两个左斜杠）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行模拟直播流命令&lt;br /&gt;
模拟直播流播放哪几个视频，按什么顺序播放它们，是可以自己定义的。例如，如果想循环播放akame.mp4和anotheVideo.mp4这两个视频，我们可以创建一个节目单文本文件：playlist.txt，将“akame.mp4”和“anotheVideo.mp4”做两行写到文件。&lt;br /&gt;
运行命令&lt;code&gt;slta.bat 192.168.1.100 178771 admin admin tv1 playlist.txt&lt;/code&gt;创建直播流，其中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;是slta.bat，而不是slta&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;IP地址是这台机器的IP地址&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;178771是Web Console的端口号。用浏览器打开Web Console，可以在URL中找到&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;admin/admin分别是账号和密码&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;tv1是为直播流分配的任意频道号，可自定义&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;playlist.txt是节目单文件。如果只播放单个视频，也可以换成视频文件名，如&amp;rdquo;akame.mp4&amp;rdquo;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;播放验证直播流&lt;br /&gt;
打开视频播放器，输入形如&amp;rdquo;rtsp://192.168.1.100:554/broadcast/tv1&amp;rdquo;的网址，播放视频。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上述步骤创建一个直播流。新开一个cmd窗口，重复上述步骤，可以创建多路直播流。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ali面试记录</title>
      <link>https://blog.yuantops.com/tech/interview-ali-record-1/</link>
      <pubDate>Thu, 19 Mar 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/interview-ali-record-1/</guid>
      <description>&lt;p&gt;记录：
1. 以支付宝的输入密码界面为例。当支付宝再次回到前台时，有时会进入输手势密码的界面。请问你的实现思路？&lt;br /&gt;
面试官的解答：编写一个BaseActivity继承Activity，然后App中所有的Activity都继承BaseActivity。在BaseActivity中设置计时器，重写BaseActivity的onStop()和onStart()方法&amp;hellip;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;百度、腾讯等旗下有多款App，这些App有的在后台共享SDK数据。请问其中原理？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IPC调用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Android中APP是单例还是多例？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;判断一个Activity是不是位于栈顶。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java中run()和start()区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java中lock()和Syncronized()区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在按下Back键时，如何自定义返回到哪个Activity？&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Git重新应用gitignore文件规则</title>
      <link>https://blog.yuantops.com/tech/refresh-gitigore/</link>
      <pubDate>Tue, 17 Mar 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/refresh-gitigore/</guid>
      <description>&lt;p&gt;这个问题参见&lt;a href=&#34;https://stackoverflow.com/questions/11451535/gitignore-not-working&#34;&gt;StackOverflow&lt;/a&gt;，记录在下面：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;保险起见，先对当前Repo提交一个commit，以防丢失数据；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;然后，&lt;br /&gt;
      git rm -r &amp;ndash;cached .&lt;br /&gt;
      git add .&lt;br /&gt;
      git commit -m &amp;ldquo;fixed untracked files&amp;rdquo;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>REST基础概念笔记</title>
      <link>https://blog.yuantops.com/tech/rest-basics/</link>
      <pubDate>Thu, 29 Jan 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/rest-basics/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Representational State Transfer(REST)&lt;/strong&gt;&lt;br /&gt;
REST is an architecture style or design pattern used as a set of guidelines for creating web services which allow anything connected to a network (web servers, private intranets, smartphones, fitness bands, banking systems, traffic cameras, televisions etc.) to communicate with one another via a shared common communications protocol known as Hypertext Transfer Protocol (HTTP). &amp;ndash;&lt;a href=&#34;http://en.wikipedia.org/wiki/Representational_state_transfer&#34;&gt;REST Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;REST是一种&lt;strong&gt;架构风格&lt;/strong&gt;，&lt;strong&gt;设计模式&lt;/strong&gt;，因此没有一本语法书规定REST应该这样实现，应该那样实现。它不是一种标准。它是一种风格，具有指导意义，凡是遵循这种风格的设计，都可以称之为&amp;rdquo;RESTful&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;REST的常见应用场景是Web服务。在RESTful API的实际实现中，往往遵循一些*约定的*规则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基于URI，例如&lt;a href=&#34;http://example.com/resources/&#34;&gt;http://example.com/resources/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;传输的数据格式是JSON。虽然理论上数据格式可以是任意一种(XML,ATOM等)，但往往大家都用JSON。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用标准HTTP方法，即GET, PUT, POST, DELETE四个动词。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://rest.elkstein.org/2008/02/how-simple-is-rest.html&#34;&gt;How Simple is REST&lt;/a&gt;这篇文章里举了这样一个例子：&lt;/p&gt;

&lt;p&gt;假设这样一个Web服务，它是一个电话本应用，我们要向它查询某个用户的信息。我们只有用户的ID。&lt;/p&gt;

&lt;p&gt;REST风格下，查询看起来这样:&lt;br /&gt;
&amp;gt;&lt;a href=&#34;http://www.acme.com/phonebook/UserDetails/12345&#34;&gt;http://www.acme.com/phonebook/UserDetails/12345&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不需要在请求中设置额外的body，一条URL就搞定。这条URL以GET方式发送给服务器，返回原始的HTTP数据。返回的数据不嵌套在任何东西里，我们可以直接使用。&lt;/p&gt;

&lt;p&gt;所以，使用REST风格对开发有好处：我们可以用浏览器测试API，哪怕客户端的部分还没完成。&lt;/p&gt;

&lt;p&gt;另外，注意这条URL使用了&amp;rdquo;UserDetails&amp;rdquo;，而不是&amp;rdquo;GetUserDetails&amp;rdquo;。这是REST设计风格的一个例子：使用*名词*而不是*动词*来表示简单的*资源*。&lt;/p&gt;

&lt;h3 id=&#34;资源的概念&#34;&gt;资源的概念&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;资源(Resources)&lt;/strong&gt;是REST架构中一个非常重要的概念。&lt;strong&gt;逻辑&lt;/strong&gt;URL标识着资源。资源同时表示&lt;strong&gt;状态(state)&lt;/strong&gt;和&lt;strong&gt;功能(functionality)&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;逻辑URL，意味着这个资源能被系统中的其它部分定位(universally addressable)。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;资源是一个RESTful 设计中的核心元素。它不同于&amp;rdquo;methods&amp;rdquo;或是&amp;rdquo;services&amp;rdquo;。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>视频格式学习笔记</title>
      <link>https://blog.yuantops.com/tech/video-format-and-container-study/</link>
      <pubDate>Wed, 28 Jan 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/video-format-and-container-study/</guid>
      <description>

&lt;p&gt;在生活语境里所说的“视频格式”，在学术上有两个概念与之对应：Container format (封装格式)和Codec (暂且译为“编解码格式”)。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Container format (封装格式)
Container format 描述了视频文件的结构。正如它的字面含义所说，它是对一个“容器”的规范。一个视频文件往往会包含图像和音频，还有一些配置信息(如图像和音频的关联，如何解码它们等)：这些内容需要按照一定的规则组织、存储起来，Container format就是这些规则。&lt;/p&gt;

&lt;p&gt;如果一个视频文件是以某个Container format封装起来的，那么它的后缀名一般会体现出来。所以，后缀名只是形式，只是为了便于识别(例如，windows系统会根据文件的后缀名决定以什么程序打开它)，不代表实质性的内容。&lt;/p&gt;

&lt;p&gt;附录(一)是常见的视频封装格式和后缀的对应表。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Codec (编解码格式)&lt;br /&gt;
Codec是一种压缩标准。而文件的压缩/还原是通过编/解码实现的，所以Codec也可理解成编/解码标准。要知道，未经过处理的原始视频和音频文件十分巨大，不好存储、传输。为了节省磁盘空间和网络带宽，原始的视频和音频文件都会通过编码压缩体积，然后需要播放时再通过逆向过程解码还原。Codec就是规定编/解码实现细节(数字存储空间、帧速率、比特率、分辨率等)的标准，不同的标准对于压缩的质量和效率有影响。&lt;/p&gt;

&lt;p&gt;世界上制定这套标准的有两大阵营：ITU-T VCEG(Visual Coding Experts Group，国际电联旗下的标准化组织)和MPEG(Moving Picture Experts Group, ISO旗下的组织)。MPEG系列标准是MPEG制定的，H.26x系列标准是ITU-T制定的。这两套标准的更进一步介绍可以参见附录(二)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Container format 和Codec 有关系吗？&lt;br /&gt;
不妨将视频文件看作容器(Container)，那么这个容器里盛放的就是遵循某种Codec的内容(Content)。一个容器里应该能放下视频、音频、数据信息，即使它们遵循的Codec不相同。例如，QuickTime File Format (.MOV)支持几乎所有的Codec，MPEG(.MP4)也支持相当广的Codec。所以，单从视频文件的格式是无法获知它的质量细节的，这些细节取决与采用的Codec。比较专业的说法是，“给我一个H.264 Quicktime文件(.mov)”。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为何还是有点迷糊？&lt;br /&gt;
以上的解释是从学术角度出发的。只要分清了这些术语，那么在学术讨论时不会有含糊。但现实生活中人们不会一丝不苟地区分“Container format ”“Codec”，往往只会说“这是一个mov文件”。这是日常用语与学术术语混用造成的理解上的混乱。&lt;/p&gt;

&lt;p&gt;另外，Container format和Codec的命名也有让清醒的人摸不清头脑。例如，“MPEG-4”既是“Container format ”，也是“Codec”，这也让混乱的名词世界更糟糕。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://library.rice.edu/services/dmc/guides/video/VideoFormatsGuide.pdf&#34;&gt;https://library.rice.edu/services/dmc/guides/video/VideoFormatsGuide.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://app.zencoder.com/docs/faq/codecs-and-formats&#34;&gt;https://app.zencoder.com/docs/faq/codecs-and-formats&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;附录一-常见的视频封装格式和后缀的对应表&#34;&gt;附录一 常见的视频封装格式和后缀的对应表&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://app.yinxiang.com/shard/s11/res/a7088df6-98db-4089-8bb6-93a2beb1c76e/7295b9399a1a37290870fa8f35f4762e_b.jpg.png?resizeSmall&amp;amp;width=313&#34; alt=&#34;常见的视频封装格式和后缀的对应表&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux确定监听某个端口的进程</title>
      <link>https://blog.yuantops.com/tech/find-out-process-listening-on-a-port/</link>
      <pubDate>Thu, 22 Jan 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/find-out-process-listening-on-a-port/</guid>
      <description>

&lt;p&gt;比较常见的命令有:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;netstat&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lsof&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ps&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/proc/$pid&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;netstat&#34;&gt;netstat&lt;/h3&gt;


# netstat -tuapn


&lt;p&gt;参数解释:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -t tcp协议   
    -u udp协议   
    -a 显示listening和non-listening端口   
    -p 显示process ID  
    -n 显示数字IP，而不是字符形式的hostname   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以用grep命令对上条命令的输出进行过滤，显示某条端口的信息。&lt;/p&gt;

&lt;h3 id=&#34;lsof&#34;&gt;lsof&lt;/h3&gt;


# lsof -i :4000


&lt;p&gt;lsof列出机器上打开的所有文件。这条命令输出端口4000被占用的情况。它的输出形如&lt;br /&gt;
        COMMAND    PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME&lt;br /&gt;
        ruby-mri 10482 yyuan   11u  IPv4 252906      0t0  TCP localhost:terabase (LISTEN)&lt;/p&gt;

&lt;p&gt;可以看到进程号10482的进程占用了TCP端口4000。&lt;/p&gt;

&lt;h3 id=&#34;ps&#34;&gt;ps&lt;/h3&gt;


# ps aux


&lt;p&gt;参数解释:
        -a 显示所有用户的进程&lt;br /&gt;
        -u 显示进程的user/owner&lt;br /&gt;
        -x 也显示不与终端关联的进程&lt;/p&gt;

&lt;p&gt;同样地，也可以用grep命令对上条命令的输出进行过滤，显示某条端口的信息。&lt;/p&gt;

&lt;h3 id=&#34;proc-pid&#34;&gt;/proc/$pid&lt;/h3&gt;

&lt;p&gt;下面是该目录下，各个文件的作用:&lt;/p&gt;


..............................................................
File		Content
clear_refs	Clears page referenced bits shown in smaps output
cmdline		Command line arguments
cpu			Current and last cpu in which it was executed	(2.4)(smp)
cwd			Link to the current working directory
environ		Values of environment variables
exe			Link to the executable of this process
fd			Directory, which contains all file descriptors
maps		Memory maps to executables and library files	(2.4)
mem			Memory held by this process
root		Link to the root directory of this process
stat		Process status
statm		Process memory status information
status		Process status in human readable form
wchan		If CONFIG_KALLSYMS is set, a pre-decoded wchan
pagemap		Page table
stack		Report full stack trace, enable via CONFIG_STACKTRACE
smaps		a extension based on maps, showing the memory consumption of
each 		mapping and flags associated with it
...............................................................


&lt;h2 id=&#34;具体应用&#34;&gt;具体应用&lt;/h2&gt;

&lt;h3 id=&#34;找到进程3813的owener&#34;&gt;找到进程3813的owener&lt;/h3&gt;


# ps aux | grep 3813


&lt;p&gt;或者 cat /proc/3813/environ , 查看USER字段。&lt;/p&gt;

&lt;h3 id=&#34;看到一个根本不认识的端口号&#34;&gt;看到一个根本不认识的端口号&lt;/h3&gt;

&lt;p&gt;/etc/services文件用来将协议/端口号映射到服务的名字。可以用grep命令来匹配某个不认识的端口。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Eclipse中添加Tomcat插件</title>
      <link>https://blog.yuantops.com/tech/install-tomcat-plugin-in-eclipse/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/install-tomcat-plugin-in-eclipse/</guid>
      <description>&lt;p&gt;##安装Tomcat
&lt;strong&gt;下载链接&lt;/strong&gt;:&lt;a href=&#34;http://tomcat.apache.org/download-70.cgi&#34;&gt;Tomcat7&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;下载tar.gz包到本地，譬如到/home/yuan/Downloads目录&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;tar -zxf **.**.tar.gz&lt;/code&gt;命令解压tar.gz包，将解压出来的文件夹转移到你希望保存的目的地(譬如说/home/yuan/tomcat7)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用vi打开~/.bashrc文件，在末尾添加如下内容:&lt;br /&gt;
   alias tomcat=&amp;lsquo;bash ~/tomcat7/bin/startup.sh&amp;rsquo;&lt;br /&gt;
   export CATALINA_HOME=/home/tomcat7&lt;br /&gt;
   export JRE_HOME=/usr/lib/jvm/java-7-openjdk-i386/jre&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，JRE_HOME是本机的JRE环境所在目录，需要根据系统的安装情况而定。&lt;br /&gt;
保存退出&lt;/p&gt;

&lt;p&gt;现在，重新打开终端，运行&lt;code&gt;tomcat&lt;/code&gt;可以启动Tomcat服务&lt;/p&gt;

&lt;p&gt;##在Eclipse中添加Tomcat插件
&lt;strong&gt;下载链接&lt;/strong&gt;: &lt;a href=&#34;http://www.eclipsetotale.com/tomcatPlugin/tomcatPluginV33.zip&#34;&gt;TomcatPluginV33.zip&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;下载压缩包，将解压后的目录复制到Eclipse安装目录下的plugins/目录。启动Eclipse，可以在状态栏中看到三个有小猫的图标。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;菜单栏，&amp;rdquo;Window&amp;rdquo;-&amp;ldquo;Preferences&amp;rdquo;-&amp;ldquo;Tomcat&amp;rdquo;,将Tomcat version和Tomcat home改为对应值。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;单击小猫图标，即可启动Tomcat。在浏览器中输入&lt;code&gt;http://127.0.0.1:8080&lt;/code&gt;能看到欢迎页。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##在Eclipse中新建一个Tomcat项目
- &amp;ldquo;File&amp;rdquo;-&amp;ldquo;New&amp;rdquo;-&amp;ldquo;Project&amp;hellip;&amp;rdquo;-&amp;ldquo;Java&amp;rdquo;-&amp;ldquo;Tomcat Project&amp;rdquo;,新建一个Tomcat工程。&lt;br /&gt;
- 添加源码在&amp;rdquo;WEB-INF/src&amp;rdquo;目录下。&lt;br /&gt;
- 不要忘记在&amp;rdquo;WEB-INF&amp;rdquo;目录下添加web.xml文件。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPv4协议保留的私有IP段</title>
      <link>https://blog.yuantops.com/tech/ipv4-private-address-space/</link>
      <pubDate>Tue, 20 Jan 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/ipv4-private-address-space/</guid>
      <description>&lt;p&gt;这三个保留IP地址段是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;10.0.0.0/8 IP addresses: 10.0.0.0 &amp;ndash; 10.255.255.255&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;172.16.0.0/12 IP addresses: 172.16.0.0 &amp;ndash; 172.31.255.255&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;192.168.0.0/16 IP addresses: 192.168.0.0 – 192.168.255.255&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意，所有以&amp;rdquo;172&amp;rdquo;和&amp;rdquo;192&amp;rdquo;打头的IP中只有部分是保留IP。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>北邮校园网通过配置IPv6使用Google服务</title>
      <link>https://blog.yuantops.com/tech/config-ipv6-to-bypass-gfw-in-bupt/</link>
      <pubDate>Sat, 17 Jan 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/config-ipv6-to-bypass-gfw-in-bupt/</guid>
      <description>

&lt;h2 id=&#34;前提&#34;&gt;前提&lt;/h2&gt;

&lt;p&gt;首先，本文针对的是北邮校园网。我在北邮学十亲测，机器是Linux Mint。&lt;/p&gt;

&lt;p&gt;其次，请确保:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;自己的机器支持IPv6。Win7默认安装了IPv6协议，WinXP可能需要自己手动安装。我自己的Linux mint默认安装了IPv6。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;自己的网络支持IPv6。包括北邮在内的绝大多数高校校园网都架设了IPv6，通过校园网上网的同学理论上不必担心这点。所以，还在使用校园网的同学们，趁IPv6还没被盯上，珍惜现在吧。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;验证方法&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;打开浏览器，访问&lt;a href=&#34;http://ipv6-test.com/&#34;&gt;IPv6test.com&lt;/a&gt;，页面上&amp;rdquo;IPv6 connectivity&amp;rdquo;一项如果显示&amp;rdquo;Supported&amp;rdquo;，说明前提条件满足。或者访问&lt;a href=&#34;http://bt.byr.cn&#34;&gt;BYR BT&lt;/a&gt;，这是只支持IPv6方式访问的站点，如果能访问也说明前提条件满足。&lt;/p&gt;

&lt;h2 id=&#34;目标&#34;&gt;目标&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用谷歌的服务(google search, gmail, google calendar, google scholar, google plus, youtube, etc.)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;访问其它支持IPv6的网站: wikipedia, facebook, etc.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了能部分避开G)(F)(W之外，北邮校园网内通过IPv6通道产生的流量是不计费的，所以，即使从节约流量这一点看也是值得的。&lt;/p&gt;

&lt;h2 id=&#34;姿势简介&#34;&gt;姿势简介&lt;/h2&gt;

&lt;p&gt;总的来说，这个方法是靠访问网站的IPv6地址。如果要去的网站没有IPv6地址，那就没辙。而让我的电脑知道一个网站的IPv6地址(如果存在的话)，有两个法子:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;修改hosts文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用IPv6 DNS服务器&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当系统准备访问一个站点时，它需要知道目的站点的IP地址。它先会读取hosts文件，看里面是否有* IP-主机名* 的记录。如果有，它会直接按IP地址访问站点。如果hosts文件中没有相应记录，那么它会向系统设置的DNS服务器查询。DNS服务器会返回目的站点的IP地址。&lt;/p&gt;

&lt;p&gt;所以，这两个方法可以同时使用。(有关DNS的知识，本文限于篇幅将不做讨论。)&lt;/p&gt;

&lt;h3 id=&#34;修改hosts文件&#34;&gt;修改hosts文件&lt;/h3&gt;

&lt;p&gt;这是一份内容随时更新的hosts文件：&lt;a href=&#34;https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/hosts&#34;&gt;Hosts&lt;/a&gt; 。这份文件属于托管在GitHub上的&lt;a href=&#34;https://github.com/lennylxx/ipv6-hosts/&#34;&gt;一个项目&lt;/a&gt;，里面除了IPv6地址外还有一小部分由活雷锋搜集的IPv4地址，大家可以参考。&lt;/p&gt;

&lt;p&gt;将&lt;a href=&#34;https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/hosts&#34;&gt;Hosts&lt;/a&gt;文件的文本复制过来，用任意一款文字编辑器打开hosts文件，将内容粘贴进来。&lt;/p&gt;

&lt;p&gt;hosts文件在不同操作系统中的位置不同。在Windows下，它的默认路径是:&lt;br /&gt;
        %SystemRoot%\system32\drivers\etc\hosts&lt;/p&gt;

&lt;p&gt;在Linux下，以我的Mint为例，它的路径是:&lt;br /&gt;
        /etc/hosts&lt;/p&gt;

&lt;p&gt;修改它需要系统权限。如果是Linux，记得在前面加上sudo。&lt;/p&gt;

&lt;p&gt;改完hosts，就已经能达到我们的目标了，可以使用Google的服务了。当然，我们还可以继续下面一步，来个双保险。&lt;/p&gt;

&lt;h3 id=&#34;使用ipv6-dns服务器&#34;&gt;使用IPv6 DNS服务器&lt;/h3&gt;

&lt;p&gt;支持IPv6 的免费DNS解析服务器很多，在此仅以Google为例。如果使用其它的IPv6 DNS服务器，将下文中的IP地址替换过来就好。&lt;/p&gt;

&lt;p&gt;Google提供公共&lt;a href=&#34;https://developers.google.com/speed/public-dns/docs/using&#34;&gt;DNS解析服务&lt;/a&gt;，能解析IPv6地址。Google DNS服务器在它的IPv6地址上监听IPv6的通道发来的查询请求。如果这个查询求的是IPv6地址，而且地址存在，那么Google服务器会返回结果AAAA记录。&lt;/p&gt;

&lt;p&gt;GoogleDNS服务器的IPv6地址是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2001:4860:4860::8888&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2001:4860:4860::8844&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;将它们设为自己的首选DNS服务器。对于一个典型的Linux系统:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;编辑/etc/resolv.conf文件:&lt;br /&gt;
    sudo vi /etc/resolv.conf&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;添加如下两条记录:&lt;br /&gt;
nameserver 2001:4860:4860::8888&lt;br /&gt;
nameserver 2001:4860:4860::8844&lt;br /&gt;
这两条记录顺序无所谓；也可以只添加一条。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;保存退出。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果系统是通过DHCP服务器获取的IP地址，那么resolv.conf文件可能会在每次开机时自动被初始化覆盖。这时，可以尝试将DNS服务器的记录保存在初始化的配置文件中。&lt;/p&gt;

&lt;p&gt;例如，我的Mint中/etc/resolv.f文件提示“OpenDNS Fallback (configured by Linux Mint in /etc/resolvconf/resolv.conf.d/tail)”，那么我将这两条记录拷贝到/etc/resolvconf/resolv.conf.d/tail里就好了。&lt;/p&gt;

&lt;p&gt;好了，到现在配置已经完成。可以通过浏览器访问Google的网站试试看了。&lt;/p&gt;

&lt;h2 id=&#34;其它&#34;&gt;其它&lt;/h2&gt;

&lt;h3 id=&#34;北邮校园网内网的dns服务器&#34;&gt;北邮校园网内网的DNS服务器&lt;/h3&gt;

&lt;p&gt;DNS查询也是需要走校外流量的。所以，最好不要将首选DNS服务器设置为外网服务器。北邮校园网内搭建有DNS服务器，譬如:&lt;/p&gt;

&lt;p&gt;#学十能用的内网DNS服务器&lt;br /&gt;
    10.3.9.4， 10.3.9.5， 10.3.9.6&lt;/p&gt;

&lt;h3 id=&#34;手机科学上网&#34;&gt;手机科学上网&lt;/h3&gt;

&lt;p&gt;如果手机通过WiFi接入IPv6网络，修改DNS服务器地址为Google DNS服务器的地址，那么手机也能访问Google了。亲测，iOS7的safari能打开youtube。&lt;/p&gt;

&lt;h3 id=&#34;一些观察手段&#34;&gt;一些观察手段&lt;/h3&gt;

&lt;p&gt;在Chrome浏览器地址栏中输入: &lt;code&gt;chrome://net-internals/#dns&lt;/code&gt;可以看到浏览器的DNS解析记录。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>厘清Java Socket端口问题 -- 服务器的端口是什么</title>
      <link>https://blog.yuantops.com/tech/some-clarification-about-java-socket-port/</link>
      <pubDate>Tue, 13 Jan 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/some-clarification-about-java-socket-port/</guid>
      <description>

&lt;p&gt;在我之前翻译的&lt;a href=&#34;http://blog.yuantops.com/tech/socket-definition-oracle-java-tutorial/&#34;&gt;Socket是什么&lt;/a&gt;一文中，对java中socket建立的流程有描述。在服务器接受客户端socket连接的部分，它这么说道：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果一切顺利，服务器会接受连接。一旦接受了连接，服务器会得到一个绑定了&lt;strong&gt;本地相同端口&lt;/strong&gt;的新socket，这个socket的另一端被置为客户端的地址和端口。服务器需要一个新的socket,所以它能一边继续在原来的socket监听连接请求，一边处理已建立连接的客户端的需求。&lt;/p&gt;

&lt;p&gt;(原文)&lt;br /&gt;
If everything goes well, the server accepts the connection. Upon acceptance, the server gets a new socket bound to the &lt;strong&gt;same local port&lt;/strong&gt; and also has its remote endpoint set to the address and port of the client. It needs a new socket so that it can continue to listen to the original socket for connection requests while tending to the needs of the connected client.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;配图:&lt;br /&gt;
&lt;img src=&#34;http://docs.oracle.com/javase/tutorial/figures/networking/6connect.gif&#34; alt=&#34;socket connection established&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本地相同端口(same local port)&lt;/strong&gt;指的到底是哪个端口？依示例图所示，它指的就是服务器端的&lt;strong&gt;监听端口&lt;/strong&gt;，而不是其它的端口。&lt;/p&gt;

&lt;p&gt;官方文档的说法按说是权威的——事实上的确它是对的。但是，在*Head First Java*中描述ServerSocket.accept()方法有这么一段话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When a client finally tries to connect, the method returns a plain old Socket(on a different port) that knows how to communicate with the client(i.e, knows the client&amp;rsquo;s IP address and the port number).&lt;/p&gt;

&lt;p&gt;The socket is on a different port than the ServerSocket, so that the server socket can go back to waiting for other clients.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个说法就不太正确了。幸好*Head First Java*出版社已经发现了这个小失误，并在官方网站的勘误表上贴出了&lt;a href=&#34;http://www.oreilly.com/catalog/errataunconfirmed.csp?isbn=9780596009205&#34;&gt;说明&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This isn&amp;rsquo;t the case. The thing that has to be unique for each socket is the source port, source ip, destination port &amp;amp; destination ip.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;根据勘误表上的解释，每一个socket连接都需要保证是唯一的，而socket的标志符由源IP、源端口、目的IP、目的端口四部分构成。只要四者有一个不同，那么就能建立两个不同的socket。所以，对于不同的Socket连接，服务器端的IP和端口号可以相同。&lt;/p&gt;

&lt;p&gt;但*Head First Java*十分畅销，导致错误的说法流传甚广，造成了学习者很多误解。&lt;/p&gt;

&lt;h3 id=&#34;来源参考&#34;&gt;来源参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/4307549/serversocket-accept-method/4308243#4308243&#34;&gt;StackOverflow.com&lt;/a&gt;有网友这么解释道：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The client chooses its port at random (you don&amp;rsquo;t need to do anything special in Java) and connects to the server on whichever port you specified.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;实践验证&#34;&gt;实践验证&lt;/h3&gt;

&lt;p&gt;根据这个网友提供的思路，我们可以实际检验一下。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/networking/sockets/clientServer.html&#34;&gt;Writing the server side of a socket&lt;/a&gt;中提供了客户端和服务器端的两个小例子。按照文章里面说的，我将几段代码下载到我的Fedora机器上，先运行服务器代码，它监听4444端口。&lt;br /&gt;
java KnockKnockServer 4444&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;netstat -na&lt;/code&gt; 命令查看机器上打开的端口，(省略无关条目)：&lt;br /&gt;

Proto Recv-Q Send-Q Local Address   Foreign Address         State      
tcp6       0      0        :::4444       :::*               LISTEN
&lt;/p&gt;

&lt;p&gt;再运行客户端代码，它与本机上的服务器程序建立socket连接。&lt;br /&gt;
java KnockKnockClient 127.0.0.1 4444&lt;br /&gt;
再使用&lt;code&gt;netstat -na&lt;/code&gt; 命令查看机器上打开的端口，(省略无关条目)：&lt;br /&gt;

Proto Recv-Q Send-Q Local Address   Foreign Address         State      
tcp6       0      0 :::4444                 :::*                    LISTEN     
tcp6       0      0 127.0.0.1:50031         127.0.0.1:4444          ESTABLISHED  
tcp6       0      0 127.0.0.1:4444          127.0.0.1:50031         ESTABLISHED  
&lt;/p&gt;

&lt;p&gt;有两条socket的记录。其中一条是服务器的，另一条是客户端的。它们的local address和foreign address刚好是相反的，这对应了socket的local和remote概念。从这两条记录看，建立的socket连接，服务器端占用的端口还是监听端口(4444)，而且此时服务器还在端口(4444)监听连接请求。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>理解Docker -- Docker Official Docs翻译</title>
      <link>https://blog.yuantops.com/tech/understanding-docker/</link>
      <pubDate>Mon, 12 Jan 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/understanding-docker/</guid>
      <description>

&lt;h3 id=&#34;docker是什么&#34;&gt;Docker是什么&lt;/h3&gt;

&lt;p&gt;Docker是用于开发(develop)、转移(ship)、运行(run)程序(application)的一个开放平台。Docker的设计目的是为了更快地传递程序。在Docker的帮助下，你能将程序与硬件基础(infrastructure)隔离、把硬件基础看作一个可管理的程序。Docker能帮你更快地转移代码、测试代码、部署代码，缩短编写代码与运行代码之间的周期。&lt;/p&gt;

&lt;p&gt;Docker将一种轻量级的容器虚拟化平台技术(container virtualization platform)与相应的工作流程和工具结合起来，从而能帮你管理、部署自己的程序。&lt;/p&gt;

&lt;p&gt;在核心层面，Docker支持在一个容器(container)中安全(securely)、独立(isolated)地运行几乎任何一种程序。这种独立性、安全性允许你在主机(host)上同时运行多个容器。容器在运行时不需要分配额外负载给监视程序(hypervisor)，它的这种轻量级特性意味着你能更大限度地使用硬件资源。&lt;/p&gt;

&lt;p&gt;基于容器虚拟化，Docker提供的工具和平台能帮助你：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将你的程序(和支持的组件)放到Docker容器中&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;分发(distribute)、转移(ship)这些容器给自己的团队成员，以便他们后续的开发和测试&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;把这些程序部署到产品环境中，不管你的产品环境位于本地数据中心还是在云中&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;我能用docker做什么&#34;&gt;我能用Docker做什么？&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;更快地转移程序&lt;/em&gt;&lt;br /&gt;
Docker是帮你处理开发周期的绝好工具。Docker能允许开发者在包含你的程序和服务的本地容器上开发，然后它能整合到一个连续的整合、部署工作流程中。&lt;/p&gt;

&lt;p&gt;举个例子。开发者在本地编写程序，通过Docker将开发环境与同事共享。当他们的工作完成时，开发者将他们的代码和开发环境推送到一个测试环境上，并且执行任何必要的测试。然后，你能从测试环境将Docker镜像(image)推送到产品，部署代码。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;更方便地部署、扩展&lt;/em&gt;&lt;br /&gt;
Docker基于容器的平台支持高便携性(portable)的工作负载(workload)。Docker容器能运行在开发者的本地机器上、数据中心的物理/虚拟机器上，也能运行在云端。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;支持更高密度，运行更多工作负载&lt;/em&gt;&lt;br /&gt;
Docker是轻量级的，而且很快。与基于监督程序(hypervisor)的虚拟机相比，它提供了可变的、低消耗的替代方案。在高密度(high density)的工作环境中，这一点就显得格外重要，例如：当搭建你自己的云或者Platform-as-a-service服务时。不止如此，当你想尽可能地利用你的资源来做小型/中型的部署时，Docker也同样有用。&lt;/p&gt;

&lt;h2 id=&#34;docker的主要组件有哪些&#34;&gt;Docker的主要组件有哪些？&lt;/h2&gt;

&lt;p&gt;Docker主要组件有两个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Docker: 开源的容器虚拟化平台&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;：Software-as-a-Service平台，用来分享、管理Docker容器&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：Docker受开源协议Apache 2.0约束&lt;/p&gt;

&lt;h2 id=&#34;docker的架构&#34;&gt;Docker的架构&lt;/h2&gt;

&lt;p&gt;Docker使用客户端-服务器架构。Docker&lt;em&gt;客户端&lt;/em&gt;(client)与Docker&lt;em&gt;守护进程&lt;/em&gt;(deamon)通信，后者来完成建立版本(build)、运行(run)、分发(distribute)Docker容器等工作。Docker客户端和守护进程*可以*同时运行在一个系统上；你也可以将Docker客户端连接到一个远程Docker守护进程。Docker客户端和Docker守护进程通过socket或者REST API通信。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://docs.docker.com/article-img/architecture.svg&#34; alt=&#34;Docker Arch&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;docker守护进程&#34;&gt;Docker守护进程&lt;/h3&gt;

&lt;p&gt;如上图所示，Docker守护进程运行在一台宿主机器上。用户不直接与守护进程通信，而是通过客户端与之通信。&lt;/p&gt;

&lt;h3 id=&#34;docker客户端&#34;&gt;Docker客户端&lt;/h3&gt;

&lt;p&gt;Docker客户端，往往是二进制形式的&lt;code&gt;docker&lt;/code&gt;程序，是Docker最主要的用户使用接口。它接收来自用户的命令，将它来回地与守护程序进行通信。&lt;/p&gt;

&lt;h3 id=&#34;在docker内部&#34;&gt;在Docker内部&lt;/h3&gt;

&lt;p&gt;为了理解Docker的内部原理，你需要理解三个组件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;镜像(image)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;仓库(registry)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;容器(container)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;镜像&#34;&gt;#镜像&lt;/h3&gt;

&lt;p&gt;镜像是一个只读(read-only)的模板。例如，一个镜像可能包含安装了Apache和你的Web服务器的一个Ubuntu操作系统。镜像是用来创造Docker容器的。通过Docker，你能以简单的方式创建新的镜像、更新现存的镜像，或者下载别人已经创建好了的镜像。Docker镜像是Docker的&lt;strong&gt;创建(build)&lt;/strong&gt;组件。&lt;/p&gt;

&lt;h3 id=&#34;仓库&#34;&gt;仓库&lt;/h3&gt;

&lt;p&gt;仓库保存镜像。它们是你用来上传、下载镜像的私有/公有场所。官方的Docker仓库是&lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;，它提供了一个巨大的镜像仓库集以供你使用。你可以自己创建镜像，也可以使用别人事先已经建好了的镜像。Docker仓库是Docker的&lt;strong&gt;分发(distribute)&lt;/strong&gt;组件。&lt;/p&gt;

&lt;h3 id=&#34;容器&#34;&gt;容器&lt;/h3&gt;

&lt;p&gt;容器与目录类似。容器包含了运行一个程序所需要的所有东西。每个容器都是创建自一个镜像。容器可以被运行、启动、停止、移动、删除。每个容器都是一个隔离、安全的程序平台。Docker容器是Docker的&lt;strong&gt;运行(run)&lt;/strong&gt;组件。&lt;/p&gt;

&lt;h2 id=&#34;那么-docker到底如何工作&#34;&gt;那么，Docker到底如何工作？&lt;/h2&gt;

&lt;p&gt;现在，我们已经知道：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;你可以创建Docker镜像来保存程序&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;你可以从Docker镜像中新建Docker容器来运行程序&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;你可以通过&lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;或者自己的私有仓库来分享Docker镜像&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面，让我们看看这些组件是如何协作起来使Docker工作的。&lt;/p&gt;

&lt;h2 id=&#34;镜像如何工作&#34;&gt;镜像如何工作？&lt;/h2&gt;

&lt;p&gt;我们已经知道，镜像是只读模板，由它们启动容器。每个镜像由一系列层(layer)组成。Docker利用&lt;a href=&#34;http://en.wikipedia.org/wiki/UnionFS&#34;&gt;union file system&lt;/a&gt;将这些层组合成单个镜像。Union file system允许独立文件系统的文件和目录(被称作branch)被透明地叠架起来(overlaid)，以此组成一个单个紧密的文件系统。&lt;/p&gt;

&lt;p&gt;Docker被称为“轻量级”，原因之一就在于这些层。当你改变一个镜像的时候，譬如说将某个程序更新到了新版本，一个层会被新建出来。如果我们使用的是虚拟机，这时候往往需要替换整个镜像，要不就是整体再创建一个版本。对比之下，Docker只需添加或者更新一个层。如此，你不必再去分发一整个镜像，而仅仅需要更新层就好了，这使得发布Docker的镜像变得更快、更容易。&lt;/p&gt;

&lt;p&gt;每个镜像都以一个基础镜像为起点，譬如&lt;code&gt;ubuntu&lt;/code&gt;，一个基础的Ubuntu镜像，或者&lt;code&gt;fedora&lt;/code&gt;，一个基础的Fedora镜像。你也可以用自己的镜像做新镜像的基础镜像，譬如如果你有个基础的Apache镜像，你就能用它作你所有网页程序镜像的基础。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：Docker一般从&lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;中获取基础镜像。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从基础镜像出发，我们能通过简单、描述性的一系列步骤(我们称其为&lt;em&gt;指示(instructions)&lt;/em&gt;)新建一个镜像。每一步都会在我们的镜像中新建一个层。这些步骤包括以下动作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;运行命令&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;添加文件或者目录&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;创建环境变量&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;定义当启动从这个镜像创建的容器时，应该运行那些进程&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些指示被保存在&lt;code&gt;Dockerfile&lt;/code&gt;文件中。当你申请从镜像生成一个版本(build)时，Docker会读取&lt;code&gt;Dockerfile&lt;/code&gt;、执行指示，然后返回最终的镜像。&lt;/p&gt;

&lt;h2 id=&#34;仓库如何工作&#34;&gt;仓库如何工作？&lt;/h2&gt;

&lt;p&gt;仓库是Docker镜像的存储之处。当你创建了一个镜像，你可以将它推送到公共仓库&lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;或者自己防火墙之内的私有仓库。&lt;/p&gt;

&lt;p&gt;使用Docker客户端，你能搜索已发布的镜像，然后将它们拉去到本地的Docker主机，再从它里面创建容器。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;提供镜像的公有和私有存储。公有存储可以被任何人搜索、下载。私有存储不显示在搜索结果中，而且只有你和你的用户能从中拉取镜像、用这些镜像来生成容器。&lt;/p&gt;

&lt;h2 id=&#34;容器如何工作&#34;&gt;容器如何工作？&lt;/h2&gt;

&lt;p&gt;容器由操作系统、用户添加的文件和元文件(meta-data)构成。我们已经知道，每个容器都由一个镜像创建。这个镜像告诉Docker应该持有什么、在启动容器时应该运行什么，以及其他一系列的配置文件。镜像是只读的。当Docker从镜像创建一个容器时，它在镜像的顶端加上一个读写层(read-write layer)，这样我们的程序就能在它上面运行了。&lt;/p&gt;

&lt;h2 id=&#34;启动一个容器时-发生了什么&#34;&gt;启动一个容器时，发生了什么&lt;/h2&gt;

&lt;p&gt;不论通过&lt;code&gt;docker&lt;/code&gt;命令还是API，Docker客户端通知Docker守护进程去启动一个容器。&lt;br /&gt;
$ sudo docker run -i -t ubuntu /bin/bash&lt;/p&gt;

&lt;p&gt;我们将这条命令分解来看。Docker客户端通过带&lt;code&gt;run&lt;/code&gt;参数的&lt;code&gt;docker&lt;/code&gt;命令新启动一个容器。为了启动一个容器，Docker客户端至少需要告知Docker守护进程：&lt;br /&gt;
- 容器应该创建自哪个Docker镜像。在这里是&lt;code&gt;ubuntu&lt;/code&gt;，一个基础Ubuntu镜像。&lt;br /&gt;
- 当容器启动后，你要在容器内运行什么命令。这里是&lt;code&gt;/bin/bash&lt;/code&gt;，它在容器内启动了Bash shell。&lt;/p&gt;

&lt;p&gt;那么，当我们运行这条命令时，后台发生了什么呢？&lt;/p&gt;

&lt;p&gt;Docker按顺序做了如下事情：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;拉取ubunut镜像&lt;/strong&gt;：Docker检查&lt;code&gt;ubuntu&lt;/code&gt;镜像是否存在，如果在本地不存在，那么它从&lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;下载镜像；如果镜像已经存在，Docker将利用它启动新容器。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建新容器&lt;/strong&gt;：Docker有了镜像，用它来新建一个容器。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分配文件系统，挂载读写层&lt;/strong&gt;：在文件系统中新建了容器，并给镜像新添了一个读写层。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分配网络/网桥接口&lt;/strong&gt;：新建一个网络接口，使Docker容器能与本地主机通信。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设置IP地址&lt;/strong&gt;：从地址池中找到一个可用IP，将它关联到容器。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行你指定的程序&lt;/strong&gt;：运行程序。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;捕获、提供程序输出结果&lt;/strong&gt;：连接并记录标准输入、标准输出、标准错误，使你能看到程序的运行情况。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;恭喜，你有了一个运行中的容器！从这里，你可以管理容器，与程序交互，然后当结束后停止、移除容器。&lt;/p&gt;

&lt;h2 id=&#34;底层技术&#34;&gt;底层技术&lt;/h2&gt;

&lt;p&gt;Docker用Go语言编写，而且利用了Linux 内核的相关特性来完成上述的功能。&lt;/p&gt;

&lt;h3 id=&#34;命名空间-namespace&#34;&gt;命名空间(namespace)&lt;/h3&gt;

&lt;p&gt;Docker使用了一项叫作&lt;code&gt;命名空间(namespace)&lt;/code&gt;的技术来为容器提供隔离的工作空间。当我们启动一个容器时，Docker会为它创建一系列命名空间。&lt;/p&gt;

&lt;p&gt;这样形成了一个隔离层：容器的每个部分都在它自己的命名空间里运行，而且没有访问它之外的权限。&lt;/p&gt;

&lt;p&gt;Docker使用的部分命名空间包括：&lt;br /&gt;
- &lt;strong&gt;pid命名空间&lt;/strong&gt;：用于进程隔离(PID, Process ID)&lt;br /&gt;
- &lt;strong&gt;net命名空间&lt;/strong&gt;：用于管理网络接口(NET, networking)&lt;br /&gt;
- &lt;strong&gt;ipc命名空间&lt;/strong&gt;：用于管理IPC资源(IPC, InterProcess Communication进程间通信)&lt;br /&gt;
- &lt;strong&gt;mnt命名空间&lt;/strong&gt;：用于管理挂载点(MNT, Mount)&lt;br /&gt;
- &lt;strong&gt;uts命名空间&lt;/strong&gt;：用于内核和版本标志隔离(UTS, Unix Timesharing System)&lt;/p&gt;

&lt;h3 id=&#34;组控制-control-groups&#34;&gt;组控制(Control groups)&lt;/h3&gt;

&lt;p&gt;Docker还用到&lt;code&gt;cgroups&lt;/code&gt;技术来进行组控制。隔离运行中程序的关键一点在于，让它们只使用你想让它使用的资源。这确保这些容器在宿主机器上能规规矩矩的。组控制允许Docker能向容器共享硬件资源，而且在必要时候设置资源的上限和限制。例如，可以设置某个特定容器的内存上限。&lt;/p&gt;

&lt;h3 id=&#34;union-file-systems&#34;&gt;Union file Systems&lt;/h3&gt;

&lt;p&gt;Union file Systems，或者UnionFS，是通过创建层的方式运行的，轻量、快速的文件系统。Docker使用Union file Systems为容器提供块(block)。Docker能利用包括AUFS, btrfs, vfs, 和DeviceMapper在内的Union file Systems。&lt;/p&gt;

&lt;h3 id=&#34;容器格式&#34;&gt;容器格式&lt;/h3&gt;

&lt;p&gt;Docker将这些组件结合成一个我们称之为容器格式的包裹层(wrapper)。默认的容器格式被称作&lt;code&gt;libcontainer&lt;/code&gt;。Docker也支持使用&lt;a href=&#34;https://linuxcontainers.org/&#34;&gt;LXC&lt;/a&gt;的传统Linux容器。未来，Docker可能会支持更多的容器格式，例如可能会整合BSD Jail或者Solaris Zone。&lt;/p&gt;

&lt;h2 id=&#34;下一步&#34;&gt;下一步&lt;/h2&gt;

&lt;h3 id=&#34;安装docker&#34;&gt;安装Docker&lt;/h3&gt;

&lt;p&gt;访问&lt;a href=&#34;https://docs.docker.com/installation/#installation&#34;&gt;installation guide&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;docker用户指南&#34;&gt;Docker用户指南&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/userguide/&#34;&gt;Learn Docker in depth&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;原文链接&#34;&gt;原文链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/introduction/understanding-docker/&#34;&gt;About Docker&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Activity的生命周期以及两个Activity跳转时的状态变化</title>
      <link>https://blog.yuantops.com/tech/android-activity-lifecycle-with-two-activites/</link>
      <pubDate>Sun, 11 Jan 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/android-activity-lifecycle-with-two-activites/</guid>
      <description>&lt;p&gt;##Android Activity的生命周期
下面这张图非常清晰地介绍了Activity的生命周期：&lt;br /&gt;
&lt;img src=&#34;http://www.startandroid.ru/images/stories/lessons/L0023/L0023_010_en.jpg&#34; alt=&#34;Activity Lifecycle&#34; /&gt;&lt;/p&gt;

&lt;p&gt;##当通过intent跳转时的状态变化
一个Activity的状态有三个：Stopped(存在但看不见)，Paused(部分可见，但无焦点)，Resumed(激活状态，拥有焦点，可以与之交互)。如果将不存在也算作一个状态，那样一共就有四个状态。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.startandroid.ru/en/lessons/complete-list/232-lesson-24-activity-lifecycle-example-about-changing-states-with-two-activities.html&#34;&gt;这篇文章&lt;/a&gt;非常详细地讨论了当通过intent在一个Activity中启动另一个Activity时，它们两个Activity的状态变化过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当由MainActivity跳转到ActivityTwo时&lt;/strong&gt;，下面是方法的调用顺序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    MainActivity: onPause()     
ActivityTwo: onCreate()     
ActivityTwo: onStart()     
ActivityTwo: onResume()     
MainActivity: onStop()     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;步骤为：MainActivity失去焦点，转到Paused状态-&amp;gt;ActivityTwo新建但不可见,处于Stopped状态-&amp;gt;ActivityTwo可见，处于Paused状态-&amp;gt;ActivityTwo获得焦点，处于Resumed状态-&amp;gt;MainActivity不可见，处于Stopped状态。&lt;/p&gt;

&lt;p&gt;值得注意的是，当ActivityTwo位于前台时，MainActivity并没有被销毁，而是仍保存在内存中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;按下后退键，由ActivityTwo返回MainActivity时&lt;/strong&gt;，方法的调用顺序为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ActivityTwo: onPause()     
MainActivity: onRestart()     
MainActivity: onStart()     
MainActivity: onResume()     
ActivityTwo: onStop()     
ActivityTwo: onDestroy()   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;步骤与上一步类似。值得注意之处有二：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;其一，MainActivity.onRestart方法先于MainActivity.onStart方法调用。如果Activity不是从无到有新建出来的，那么在onStart方法前都会先调用onRestart方法。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;其二，ActivityTwo被销毁了。至于为什么此时ActivityTwo会被销毁，涉及到Task的原理。在&lt;a href=&#34;http://www.startandroid.ru/en/lessons/complete-list/234-lesson-25-task-what-is-it-and-how-it-is-formed.html&#34;&gt;这篇文章&lt;/a&gt;中有介绍。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Android中Context的作用</title>
      <link>https://blog.yuantops.com/tech/use-of-context-in-android/</link>
      <pubDate>Sun, 11 Jan 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/use-of-context-in-android/</guid>
      <description>&lt;p&gt;##官方文档中对Context的介绍
&amp;gt;Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc.&lt;/p&gt;

&lt;p&gt;翻译：&lt;br /&gt;
Context是Android应用的全局信息的接口。它是一个虚类，它的实现由Android系统完成。它提供了对某个应用的资源和类的访问权限，也提供对应用层面操作(如启动Activity，发送broadcast，接受intent)的调用接口。&lt;/p&gt;

&lt;p&gt;##总结
&lt;a href=&#34;http://stackoverflow.com/questions/3572463/what-is-context-in-android&#34;&gt;StackoverFlow.com&lt;/a&gt;上有人根据自己的理解总结了Context的用法，说得很有道理，以下是我的翻译。&lt;/p&gt;

&lt;p&gt;正如Context的名字所说，它是一个应用/对象(applicaton/object)当前状态的上下文。它让新建的对象知道当前正在发生着什么。典型的用法，你可以调用它来得到关于你程序其它部分(Activity，package/application等)的信息。&lt;/p&gt;

&lt;p&gt;你可以通过以下方式得到context: getApplicationContext(), getContext(), getBaseContext()或者this(当位于一个Activity class中时)。&lt;/p&gt;

&lt;p&gt;典型用法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;新建对象&lt;/strong&gt;：新建views, adapters, listeners等：&lt;br /&gt;
    TextView tv = new TextView(getContext());
ListAdapter adapter = new SimpleCursorAdapter(getApplicationContext(), &amp;hellip;);&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;访问资源&lt;/strong&gt;：譬如LAYOUT_INFLATER_SERVICE, SharedPreferences一类的资源：&lt;br /&gt;
    context.getSystemService(LAYOUT_INFLATER_SERVICE)&lt;br /&gt;
    getApplicationContext().getSharedPreferences(&lt;em&gt;name&lt;/em&gt;, &lt;em&gt;mode&lt;/em&gt;);&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;隐式访问组件&lt;/strong&gt;：content providers, broadcast, intent 等：&lt;br /&gt;
    getApplicationContext().getContentResolver().query(uri, &amp;hellip;);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Sockets in Java -- Oracle Java Tutorial 翻译</title>
      <link>https://blog.yuantops.com/tech/java-all-about-sockets-oracle-java-tutorial/</link>
      <pubDate>Sun, 11 Jan 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/java-all-about-sockets-oracle-java-tutorial/</guid>
      <description>&lt;p&gt;##课程：关于Sockets的一切
URL和URLConnection为获取因特网上的资源提供了一种相对高层次(high-level)的机制。但有时候，你的程序需要一种相对低层次(lower-level)的网络通信，譬如说，你可能需要编写一个客户端-服务器(client-server)程序。&lt;/p&gt;

&lt;p&gt;在客户端-服务器程序中，服务器端提供一些服务：譬如处理数据库查询，或者发送当前的期货价格。客户端利用服务器提供的这些服务器，用来向用户显示数据库查询的结果，或者给投资者提供期货的购买建议。客户端和服务器端的通信因此必须是&lt;strong&gt;可信&lt;/strong&gt;的。换言之，数据不能丢失，而且它到达客户端的顺序必须与服务器的发送顺序一致。&lt;/p&gt;

&lt;p&gt;TCP协议提供了一个可信的、点到点的通信信道，因特网上的客户端-服务器端程序可以使用它来通信。为了基于TCP通信，客户端程序和服务器程序要和对方建立连接。每个程序各自将一个socket绑定到连接的一头。当通信时，客户端和服务器各自从与连接绑定的socket里面读/写数据。&lt;/p&gt;

&lt;p&gt;##Socket是什么?
因特网上运行着的两个程序建立了一个双向的通信连接，Socket就是这个连接的一端。Socket类用来表示一个客户端程序和一个服务器程序间的连接。java.net包中提供了Socket和ServerSocket这两个类，它们分别是这一连接的客户端实现和服务器端实现。&lt;/p&gt;

&lt;p&gt;##通过Socket读和写
&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/networking/sockets/readingWriting.html&#34;&gt;Reading from and Writing to a Socket&lt;/a&gt;包含一个小例子，它演示了客户端程序如何从Socket读数据和向socket写数据。&lt;/p&gt;

&lt;p&gt;##编写一对socket Client/Server
&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/networking/sockets/readingWriting.html&#34;&gt;Reading from and Writing to a Socket&lt;/a&gt;演示了客户端程序如何通过socket与一个存在的服务器端交互。&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/networking/sockets/clientServer.html&#34;&gt;Writing a Client/Server Pair&lt;/a&gt;则演示如何实现连接的另一端——服务器端的功能。&lt;/p&gt;

&lt;p&gt;##原文链接
&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/networking/sockets/index.html&#34;&gt;Lesson: All About Sockets&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Socket是什么 -- Oracle Java Tutorial 翻译</title>
      <link>https://blog.yuantops.com/tech/socket-definition-oracle-java-tutorial/</link>
      <pubDate>Sun, 11 Jan 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/socket-definition-oracle-java-tutorial/</guid>
      <description>&lt;p&gt;一般而言，一个服务器运行在一台电脑上，这个服务器有一个绑定了端口号的socket。这个服务器一边等待，一边守着socket监听从客户端发过来的连接请求。&lt;/p&gt;

&lt;p&gt;在客户端：客户端知道服务器所在的主机的主机名(hostname)和服务器正在监听的端口号。为了发出连接请求，客户端尝试着连接服务器所在的主机名和端口。客户端同时也需要向服务器端证明自己的身份，因此它也绑定了一个本地的端口号以便在本次连接中使用。这一般是由系统指定的。&lt;br /&gt;
&lt;img src=&#34;http://docs.oracle.com/javase/tutorial/figures/networking/5connect.gif&#34; alt=&#34;Server listening on port&#34; /&gt;&lt;br /&gt;
如果一切顺利，服务器会接受连接。一旦接受了连接，服务器会得到一个绑定了本地相同端口的新socket，这个socket的另一端被置为客户端的地址和端口。服务器需要一个新的socket,所以它能一边继续在原来的socket监听连接请求，一边处理已建立连接的客户端的需求。&lt;br /&gt;
&lt;img src=&#34;http://docs.oracle.com/javase/tutorial/figures/networking/6connect.gif&#34; alt=&#34;connection_established&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在客户端，如果连接请求被接受，会成功新建一个socket。客户端能利用这个socket来与服务器端通信。&lt;/p&gt;

&lt;p&gt;现在，客户端和服务器能通过向它们的sockets读/写数据来通信了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;定义&lt;br /&gt;
Socket是网络上运行着的两个程序所形成的双向通信连接的一端(endpoint)。每个socket都绑定了一个端口号，所以TCP层能确定数据接收方的程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;连接的一端&lt;/em&gt;(&lt;em&gt;endpoint&lt;/em&gt;)是一个IP地址和一个端口号的组合。每个TCP连接能被两个*连接的一端*唯一标志。这样，主机和服务器之间就能存在多个连接。&lt;/p&gt;

&lt;p&gt;Java平台上的java.net包提供了Socket这个类，它实现了Java程序和网络上另一个程序的双向连接的一边。Socket类位于依赖于平台的实现方式的顶端，向Java程序隐藏了所有系统的细节。通过使用java.net.Socket类而不是系统的原生代码，Java程序能一种独立于平台的实现方式与网络通信。&lt;/p&gt;

&lt;p&gt;另外，java.net包也包括了ServerSocket类，它实现的socket能被服务器用来监听、接受来自客户端的连接请求。&lt;/p&gt;

&lt;p&gt;如果你想连接Web，那么URL类和与之相关的类(URLConnection, URLEncoder)可能比Socket类更适合。事实上，URL类是连接Web相对更高层次的方式，它也用到sockets作为底层的部分实现。&lt;/p&gt;

&lt;p&gt;##原文链接
&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/networking/sockets/definition.html&#34;&gt;What Is a Socket?&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[转载]Android Intent原理分析</title>
      <link>https://blog.yuantops.com/tech/an-insight-of-android-intent/</link>
      <pubDate>Sun, 11 Jan 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/an-insight-of-android-intent/</guid>
      <description>&lt;p&gt;##原文链接
&lt;a href=&#34;http://blog.chinaunix.net/uid-741742-id-359319.html&#34;&gt;Android Intent原理分析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;##转载原文正文
Revision History&lt;/p&gt;

&lt;p&gt;wylhistory&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Abstract&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Introduction&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Intent的架构&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Intent的发送过程&lt;br /&gt;
4.1      Intent消息在发送进程的逻辑&lt;br /&gt;
4.2      Intent发送在服务器端的执行&lt;br /&gt;
4.2.1       进入消息队列之前&lt;br /&gt;
4.2.2       进入消息队列后的处理&lt;br /&gt;
4.2.3       消息的分发过程&lt;br /&gt;
4.2.4       deliverToRegisteredReceiver的逻辑&lt;br /&gt;
4.2.5       processCurBroadcastLocked的逻辑&lt;br /&gt;
4.2.6       startProcessLocked的逻辑&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Intent的接收过程&lt;br /&gt;
5.1      Receiver的注册&lt;br /&gt;
5.2      scheduleReceiver&lt;br /&gt;
5.3      scheduleRegisteredReceiver的逻辑&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;未分析&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Abstract&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;主要是分析一下android的IPC通讯之Intent；&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Introduction&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;任何一个操作系统，都有自己的IPC通讯机制，Android也不例外；&lt;br /&gt;
IPC通讯在linux下面通常包括共享内存，管道，消息队列等，这其中共享内存的效率比较高，我想；&lt;br /&gt;
这里将要说的Intent的通讯机制是基于Binder的，而Binder的机制本质上是共享内存；&lt;br /&gt;
Intent中文翻译为：n.意图，意向，目的 a.专心的；急切的；没有一个特别适合，所以我还是决定用英文；&lt;br /&gt;
它的作用，我想就是传达一些信息各特定的对象，或者广播一些信息各某些对象；这里涉及两方面的内容：&lt;br /&gt;
A） 消息的发送；&lt;br /&gt;
B） 消息的接收；&lt;/p&gt;

&lt;p&gt;后面就会具体的展开；&lt;/p&gt;

&lt;p&gt;讨论之前先看一个简单的例子：
Intent intent = new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);&lt;br /&gt;
mContext.sendBroadcast(intent);&lt;/p&gt;

&lt;p&gt;这是摘自HeadsetObserver.java的代码；&lt;br /&gt;
后面将会以此为例，分析发送和接收的过程；&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Intent的架构&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Intent的架构包括三方面：&lt;br /&gt;
Client，也就是发送这个Intent的activity；&lt;br /&gt;
Server，也就是activityManagerService.java,它主要是负责分发这些Intent给适当的对象；&lt;br /&gt;
Target，也就是那些需要处理这个Intent的activity，我们称为Receiver；&lt;/p&gt;

&lt;p&gt;需要大致的了解一下，Intent通常有哪些部分？我们常用的包括三方面：&lt;br /&gt;
A）    action，就是这个intent是想达到什么目的，比如是想打电话，还是想告诉我们电池电量低？&lt;br /&gt;
B）      数据，也就是这个intent要处理的是这些数据，如果你是receiver的话，你需要考虑，你是否需要处理这个intent，这里包括数据的URI，以及数据的类型；&lt;br /&gt;
C）      Category，这个就是需要处理这个Intent的activity的种类，这个种类是比较难以理解的，我想Google的本意是想区分一下不同的Activity的种类，比如对于CATEGORY_LAUNCHER，这个就表示它是一个启动器，有些消息只需要由特定类型的activity来处理；&lt;/p&gt;

&lt;p&gt;当然还有其它的一些属性，但是我们经常遇到的就是这三个，而这三个里面最常用的是Action；&lt;br /&gt;
这些项的作用，主要是被activityManagerService用来挑选适当的Activity来处理这个Intent；&lt;br /&gt;
好了，太多的概念，让人有点头晕，后面会再详细的讲；&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Intent的发送过程&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;4.1 Intent消息在发送进程的逻辑&lt;/p&gt;

&lt;p&gt;回到我们先前的那个例子：&lt;/p&gt;

&lt;p&gt;Intent intent = new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);&lt;br /&gt;
mContext.sendBroadcast(intent);&lt;/p&gt;

&lt;p&gt;第一句话是构造一个Intent，注意只传入了一个参数，这个参数就是一个Action，没有指定data以及Category；也就是说如果某个Receiver写成这样（在AndroidManifext.xml里面）：&lt;/p&gt;

&lt;p&gt;&lt;receiver android:name=&#34;MediaButtonIntentReceiver&#34;&gt;
          &lt;intent-filter&gt;
               &lt;action android:name=&#34;android.media.AUDIO_BECOMING_NOISY&#34; /&gt;
     &lt;/intent-filter&gt;&lt;br /&gt;
&lt;/receiver&gt;&lt;/p&gt;

&lt;p&gt;这个receiver的onReceive函数将会被调用，其中receiver表示处理这个Intent消息的类，而intent-filter表示这个receiver关心哪些Intent，这里写明了，我只关心，action == android.media.AUDIO_BECOMING_NOISY的Intent，如果是其它的Intent请别来烦我；&lt;/p&gt;

&lt;p&gt;第二句话的目的就是把这个消息广播出去，谁关心谁处理去，从此和我没关系了；&lt;br /&gt;
我可以很负责任的说，这个mContext的类型为ApplicationContext，在Android的代码里，这样命名的变量多半是这个类型，所以后面的逻辑就简单描述为：&lt;br /&gt;
Android的代码很多都这样，一层层的调用，很多时候都是二传手，这是模块化设计需要付出的代价，不过，值得；&lt;/p&gt;

&lt;p&gt;对于分析来说，需要理清楚这个调用到底去了什么地方？&lt;/p&gt;

&lt;p&gt;代码在ActivityManagerNative.java里面：&lt;br /&gt;
这是一个典型的Binder调用，从此以后代码的执行进入了另外一个进程；&lt;/p&gt;

&lt;p&gt;4.2  Intent发送在服务器端的执行&lt;br /&gt;
4.2.1 进入消息队列之前&lt;br /&gt;
这个图的逻辑是由ActivityManagerService.java来执行的，基本上也没什么意思；&lt;br /&gt;
重要的是最后调用的这个函数broadcastIntentLocked，基本上主要的工作都是由它来完成的；&lt;br /&gt;
这个函数非常重要，需要详细分析：&lt;br /&gt;
1，首先是进行一些权限检查，保证非串行的Intent其resultTo receiver必须是null;&lt;br /&gt;
2，如果这个Intent是说某个包被删除了或者改变了，那么当前的历史栈里面的属于这个包的activity就必须被关掉；&lt;br /&gt;
3，如果是时区改变的消息，那么将会先被放进队列里面通知当前正在运行的进程；&lt;br /&gt;
4，权限检查，判断是否有权限发送受保护的Intent，对于SYSTEM_UID，PHONE_UID，SHELL_UID，或者callingUid == 0的情况不做检查，也就是说默认这些调用者有这个发送的权限；&lt;br /&gt;
5，对于sticky类型的Intent做一些特殊处理（关于sticky类型等概念后面会讲），简单就是把这个Intent加入到mStickyBroadcasts链表中去；&lt;br /&gt;
6，判断这个Intent是有一个明确的对象，如果是那么直接把它的对象加入到receivers列表中去，如果不是，那么会继续判断是不是这个Intent在发送的时候设置了FLAG_RECEIVER_REGISTERED_ONLY标志，如果是，那么这个Intent将只发送给已经注册的Receiver，不会发送给Broadcast receiver,否则就发送给所有的那些满足条件的receivers；这里就涉及Intent的匹配原则，主要是通过函数queryIntent(Intent intent, String resolvedType, boolean defaultOnly)来匹配的，原则就是我前面说的，根据Action，data type，category等来匹配，记住，每条规则之间的关系是或的关系，比如：&lt;br /&gt;
&lt;receiver android:name=&#34;MediaButtonIntentReceiver&#34;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&#34;android.intent.action.MEDIA_BUTTON&#34; /&gt;
        &lt;action android:name=&#34;android.media.AUDIO_BECOMING_NOISY&#34; /&gt;
    &lt;/intent-filter&gt;
 &lt;/receiver&gt;&lt;/p&gt;

&lt;p&gt;就表示只要匹配到其中一条就算成功；另外，对于没有写明的匹配规则默认就算成功，比如对于此规则，没有写明数据类型，种类等，那么默认所有的数据类型都可以匹配上；&lt;/p&gt;

&lt;p&gt;7，如果是registeredReceivers不为空并且这个Intent不是串行的，也就是上一步已经取出了对应的接收者，那么就需要把这个Intent封装成一个BroadcastRecord，然后加入到mParallelBroadcasts，这个称为并行广播，也就是说可以同时发送给多个接收者，再通过scheduleBroadcastsLocked触发真正的发送；&lt;br /&gt;
8，过滤一种特殊情况，也就是对于ACTION_PACKAGE_ADDED消息，这个被安装的包本身不能作为这个消息的接收者；&lt;br /&gt;
9，然后对registeredReceivers和receivers做一个合并，如果这两个都不为空的话，记住，合并前这个receivers标识了“具有固定对象的接收者或者是当前已经注册的接收者不包括广播接收者”，而registeredReceivers表示broadcast Filter，另外这步能合并的前提是这个Intent是串行的Intent，否则是不会合并的；&lt;br /&gt;
10，  合并以后receivers表示所有的串行receivers通过mOrderedBroadcasts.add&amp;reg;加入到列表中去，再通过scheduleBroadcastsLocked触发真正的发送；&lt;/p&gt;

&lt;p&gt;OK，这个函数基本上就结束了，这里有三个概念需要解释，串行,并行，sticky的BroadCast；&lt;br /&gt;
串行：就表示这个Intent必须一个一个的发送给接收者；&lt;br /&gt;
并行：表示这个Intent可以同时发送给多个接收者，通常广播的消息都是并行的；&lt;br /&gt;
Sticky：这个类型的BroadCast比较难以理解，问了google也没有答案，我个人的理解是这样的，某些Intent需要被保留，当新的应用起来后，需要关注这个消息，但是呢，又不需要启动这个应用来接收此消息，比如耳机插入等消息，这里说实话，真的很巧妙，我们以前在maemo上碰到过这个问题，当时我们的策略是应用起来的时候自己查询耳机的状态，这里的处理明显就高明许多；&lt;/p&gt;

&lt;p&gt;总结一下这个函数：它的主要作用是根据这个Intent的特点，构造BroadCastRecord加入到不同的列表，等待被处理；&lt;/p&gt;

&lt;p&gt;OK，控制到了scheduleBroadcastsLocked这里，它的逻辑很简单：&lt;br /&gt;
private final void scheduleBroadcastsLocked() {
 if (mBroadcastsScheduled) {
return;
mHandler.sendEmptyMessage(BROADCAST_INTENT_MSG);
mBroadcastsScheduled = true;
先判断mBroadcastsScheduled是否为真，如果为真就直接返回,这个变量主要是实现scheduleBroadcastsLocked和processNextBroadcast之间的顺序执行，后面会看到在processNextBroadcast函数里面会把它设置为false；&lt;br /&gt;
下面就是通过BROADCAST_INTENT_MSG消息放入到消息队列里面，从这个角度来说Intent最后也是通过线程本身的消息队列来实现Intent的分发的；&lt;/p&gt;

&lt;p&gt;4.2.2 进入消息队列后的处理&lt;br /&gt;
上面有提到会通过mHandler.sendEmptyMessage(BROADCAST_INTENT_MSG)，把这个消息传递给mHandler，下面看看这个逻辑是如何实现的；&lt;br /&gt;
到这里消息就是按照时间顺序进入了mQueue了；&lt;br /&gt;
我们再看看一个activity的thread是如何进入主循环的：&lt;br /&gt;
首先是通过prepareMainLooper建立基本的数据结构，包括mQueue以及mThread,mMainLooper;&lt;br /&gt;
并把当前的这个Looper放入到线程独有的变量中；&lt;br /&gt;
其次是通过Looper.loop进入到主循环，逻辑如下：&lt;br /&gt;
首先是取出当前进入主循环的Looper，然后取出这个looper所拥有的mQueue，接下来就开始处理这个队列里面的消息了；&lt;br /&gt;
根据处理方式分两种消息，一种是消息的处理由一个线程来完成，一种是消息的处理时由一个函数来完成；&lt;br /&gt;
后者的话也分两种，一种是handler创建的时候提供了callback，这种情况非常少见；另外一种是通过handleMessage的方式来处理，通常我们在创建handler的时候都会提供这样一个函数，于是消息就可以被处理了；&lt;/p&gt;

&lt;p&gt;注意，最左边的分支我们还没有讨论，后面会遇到；&lt;/p&gt;

&lt;p&gt;我们先看看这个handleMessage对于BROADCAST_INTENT_MSG的处理：&lt;br /&gt;
这是最重要的函数，如果说broadcastIntentLocked是负责把Intent转化为BroadCast的话放入不同的队列，那么这个函数主要就是负责分发了，当然也涉及一点接收的流程；&lt;/p&gt;

&lt;p&gt;4.2.3 消息的分发过程&lt;/p&gt;

&lt;p&gt;下面分析函数private final void processNextBroadcast(boolean fromMsg)；&lt;br /&gt;
1，先判断fromMsg,如果是通过消息发送过来的就为真，否则为假，如果为真mBroadcastsScheduled = false，这样的话在函数scheduleBroadcastsLocked里面就可以再次发送BROADCAST_INTENT_MSG的消息从而触发processNextBroadcast函数被再次调用；&lt;br /&gt;
2，先判断mParallelBroadcasts是否为空，不为空就开始调用这个列表里面的receivers来接收消息，这个过程后面在串行intent的时候也会碰到，我们留到后面讨论，这里只需要知道它通过一个while循环把Intent发送给关注这个Intent的所有的receivers；&lt;br /&gt;
3，再判断mPendingBroadcast是否为空，如果不为空，就表示先前发送的串行的Intent还没有处理完毕，一般出现这种可能是因为我们要发送到的receiver还没有启动，所以需要先启动这个activity，然后等待起来的这个activity处理，这时候，这个mPendingBroadcast就为true；如果发送这种情况需要判断这个Activity是否死了，如果死了，那么就把mPendingBroadcast设为false，否则就直接返回，继续等待；&lt;br /&gt;
4，接下来就顺序的从mOrderedBroadcasts里面取出BroadCastRecord消息，然后对这个消息的receiver一个一个的调用其接收流程，注意这里要把这个BroadCast的所有的receivers串行发送，都发送完了，才会进入到下一个BroadCastRecord消息；对于这个消息的处理，先判断其接收者是不是BroadFilter，如果是，就调用deliverToRegisteredReceiver来接收，它的处理流程和前面的处理并行BroadCast一样，所以留到后面讲；&lt;br /&gt;
5，如果不是BroadCast Filter，就需要找出这个reiver所在的进程，这时候通常就是一个IntentFilter所在的进程，如果这个进程活着，那么就调用processCurBroadcastLocked(r, app)来处理，否则&lt;br /&gt;
6，需要先启动这个进程，这就是startProcessLocked做的事情，然后设置mPendingBroadcast = r，这样等应用起来它会处理这个消息，后面会有进一步的说明；&lt;/p&gt;

&lt;p&gt;到这里这个函数就结束了，比较复杂，里面还有一些安全的检查等等，上面遗留了三个问题：&lt;br /&gt;
A）deliverToRegisteredReceiver的处理流程；&lt;br /&gt;
B）processCurBroadcastLocked的处理流程；&lt;br /&gt;
C）startProcessLocked以后的进程如何处理这个唤醒它的Intent；&lt;/p&gt;

&lt;p&gt;4.2.4 deliverToRegisteredReceiver的逻辑&lt;br /&gt;
这里也分为这个receiver是否启动，如果已经启动就通过binder调用到了接收 activity的进程里面了，右边的分支performReceive也会调用到activityThread这边，留到接收过程再看；&lt;/p&gt;

&lt;p&gt;4.2.5 processCurBroadcastLocked的逻辑&lt;br /&gt;
可以看到它和deliverToRegisteredReceive的最终差别，只在于一个调用的是ScheduleRegisterdReceiver,一个是scheduleReceiver，这两个函数最后都会进入到目标activity的线程；&lt;/p&gt;

&lt;p&gt;4.2.6 startProcessLocked的逻辑&lt;br /&gt;
从这里可以看出最后通过Process.start启动了ActivityThread.java的进程，我们看看这个线程启动后的执行逻辑：&lt;br /&gt;
首先是在进入主循环之前调用attachApplication通过binder调用进入到activityManagerService.java的进程；&lt;br /&gt;
这个服务器进程在把我们先前设置的mPendingBroadcast设置为null，表示这个pending的broadcat已经得到处理了，然后调用processCurBroadcastLocked来处理这个broadcast消息，最后通过app.thread.scheduleReceiver进入到目标线程的接收流程；&lt;br /&gt;
OK,到这里的话所有的发送分发流程已经结束了，剩下的就是两个接收函数还没有讨论一个就是ScheduleRegisterdReceiver,一个是scheduleReceiver；&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Intent的接收过程&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;5.1  Receiver的注册&lt;/p&gt;

&lt;p&gt;Receiver的注册一般分为动态注册和静态注册，动态注册就是通过API registerReceiver来注册，静态的一般就是写在AndroidManifest.xml,比如我们在前面已经看到的：&lt;/p&gt;

&lt;p&gt;&lt;receiver android:name=&#34;MediaButtonIntentReceiver&#34;&gt;
&lt;intent-filter&gt;
&lt;action android:name=&#34;android.intent.action.MEDIA_BUTTON&#34; /&gt;
&lt;action android:name=&#34;android.media.AUDIO_BECOMING_NOISY&#34; /&gt;
&lt;/intent-filter&gt;
&lt;/receiver&gt;&lt;/p&gt;

&lt;p&gt;至于它的原理以后在分析packageManger的时候再分析；&lt;br /&gt;
下面重点来看看这个动态注册的逻辑：&lt;/p&gt;

&lt;p&gt;这两条路径都可能被走到，如果不在ApplicationContent环境里面就需要通过context.registerReceiver来注册了，经过几层传递会通过registerReceiverInternal进入主题；&lt;/p&gt;

&lt;p&gt;这个图看起来复杂，其实很简单，就是构造receiver放入到列表中去，只是中间又经历了Binder，这些receiver也就是我们先前在发送的过程中看到的那些receiver，当然它们能进入到broadcast的列表还要看发送的intent是否满足它们给自的filter；&lt;/p&gt;

&lt;p&gt;好，现在可以看看我们在发送阶段遗留的两个函数：&lt;/p&gt;

&lt;p&gt;scheduleReceiver&lt;br /&gt;
scheduleRegisteredReceiver；&lt;/p&gt;

&lt;p&gt;5.2  scheduleReceiver&lt;/p&gt;

&lt;p&gt;它的入口通常是Binder的分发函数，如下：&lt;/p&gt;

&lt;p&gt;右下方的这个函数scheduleReceiver才会真正调用到ActivityThread.java，这个就是目标activity的母体；&lt;/p&gt;

&lt;p&gt;前面两个就是封装参数，最后放入到消息队列中，等待主循环的处理，这段逻辑我们前面已经看到了，就不再细说，总之会调用到handlemessage函数；&lt;/p&gt;

&lt;p&gt;在收到这个消息的时候通过handleReceiver来处理；&lt;/p&gt;

&lt;p&gt;这又是一个非常重要的函数，需要详细分析：&lt;/p&gt;

&lt;p&gt;1，取得这个Intent指向的component，包括包名，类名；&lt;/p&gt;

&lt;p&gt;2，取得包信息，这个结构提供了getClassLoader接口；&lt;/p&gt;

&lt;p&gt;3，通过java.lang.ClassLoader cl = packageInfo.getClassLoader取得classLoader；&lt;/p&gt;

&lt;p&gt;4，动态创建一个receiver，receiver = (BroadcastReceiver)cl.loadClass(component).newInstance()；&lt;/p&gt;

&lt;p&gt;5，调用receiver.onReceive(context.getReceiverRestrictedContext(), data.intent)，进入到真正的处理流程中去了；&lt;/p&gt;

&lt;p&gt;6，调用finishReceiver来触发ActivityManagerService这个消息到其它receivers的发送或者下一个broadcast的发送；&lt;/p&gt;

&lt;p&gt;这其中最重要的就是这个onReceive函数，我们通常都会实现这么一个函数，然后在里面处理我们收到的消息；&lt;/p&gt;

&lt;p&gt;5.3             scheduleRegisteredReceiver的逻辑&lt;/p&gt;

&lt;p&gt;入口还是Binder得分发函数，如下：&lt;/p&gt;

&lt;p&gt;这种处理在Android的代码里面随处可见，都是在native文件里面通过onTransact分发调用service文件里面的同名函数来完成真正的功能；&lt;/p&gt;

&lt;p&gt;逻辑如下：&lt;/p&gt;

&lt;p&gt;也就是说，这里把参数打包放入到args里面去，然后通过post放入到消息队列里面等待处理，后面的逻辑和一个消息的发送很相似，如下：&lt;/p&gt;

&lt;p&gt;这里需要关注两个点，&lt;/p&gt;

&lt;p&gt;一个就是m.callback=r,这个赋值会导致后面在分发消息的时候走不同的路径；&lt;/p&gt;

&lt;p&gt;Msg.target=this,表示将来分发的时候谁来处理这个消息，如果设置为null将会导致主循环退出；&lt;/p&gt;

&lt;p&gt;分发的逻辑前面我们有介绍就是dispatchMessage的时候，我们再看看这段代码：&lt;/p&gt;

&lt;p&gt;public void dispatchMessage(Message msg) {&lt;/p&gt;

&lt;p&gt;if (msg.callback != null) {&lt;/p&gt;

&lt;p&gt;handleCallback(msg);&lt;/p&gt;

&lt;p&gt;} else {&lt;/p&gt;

&lt;p&gt;if (mCallback != null) {&lt;/p&gt;

&lt;p&gt;if (mCallback.handleMessage(msg)) {&lt;/p&gt;

&lt;p&gt;return;&lt;/p&gt;

&lt;p&gt;handleMessage(msg);&lt;/p&gt;

&lt;p&gt;这里就是需要先判断msg.callback是否为null，前面我们已经看到赋值了，所以这里不为null；&lt;/p&gt;

&lt;p&gt;于是调用handleCallback,如下：&lt;/p&gt;

&lt;p&gt;private final void handleCallback(Message message) {&lt;/p&gt;

&lt;p&gt;message.callback.run();&lt;/p&gt;

&lt;p&gt;这个callback我们也看到了其实就是我们封装的Args的args，原型为：&lt;/p&gt;

&lt;p&gt;class Args implements Runnable，&lt;/p&gt;

&lt;p&gt;也就是说它是一个类似线程的对象，它的run函数代码有点多，所以画了个图：&lt;/p&gt;

&lt;p&gt;基本上这个逻辑就和我们之前看到的逻辑一致了，会调用receiver提供的onReceive函数来处理，这个onReceive函数是需要我们自己提供的，里面一般的逻辑都是根据不同的消息做不同的处理；&lt;/p&gt;

&lt;p&gt;最后就是通过finishReceiver来触发ActivityManagerService对Intent的其它receivers的发送；&lt;/p&gt;

&lt;p&gt;需要总结一下，&lt;/p&gt;

&lt;p&gt;Intent从使用的角度来说，就是构造Intent，提供适当的参数，比如Action，比如数据类型，数据的uri等，然后发送出去；接收方需要注册一个receiver，然后提供onReceive函数就可以了；这个注册可以简单的写在AndroidManifest.xml里面也可以通过registerReceiver来完成；&lt;/p&gt;

&lt;p&gt;发送的时候有三个API可以用：&lt;/p&gt;

&lt;p&gt;sendBroadcast&lt;/p&gt;

&lt;p&gt;sendStickyBroadcast&lt;/p&gt;

&lt;p&gt;sendOrderedBroadcast&lt;/p&gt;

&lt;p&gt;第一个用于发送并行广播；&lt;/p&gt;

&lt;p&gt;第二个用于发送粘性广播；&lt;/p&gt;

&lt;p&gt;第三个用于发送串行广播；&lt;/p&gt;

&lt;p&gt;从原理的角度来说，本质上都是通过共享内存把信息传递给ActivityManagerService，它查询已经注册的那些receiver的过滤器，看是否和这个Intent匹配，如果匹配成功就加入到这个Intent的receiver列表中去，当然要根据这个Intent的参数决定加入到并行，串行，还是sticky的列表中，再通过Message传递，到主循环的下一轮来分发；这时候控制已经到了另外一个进程，然后分发好以后再调用目标线程的处理函数，所以基本上就是涉及三个进程，源——&amp;gt;server——&amp;gt;receiver；当然，源和目的可以是同一个进程；&lt;/p&gt;

&lt;p&gt;另外这里需要处理一种情况，就是这个消息发送的时候，目标线程还没有创建，比如我们系统里面的校准程序，需要在第一次开机的时候执行，那么就需要捕捉一个广播消息，比如：&lt;/p&gt;

&lt;p&gt;&lt;receiver android:name=&#34;StartupIntentReceiver&#34; &gt;&lt;/p&gt;

&lt;p&gt;&lt;intent-filter&gt;&lt;/p&gt;

&lt;p&gt;&lt;action android:name=&#34;android.intent.action.BOOT_COMPLETED&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;category android:name=&#34;android.intent.category.HOME&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/intent-filter&gt;&lt;/p&gt;

&lt;p&gt;&lt;/receiver&gt;&lt;/p&gt;

&lt;p&gt;这个消息的意思就是说启动已经完毕了；&lt;/p&gt;

&lt;p&gt;处理这个消息的类是StartupIntentReceiver,首先包含这个receiver的主activity将会被执行，然后再执行这个接收类的onReceive来接收消息并处理，所谓主activity是这样的：&lt;br /&gt;
    &amp;lt;activity android:name=&amp;ldquo;.CalibrationTest&amp;rdquo;&lt;/p&gt;

&lt;p&gt;android:label=&amp;ldquo;Calibration Test&amp;rdquo;&lt;/p&gt;

&lt;p&gt;android:theme=&amp;ldquo;@android:style/Theme.Black.NoTitleBar.Fullscreen&amp;rdquo;&lt;/p&gt;

&lt;p&gt;android:configChanges=&amp;ldquo;keyboard|keyboardHidden|navigation|orientation&amp;rdquo;&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;intent-filter&gt;&lt;/p&gt;

&lt;p&gt;&lt;action android:name=&#34;android.intent.action.MAIN&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;category android:name=&#34;android.intent.category.LAUNCHER&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/intent-filter&gt;&lt;/p&gt;

&lt;p&gt;&lt;/activity&gt;&lt;/p&gt;

&lt;p&gt;就是activity filter里面包含ACTION android.intent.action.MAIN,种类包含android.intent.category.LAUNCHER的activity；&lt;/p&gt;

&lt;p&gt;这个启动过程是由ActivityManagerService.java来完成的，我们不必关心；&lt;/p&gt;

&lt;p&gt;OK，基本上就这些了，关于Activity本身的原理，需要专门的文档来描述；&lt;br /&gt;
7. 未分析&lt;/p&gt;

&lt;p&gt;1，包管理器的信息来源；&lt;/p&gt;

&lt;p&gt;2，AndroidManifest.xml的解析；&lt;/p&gt;

&lt;p&gt;3，权限的检查；&lt;/p&gt;

&lt;p&gt;4,其它；&lt;/p&gt;

&lt;p&gt;作者：wylhistory&lt;/p&gt;

&lt;p&gt;联系方式：wylhistory@gmail.com&lt;/p&gt;

&lt;p&gt;##个人思考
当调用startIntent方法时，从这篇文章可以看出，其实是在消息队列中添加了一个消息。之后，这个消息会被分发、处理。如果是用Intent启动某个Activity，启动的过程会在调用方法的那个进程结束后才会开始。这是需要注意的，因为不是startActivity方法被调用后马上就会启动一个新的Activity。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTP Methods: GET vs. POST</title>
      <link>https://blog.yuantops.com/tech/difference-between-http-get-and-post/</link>
      <pubDate>Fri, 09 Jan 2015 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/difference-between-http-get-and-post/</guid>
      <description>&lt;p&gt;##HTTP是什么？&lt;br /&gt;
超文本传输协议(The Hypertext Transfer Protocol, HTTP)是为客户端(client)与服务器(server)之间的通信(communication)设计的。&lt;/p&gt;

&lt;p&gt;HTTP是在客户端与服务器之间以请求-响应(request-response)方式工作的协议。&lt;/p&gt;

&lt;p&gt;客户端可以是一个网页浏览器，服务器可以是一台提供web服务的主机上的某个应用程序。&lt;/p&gt;

&lt;p&gt;例如：一个客户端(浏览器)向服务器提交了HTTP请求；服务器接着向客户端返回响应。响应中包含了请求的状态信息，同时可能包含所请求的资源。&lt;/p&gt;

&lt;p&gt;##最常用的两种HTTP请求方式：GET和POST
- &lt;strong&gt;GET&lt;/strong&gt;: 向某个指定的资源申请数据&lt;br /&gt;
- &lt;strong&gt;POST&lt;/strong&gt;: 向某个指定的资源提交需要处理的数据&lt;/p&gt;

&lt;p&gt;##GET方式
&lt;strong&gt;注意，GET请求的查询字符串(name/value对)是包含在URL中发送的&lt;/strong&gt;&lt;br /&gt;

/test/demo_form.asp?name1=value1&amp;name2=value2
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于GET还需注意：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GET请求能被缓存&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;GET请求保存在浏览器的历史记录中&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;GET请求能被当作书签添加&lt;/li&gt;
&lt;li&gt;GET请求永远&lt;strong&gt;不应用在&lt;/strong&gt;处理敏感数据的场合&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;GET请求有长度限制&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;GET请求只应该用来获取数据&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##POST方式
&lt;strong&gt;注意，POST请求的查询字符串(name/value对)是包含在HTTP消息体中发送的&lt;/strong&gt;&lt;br /&gt;

POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&amp;name2=value2
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于POST还需注意：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;POST请求不能被缓存&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;POST请求不保存在浏览器的历史记录中&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;POST请求不能被添作标签&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;POST请求没有长度限制&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##GET与POST对比&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;GET&lt;/th&gt;
      &lt;th&gt;POST&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;返回/刷新按钮&lt;/td&gt;
      &lt;td&gt;无影响&lt;/td&gt;
      &lt;td&gt;数据会被再次提交(浏览器应该会警示用户这一点)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;书签&lt;/td&gt;
      &lt;td&gt;能被添作书签&lt;/td&gt;
      &lt;td&gt;不能被添作书签&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;缓存&lt;/td&gt;
      &lt;td&gt;能被缓存&lt;/td&gt;
      &lt;td&gt;不能缓存&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;编码方式&lt;/td&gt;
      &lt;td&gt;application/x-www-form-urlencoded&lt;/td&gt;
      &lt;td&gt;application/x-www-form-urlencoded或者multipart/form-data。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;历史记录&lt;/td&gt;
      &lt;td&gt;参数保存在浏览器记录中&lt;/td&gt;
      &lt;td&gt;参数不保存&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;数据长度限制&lt;/td&gt;
      &lt;td&gt;在传输数据时，GET方式会将数据添加到URL中，而URL的最大长度是2048个字符。&lt;/td&gt;
      &lt;td&gt;无限制&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;数据类型限制&lt;/td&gt;
      &lt;td&gt;只允许ASCII字符&lt;/td&gt;
      &lt;td&gt;无限制。二进制数据也是合法的。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;安全&lt;/td&gt;
      &lt;td&gt;与POST相比，更不安全，因为GET方式数据是URL的一部分。永远不要用GET来发送密码之类的敏感信息！&lt;/td&gt;
      &lt;td&gt;相对GET更安全一点，因为数据不会存储在浏览器历史记录或者服务器日志中。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可见性&lt;/td&gt;
      &lt;td&gt;每个人都能看见URL中的数据&lt;/td&gt;
      &lt;td&gt;数据不在URL中显示&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;##原文链接
&lt;a href=&#34;http://www.w3schools.com/tags/ref_httpmethods.asp&#34;&gt;HTTP Methods: GET vs. POST&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Buffered Streams -- Oracle Java Tutorial 翻译</title>
      <link>https://blog.yuantops.com/tech/oracle-java-tutorial-buffered-stream/</link>
      <pubDate>Wed, 31 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/oracle-java-tutorial-buffered-stream/</guid>
      <description>

&lt;h2 id=&#34;buffered-streams-缓冲流&#34;&gt;Buffered Streams 缓冲流&lt;/h2&gt;

&lt;p&gt;此前我们所见识的例子使用的大多*非缓冲I/O*。非缓冲，意味着每一次读/写的请求都由底层的OS直接处理。这降低了程序效率，因为每一次请求往往会触发磁盘操作、网络活动、或者其它代价昂贵的操作。&lt;/p&gt;

&lt;p&gt;为了减少这类消耗，Java平台实现了*缓冲I/O*流。输入缓冲流从一块别名为&amp;rdquo;缓存&amp;rdquo;(&lt;em&gt;buffer&lt;/em&gt;)的内存区域中读入数据;只有当缓存区变空的时候，原生的输入API才会被调用。类似地，缓冲的输出流向一块缓存中写数据，只有当缓存区满了的时候，原生的API的输出API才会被调用。&lt;/p&gt;

&lt;p&gt;程序能把一个非缓冲流转化为缓冲流。我们已经使用过几次这样的&amp;rdquo;包装类&amp;rdquo;了：非缓冲流作为参数传入缓冲流类的构造函数。下面就是一个例子，你可以在用它替代CopyCharacters代码中的构造函数以使用缓冲I/O：&lt;br /&gt;

inputStream = new BufferedReader(new FileReader(&#34;xanadu.txt&#34;));
outputStream = new BufferedWriter(new FileWriter(&#34;characteroutput.txt&#34;));
&lt;/p&gt;

&lt;p&gt;可以用来包裹非缓冲流的缓冲流类有4类：BufferedInputStream和BufferedOutputStream生成缓冲字节流, BufferedReader 和BufferedWriter 生成缓冲字符流。&lt;/p&gt;

&lt;h3 id=&#34;洗刷-flush-缓冲流&#34;&gt;洗刷(flush)缓冲流&lt;/h3&gt;

&lt;p&gt;在某些重要的时刻，我们等不及缓存填满就要将它的内容输出。这样的操作一般被称作*洗刷(flush)*缓存。&lt;/p&gt;

&lt;p&gt;一些缓冲输出流支持&amp;rdquo;自动洗刷(autoflush)&amp;ldquo;，只要你在它的构造函数中指定某个参数即可。当开启了自动洗刷后，某些关键事件会触发洗刷。例如，一个自动洗刷的PrintWriter对象，每当*println*或者*format*被调用时都会自动洗刷缓存。&lt;/p&gt;

&lt;p&gt;可以使用*flush*函数来手动洗刷缓存。可以对任何一个输出流使用*flush*函数，但只有在这个流被缓冲时才有效果。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：flush也可以翻译成“刷新”，但我觉得这样可能造成含混，所以还是将它翻作“洗刷”来得直白。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;原文链接&#34;&gt;原文链接&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/io/buffers.html&#34;&gt;Buffered Streams&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在GitHub pages中添加标签Tags(非插件方式)</title>
      <link>https://blog.yuantops.com/tech/add-tags-in-gh-pages/</link>
      <pubDate>Wed, 31 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/add-tags-in-gh-pages/</guid>
      <description>

&lt;h3 id=&#34;参考内容&#34;&gt;参考内容&lt;/h3&gt;

&lt;p&gt;本文参考了以下内容：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.lanyonm.org/articles/2013/11/21/alphabetize-jekyll-page-tags-pure-liquid.html&#34;&gt;Alphabetizing Jekyll Page Tags In Pure Liquid (Without Plugins)&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boylee.me/development/2014/11/20/Tips-For-Sorting-Tags-In-GitHub-Page-With-Jekyll/&#34;&gt;Tips For Sorting Tags In GitHub Page With Jekyll&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.minddust.com/post/tags-and-categories-on-github-pages/&#34;&gt;HOW TO USE TAGS AND CATEGORIES ON GITHUB PAGES WITHOUT PLUGINS&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;Jekyll引擎按照post/page文件-layout模板-HTML文件的逻辑处理、生成数据，因此添加Tags功能时也应遵循对应的顺序。&lt;br /&gt;
1. 在_posts目录下新建post文件时，在yaml头中加入tags变量。如果有多个tag，那么用中括号括起来、逗号分开。&lt;br /&gt;
2. 在_layouts目录下，post文件引用的模板文件中，加入解析单个post文件的tags的逻辑，并显示。&lt;br /&gt;
3. 在博客文件夹的根目录下新建一个tags.html文件，列出博客所有文章的tags，通过Html定位符确定每个tag的位置。将这个页面的链接摆放在首页或者其它合适的地方。&lt;/p&gt;

&lt;h3 id=&#34;步骤&#34;&gt;步骤&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Step 1&lt;/strong&gt;
在_layouts目录下的post.html文件中，在你想Tags出现的地方加入下面的代码：&lt;br /&gt;
    
	&lt;p class=&#34;entry-tags&#34;&gt; {% for tag in page.tags %}&lt;a href=&#34;{{ site.url }}/tags.html#{{ tag | cgi_    e    scape }}&#34; title=&#34;Pages tagged {{ tag }}&#34; rel=&#34;tag&#34; class=&#34;post-tag&#34;&gt;{{ tag }}&lt;/a&gt;{% unless forloop.last %}  {%     endunless %}{% endfor %}&lt;/p&gt;
	
&lt;strong&gt;Step 2&lt;/strong&gt;
在博客的根目录下新建tags.html文件，内容如下:&lt;br /&gt;
 ---
layout: page
title: Tags
description: &#34;An archive of posts sorted by tag.&#34;
--- 
 {%raw%} {% capture site_tags %}{% for tag in site.tags %}{{ tag | first }}{% unless forloop.last %},{% endunless %}{% endfor %}{% endcapture %}
&lt;!-- site_tags: {{ site_tags }} --&gt;
{% assign tag_words = site_tags | split:&#39;,&#39; | sort %}
&lt;!-- tag_words: {{ tag_words }} --&gt; {%endraw%}
&lt;div id=&#34;tags&#34;&gt;
  &lt;ul class=&#34;tag-box inline&#34;&gt;
{%raw%} {% for item in (0..site.tags.size) %}{% unless forloop.last %}
    {% capture this_word %}{{ tag_words[item] | strip_newlines }}{% endcapture %}
    &lt;li&gt;&lt;a href=&#34;#{{ this_word | cgi_escape }}&#34; class=&#34;tag-in-page&#34;&gt;{{ this_word }} &lt;span&gt;{{ site.tags[this_word].size }}&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
  {% endunless %}{% endfor %} {%endraw%}
  &lt;/ul&gt;
{%raw%} {% for item in (0..site.tags.size) %}{% unless forloop.last %}
    {% capture this_word %}{{ tag_words[item] | strip_newlines }}{% endcapture %}
  &lt;h2 id=&#34;{{ this_word | cgi_escape }}&#34;&gt;{{ this_word }}&lt;/h2&gt; {%endraw%}
  &lt;ul class=&#34;posts&#34;&gt;
{%raw%} {% for post in site.tags[this_word] %}{% if post.title != null %}
    &lt;li itemscope&gt;&lt;span class=&#34;entry-date&#34;&gt;&lt;time datetime=&#34;{{ post.date | date_to_xmlschema }}&#34; itemprop=&#34;datePublished&#34;&gt;{{ post.date | date: &#34;%B %d, %Y&#34; }}&lt;/time&gt;&lt;/span&gt; » &lt;a href=&#34;{{ post.url }}&#34;&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt;
    {% endif %}{% endfor %} {%endraw%}
  &lt;/ul&gt;
{% endunless %}{% endfor %}
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 3&lt;/strong&gt;
将tags.html的链接放到合适的地方：Header，Siderbar，Footer或者其他地方。&lt;br /&gt;
&lt;strong&gt;Step 4&lt;/strong&gt;
以后在写博客时，在post的yaml头部加入tags变量。&lt;/p&gt;

&lt;h3 id=&#34;显示效果美化&#34;&gt;显示效果美化&lt;/h3&gt;

&lt;p&gt;如果觉得Tags在post页面和tags.html的显示效果不够酷炫，可以自己在对应的css文件中加入/修改规则。&lt;/p&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;基于lanyon模板的博客：&lt;a href=&#34;https://github.com/LanyonM/lanyonm.github.io&#34;&gt;lanyonm.github.io GitHub Project&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;想定制Tags显示的排序规则，以及定制CSS效果：&lt;a href=&#34;http://boylee.me/development/2014/11/20/Tips-For-Sorting-Tags-In-GitHub-Page-With-Jekyll/&#34;&gt;Boyi Li webpage&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;本博客： &lt;a href=&#34;https://github.com/yuantops/blog&#34;&gt;Yuantops&amp;rsquo; Blog GitHub Project&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Jekyll安装指南</title>
      <link>https://blog.yuantops.com/tech/jekyll-installation/</link>
      <pubDate>Tue, 30 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/jekyll-installation/</guid>
      <description>

&lt;h3 id=&#34;环境准备&#34;&gt;环境准备&lt;/h3&gt;

&lt;p&gt;准备安装Jekyll前，确保系统满足以下条件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ruby&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;RubyGems&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Linux, Unix, 或者 Mac OS X&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Nodejs, 或者其它JavaScript运行环境&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以Ubuntu为例，安装上述软件的方法：&lt;br /&gt;
&lt;strong&gt;Ruby&lt;/strong&gt;&lt;br /&gt;

$ sudo apt-get install ruby, ruby-dev

要注意，*ruby-dev*包需要一并安装，否则在后续会报错。&lt;/p&gt;

&lt;p&gt;在Redhat/Fedora下，需要安装的软件包为ruby,ruby-devel。有可能还需要安装gcc包。&lt;br /&gt;

$ sudo yum install ruby, ruby-devel, gcc
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RubyGems&lt;/strong&gt;&lt;br /&gt;
RubyGems是Ruby程序包管理器，类似Redhat的RPM。更多的概念介绍，请参看&lt;a href=&#34;http://henter.me/post/ruby-rvm-gem-rake-bundle-rails.html&#34;&gt;整理Ruby相关的各种概念&lt;/a&gt;。&lt;br /&gt;
新版本的Ruby已经包含RubyGems，无需额外安装了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nodejs&lt;/strong&gt;&lt;br /&gt;

$ sudo apt-get install nodejs
&lt;/p&gt;

&lt;h3 id=&#34;设置gemfile&#34;&gt;设置Gemfile&lt;/h3&gt;

&lt;p&gt;将GitHub上你的博客Repo克隆到本地。假设Repo的根目录为blog。终端路径切换到blog目录，新建名为&lt;code&gt;Gemfile&lt;/code&gt;的文件，并填充内容:&lt;/p&gt;


source &#39;https://rubygems.org&#39;
gem &#39;github-pages&#39;


&lt;h3 id=&#34;使用rubygems安装jekyll&#34;&gt;使用RubyGems安装Jekyll&lt;/h3&gt;

&lt;p&gt;终端路径切换到blog，运行命令：

$ sudo gem install jekyll
&lt;/p&gt;

&lt;h3 id=&#34;运行jekyll-查看博客效果&#34;&gt;运行Jekyll，查看博客效果&lt;/h3&gt;

&lt;p&gt;终端路径切换到blog，运行命令：

$ jekyll serve
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Byte Streams -- Oracle Java Tutorial 翻译</title>
      <link>https://blog.yuantops.com/tech/oracle-java-tutorial-byte-stream/</link>
      <pubDate>Mon, 29 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/oracle-java-tutorial-byte-stream/</guid>
      <description>

&lt;h2 id=&#34;byte-streams-字节流&#34;&gt;Byte Streams 字节流&lt;/h2&gt;

&lt;p&gt;程序使用*字节流*来处理8bit字节的输入和输出。所有的字节流类都派生(descend)自InputStream和OutputStream。&lt;/p&gt;

&lt;p&gt;字节流类有很多。为了演示字节流的工作原理，我们将关注文件的I/O字节流,FileInputStream和FileOutputStream。其它字节流类的使用方法往往与之类似，仅在构造的方法上存在差别。&lt;/p&gt;

&lt;h3 id=&#34;使用字节流&#34;&gt;使用字节流&lt;/h3&gt;

&lt;p&gt;下面我们通过一段代码CopyBytes来演示FileInputStream和FileOutputStream的用法。这段代码通过字节流逐字节地拷贝xanadu.txt。&lt;/p&gt;


import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyBytes {
	   public static void main(String[] args) throws IOException {

        FileInputStream in = null;
        FileOutputStream out = null;

        try {
            in = new FileInputStream(&#34;xanadu.txt&#34;);
            out = new FileOutputStream(&#34;outagain.txt&#34;);
            int c;

            while ((c = in.read()) != -1) {
                out.write(c);
            }
        } finally {
            if (in != null) {
               in.close();
            }
            if (out != null) {
               out.close();
            }
        }
    }
}


&lt;p&gt;CopyBytes在运行时形成一个循环:它不断从输入流中逐字节地读入数据，然后将字节输出到输出流。如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://docs.oracle.com/javase/tutorial/figures/essential/byteStream.gif&#34; alt=&#34;图片链接&#34; title=&#34;Byte Stream&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;永远记得关闭流&#34;&gt;永远记得关闭流&lt;/h3&gt;

&lt;p&gt;关闭不再使用的流十分重要——以至于你可以看到在CopyBytes中，我们甚至使用finally区块来确保输入流和输出流即使在出现错误的情况下都能被关闭。关闭操作可以避免严重的资源泄露。&lt;/p&gt;

&lt;p&gt;可能出现的错误是CopyBytes无法打开一个或者多个文件。当这样的错误发生时，与这些文件相关的流变量不会改变它们最初的null值。这就是为什么在CopyBytes中，当我们最后调用close函数时要先确认每个流变量所持有的引用对象非空的原因。&lt;/p&gt;

&lt;h3 id=&#34;何时避免使用字节流&#34;&gt;何时避免使用字节流&lt;/h3&gt;

&lt;p&gt;CopyBytes看上去是一个很普通的程序，但它实际上是一种你应该避免使用的、低层次的I/O操作方式。因为xanadu.txt中包含了字符数据，所以最适当的方式是使用字符流(character stream)。我们将在下一部分讨论字符流。对于更复杂的数据类型，也有专门的流类来处理它们。字节流只应该用于最原始的I/O操作。&lt;/p&gt;

&lt;p&gt;那为何还要讨论字节流呢？因为所有其它的流类的&lt;strong&gt;基础&lt;/strong&gt;都是字节流。&lt;/p&gt;

&lt;h3 id=&#34;原文链接&#34;&gt;原文链接&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/io/bytestreams.html&#34;&gt;Byte Streams&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Character Streams -- Oracle Java Tutorial 翻译</title>
      <link>https://blog.yuantops.com/tech/oracle-java-tutorial-character-stream/</link>
      <pubDate>Mon, 29 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/oracle-java-tutorial-character-stream/</guid>
      <description>

&lt;h2 id=&#34;character-streams-字符流&#34;&gt;Character Streams 字符流&lt;/h2&gt;

&lt;p&gt;Java平台使用Unicode字符集存储字符值(character value)。字符流I/O自动将内部的Unicode格式翻译成本地的字符集，反之亦然。在西方的使用环境(locale)下，本地字符集往往是8bit的ASCII码的超集(superset)。&lt;/p&gt;

&lt;p&gt;对大多数程序来说，使用字符流的I/O不会比使用字节流的I/O更复杂。与输入和输出相关的流类会自动完成与本地字符集的翻译过程。一个使用字符流而不是字节流的程序，它会自动使用本地字符集，而且它可以完成国际化的过程——不需要程序员付出过多的额外工作。&lt;/p&gt;

&lt;p&gt;如果国际化的需求优先级不高，你尽管以最简单的方式使用字符流类，而不需太关注字符集的问题。如果之后有了国际化的需求，你的程序也可以轻松地予以修改。参见&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/i18n/index.html&#34;&gt;国际化的章节&lt;/a&gt;了解更多。&lt;/p&gt;

&lt;h3 id=&#34;使用字符流&#34;&gt;使用字符流&lt;/h3&gt;

&lt;p&gt;所有的字符流类都派生自Reader和Writer。与字节流一样，有专为文件I/O而设的字符流类：FileReader和FileWriter。下面的CopyCharacters代码演示了它们的使用方法。&lt;/p&gt;


import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class CopyCharacters {
    public static void main(String[] args) throws IOException {

    FileReader inputStream = null;
    FileWriter outputStream = null;

    try {
        inputStream = new FileReader(&#34;xanadu.txt&#34;);
        outputStream = new FileWriter(&#34;characteroutput.txt&#34;);
        int c;
        while ((c = inputStream.read()) != -1) {
            outputStream.write(c);
        }
    } finally {
        if (inputStream != null) {
           inputStream.close();
        }
        if (outputStream != null) {
           outputStream.close();
        }
   }
  }
}


&lt;p&gt;CopyCharacters和CopyBytes很相似。它们之间最大的不同在于CopyCharacters使用FileReader和FileWriter来完成输入和输出，CopyBytes使用FileInputStream和FileOutputStream。值得注意的是，CopyCharacters和CopyBytes都使用了一个int变量来暂存读入/写出的值。在CopyCharacters中这个int变量在它的后16bit中暂存一个字符值(character value),然而在CopyBytes中这个int变量在它的后8bit中暂存一个字节值(byte value)。&lt;/p&gt;

&lt;h3 id=&#34;使用字节流的字符流&#34;&gt;使用字节流的字符流&lt;/h3&gt;

&lt;p&gt;字符流往往是字节流的&amp;rdquo;包装&amp;rdquo;(wrapper)。字符流利用字节流完成物理I/O操作，同时字符流完成字符和字节之间的翻译。举例来说，FileReader使用FileInputStream，FileWriter使用FileOutputStream。&lt;/p&gt;

&lt;p&gt;起到字节-字符之间“桥梁”(bridge)作用的通用类有两个：InputStreamReader和OutputStreamWriter。在没有已经封装好的字符流包能满足你的操作需求时，你可以用它们创建字符流。&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/networking/sockets/readingWriting.html&#34;&gt;socket lesson&lt;/a&gt;和&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/networking/index.html&#34;&gt;network trial&lt;/a&gt;中会介绍如何从socket相关类提供的字节流中创建字符流。&lt;/p&gt;

&lt;h3 id=&#34;行导向的i-o&#34;&gt;行导向的I/O&lt;/h3&gt;

&lt;p&gt;字符I/O操作的往往不是单个字符，而是更大的单元。最常见的单元是行：以行终止符结尾的一个字符串。行终止符可以是回车(carrige-return)/新行(line-feed)的字符组合(&amp;rdquo;\r\n&amp;rdquo;)，可以是单个的回车符号(&amp;rdquo;\r&amp;rdquo;)，也可以是单个的新行符号(&amp;rdquo;\n&amp;rdquo;)。兼容所有可能存在的行终止符，这样会使程序能读取在任何流行的操作系统上创建的文本。&lt;/p&gt;

&lt;p&gt;让我们对CopyCharacters稍作修改，使其变为基于行的I/O。我们会使用之前没使用的两个类：BufferedReader和PrintWriter。我们将在&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/io/buffers.html&#34;&gt;Buffered I/O&lt;/a&gt;和&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/io/formatting.html&#34;&gt;FormaFormattingtting&lt;/a&gt;这两个章节中详细讨论这两个类。&lt;/p&gt;

&lt;p&gt;下文的CopyLines程序会调用BufferedReader.readLine和PrintWriter.println来完成每次输入/输出一行的操作。&lt;/p&gt;


import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.IOException;

public class CopyLines {
    public static void main(String[] args) throws IOException {

        BufferedReader inputStream = null;
        PrintWriter outputStream = null;

        try {
			inputStream = new BufferedReader(new FileReader(&#34;xanadu.txt&#34;));
			outputStream = new PrintWriter(new FileWriter(&#34;characteroutput.txt&#34;));
			String l;
			while ((l = inputStream.readLine()) != null) {
				outputStream.println(l);
			}
		} finally {
			if (inputStream != null) {
			inputStream.close();
		}
		if (outputStream != null) {
			outputStream.close();
		}
		}
	}
}


&lt;p&gt;调用readLine会返回文本中的一行。CopyLines使用println输出每一行，println函数会在每一行末尾添上当前操作系统的行终止符，再打印出来。这样的话，最后打印出来的行所使用的行终止符不一定与输入文件中的行终止符相同。&lt;/p&gt;

&lt;h3 id=&#34;原文链接&#34;&gt;原文链接&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/io/charstreams.html&#34;&gt;Character Streams&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OSC Android源码学习笔记 四 listview初始化、获取数据、加载数据的流程</title>
      <link>https://blog.yuantops.com/tech/osc-android-app-notes-4/</link>
      <pubDate>Sat, 27 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/osc-android-app-notes-4/</guid>
      <description>&lt;p&gt;OSC App显示的信息分为资讯(news)，博客(blog)，问答(Question)，动弹(tweet)几屏，每屏对应一个ListView。以资讯(news)为例，粗略看一下它的ListView是如何初始化、获取数据、加载数据的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;实例化一个ListViewNewsApapter并添加到lvNews：&lt;br /&gt;

lvNewsAdapter = new ListViewNewsAdapter(this, lvNewsData, R.layout.news_listitem);

ListViewNewsApapter这个类继承BaseAdapter，重写了getView()方法。值得注意的是，getView()方法中news实体被被作为Tag添加到了listView的ItemView中。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为lvNews设置lvNewsAdapter。lvNews和lvNewsAdapter都是Main这个类持有的变量，而不是某个函数的局部变量。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;为lvNews设置OnClickListener，这个Listener以匿名内部类方式初始化：
当点击单个item view时，从view中取出news这个Tag，然后使用UIHelper.showNewsRedirect()方法跳转到新闻阅读详情页。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实例化一个lvNewsHandler：&lt;br /&gt;

lvNewsHandler = this.getLvHandler(lvNews, lvNewsAdapter, lvNews_foot_more, lvNews_foot_progress, AppContext.PAGE_SIZE);
&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个Handler定义了当接收到有数据更新的通知时，应该作何处理。主要是通知adapter数据发生了变化：&lt;br /&gt;

adapter.notifyDataSetChanged();
&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;下载数据，加载数据：&lt;br /&gt;

loadLvNewsData(curNewsCatalog, 0, lvNewsHandler, UIHelper.LISTVIEW_ACTION_INIT);

新开进程，调用appContext.getNewList()从服务器获取数据。数据获取完成后，通过传入的lvNewsHandler发送Message，回调handleMessage(Message msg)方法。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>开源中国安卓客户端源码学习笔记 三 自定义Exception类</title>
      <link>https://blog.yuantops.com/tech/osc-android-app-notes-3/</link>
      <pubDate>Thu, 25 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/osc-android-app-notes-3/</guid>
      <description>&lt;p&gt;net.oschina.app包中包含四个类的定义文件，它们分别是AppConfig, AppException, AppManager, AppStart。其中AppStart类继承Activity，是跳转界面。AppException类是Exception的子类，是自定义的异常类。&lt;/p&gt;

&lt;p&gt;AppException类中有8个final static类型的类变量，定义异常类型: network, socket, http, xml, io, run, jason几种。这个类中有对应的静态方法，以Exception为形参，返回对应的新建对象。值得注意的是，代码中预留了debug的选项，如果在新建AppException对象时传入“debug”参数，那么对应的Exception信息会被写到文件中保存。&lt;/p&gt;

&lt;p&gt;这个类中定义了异常的处理方式：收集错误信息，然后显示异常信息&amp;amp;发送错误报告。显示异常信息和发送错误报告的过程在新建的Thread里完成。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用OpenSSL工具制作证书的方法</title>
      <link>https://blog.yuantops.com/tech/ssl-creation-guide/</link>
      <pubDate>Wed, 24 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/ssl-creation-guide/</guid>
      <description>

&lt;div class=&#34;message&#34;&gt;
&lt;/div&gt;

&lt;p&gt;之前&lt;a href=&#34;http://blog.yuantops.com/tech/SSL-certificate-details-and-creation-guide/&#34;&gt;一篇文章&lt;/a&gt;介绍了SSL证书的一些细节，这篇文章介绍OpenSSL工具的基本使用方法。老实说，OpenSSL工具实在是太难用了，我参考了&lt;a href=&#34;http://pages.cs.wisc.edu/~zmiller/ca-howto/&#34;&gt;How To Setup a CA&lt;/a&gt;和&lt;a href=&#34;http://rhythm-zju.blog.163.com/blog/static/310042008015115718637/&#34;&gt;基于 OpenSSL 的 CA 建立及证书签发&lt;/a&gt;这两篇文章，捣鼓了很久才理清流程。虽然原理很清楚，但是操作起来却不那么容易，这告诉我们要多实践才对，不然发现不了问题。&lt;/p&gt;

&lt;h3 id=&#34;一些坑&#34;&gt;一些坑&lt;/h3&gt;

&lt;p&gt;在使用openssl ca命令时，如果不手动指定-config参数，它会自动调用/etc/pki/tls/openssl.cnf作为-config配置文件，这个openssl.cnf文件里定义了要调用的CA证书、私钥路径。如果我们在创建CA时将它的证书和私钥等文件保存在了别处，或者/etc/pki/tls/openssl.cnf里的定义的那些文件不存在，那么在openssl ca找不到要使用的这些文件时，就会报错。其中典型的错误有：&lt;/p&gt;


Using configuration from /etc/pki/tls/openssl.cnf
unable to load CA private key
139911890630472:error:0906D06C:PEM routines:PEM_read_bio:no start line:pem_lib.c:703:Expecting: ANY PRIVATE KEY  


&lt;p&gt;所以，我们如果想自定义CA的目录位置，那么要事先1）按照OpenSSL的默认配置建立相应的目录结构，2）定制openssl.cnf文件，修改CA目录的路径定义。&lt;/p&gt;

&lt;h3 id=&#34;建立ca-生成root证书&#34;&gt;建立CA，生成Root证书&lt;/h3&gt;

&lt;h4 id=&#34;生成ca目录结构&#34;&gt;生成CA目录结构&lt;/h4&gt;

&lt;p&gt;假设我要将/root/newCA作为CA文件根目录，那么在Terminal中敲入命令：&lt;br /&gt;

[root@node ~]# pwd
/root
[root@node ~]# mkdir -p ./newCA/{private,newcerts}
[root@node ~]# touch ./newCA/index.txt
[root@node ~]# echo 01 &gt; ./newCA/serial
&lt;/p&gt;

&lt;h4 id=&#34;定制openssl-cnf文件&#34;&gt;定制openssl.cnf文件&lt;/h4&gt;

&lt;p&gt;将/etc/pki/tls/openssl.cnf文件复制到newCA目录下，将CA_default下面的dir的值更新为自定义的openssl.cnf文件的路径(在本文中为/root/newCA)。&lt;/p&gt;

&lt;p&gt;除此之外，出于方便后续设置的目的，还可以修改openssl.cnf文件中[req_distinguished_name]区域内后缀为default的变量，将它们预设合适的值。下面是我修改后的样子：&lt;br /&gt;
&amp;gt;       [ req_distinguished_name ]
        countryName                     = Country Name (2 letter code)
        countryName_default             = CN
        countryName_min                 = 2
        countryName_max                 = 2&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  stateOrProvinceName             = State or Province Name (full name)
    stateOrProvinceName_default     = Beijing

  localityName                    = Locality Name (eg, city)
    localityName_default            = HaiDian

  0.organizationName              = Organization Name (eg, company)
    0.organizationName_default      = Yuantops&#39; Company Ltd

  # we can do this but it is not needed normally :-)
    #1.organizationName             = Second Organization Name (eg, company)
    #1.organizationName_default     = World Wide Web Pty Ltd

  organizationalUnitName          = Organizational Unit Name (eg, section)
    organizationalUnitName_default  = Head Office

  commonName                      = Common Name (eg, your name or your server\&#39;s hostname)
    commonName_max                  = 64

  emailAddress                    = Email Address
    emailAddress_max                = 64   
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;生成ca的root-key和self-signed的证书&#34;&gt;生成CA的root key和self-signed的证书&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;生成密钥对&lt;br /&gt;
 # openssl genrsa -out private/cakey.pem 2048&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;生成证书申请、用CA的密钥自签名，用一条语句完成&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;


[root@node newCA]# openssl req -new -x509 -days 3650 -key private/cakey.pem -out cacert.pem -config openssl.cnf
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
	If you enter &#39;.&#39;, the field will be left blank.
	-----
	Country Name (2 letter code) [CN]:
	State or Province Name (full name) [Beijing]:
	Locality Name (eg, city) [HaiDian]:
	Organization Name (eg, company) [Yuantops Company Ltd]:
	Organizational Unit Name (eg, section) [Head Office]:
	Common Name (eg, your name or your server&#39;s hostname) []:test.yuantops.com
	Email Address []:


&lt;ul&gt;
&lt;li&gt;查看我们生成的root-ca.crt的内容&lt;br /&gt;
 # openssl x509 -noout -text -in root-ca.crt&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;使用ca-root证书签署证书&#34;&gt;使用CA Root证书签署证书&lt;/h4&gt;

&lt;p&gt;在上一步完成之后，就可以用CA的root 证书来签署证书了。&lt;/p&gt;

&lt;p&gt;可以使用一条OpenSSL命令完成生成密钥对，生成证书签名请求的操作：&lt;br /&gt;
     # openssl req -newkey rsa:1024 -keyout zmiller.key -config openssl.cnf -out zmiller.req&lt;/p&gt;

&lt;p&gt;然后用CA的Root证书签发证书&lt;br /&gt;
     # openssl ca -config openssl.cnf -out zmiller.crt -infiles zmiller.req&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>BIND安装笔记</title>
      <link>https://blog.yuantops.com/tech/bind-installation-guide/</link>
      <pubDate>Tue, 23 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/bind-installation-guide/</guid>
      <description>

&lt;h3 id=&#34;安装环境&#34;&gt;安装环境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;网络环境：两台KVM虚拟机，通过NAT方式组成子网(IP地址分别为192.168.100.139, 192.168.100.172)，彼此能ping通，均能访问互联网&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;系统：Redhat 6.6&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;要解析的域名：yuantops.com&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;安装bind软件包&#34;&gt;安装BIND软件包&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;$ yum install bind bind-utils&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;为要解析的域名生成dnssec-key&#34;&gt;为要解析的域名生成DNSSEC KEY&lt;/h3&gt;

&lt;p&gt;这一步不是配置基本DNS解析器时必须包括的步骤，因此可以省略。&lt;/p&gt;

&lt;p&gt;DNSSEC是为了解决DNS欺骗和缓存污染而设计的一种安全机制。由于DNS域名解析系统在设计之初没有考虑到安全问题，经常有针对DNS系统的攻击发生，而且由于DNS协议十分脆弱，攻击一旦发生就会造成大面积的影响甚至瘫痪。DNSSEC的原理是通过引入加密技术，依靠数字签名保证DNS应答报文的真实性和完整性。具体的介绍请见&lt;a href=&#34;http://netsec.ccert.edu.cn/duanhx/archives/1479&#34;&gt;DNSSEC的原理、配置与部署简介&lt;/a&gt;一文。&lt;/p&gt;

&lt;p&gt;假设我要解析的域名为yuantops.com，准备将这个域名对应的DNSSEC KEY文件保存在/var/named/路径下。&lt;br /&gt;
&amp;gt; $ cd /var/named&lt;br /&gt;
&amp;gt; $ dnssec-keygen -a HMAC-SHA256 -b 256 -n USER -r /dev/urandom yuantops.com&lt;/p&gt;

&lt;p&gt;在/var/named/路径下生成了文件名形如Kyuantops.com.+163+15844.key和Kyuantops.com.+163+15844.private的一对key文件。&lt;/p&gt;

&lt;h3 id=&#34;启用rndc工具作为bind的控制工具&#34;&gt;启用rndc工具作为BIND的控制工具&lt;/h3&gt;

&lt;p&gt;这一步同样不是配置一个最基本的DNS解析服务器所必须包含的步骤，因此可以省略。&lt;/p&gt;

&lt;p&gt;rndc是BIND安装包提供的一种域名服务控制工具，它可以运行在其他计算机上，通过网络与DNS服务器进行连接，然后根据管理员的指令对named服务进行远程控制，此时，管理员不需要DNS服务器的根用户权限。更重要一点，rndc能实现数据的&lt;strong&gt;热更新&lt;/strong&gt;，这对繁忙的实际场景而言是十分有必要的。具体的介绍可以请见&lt;a href=&#34;http://book.51cto.com/art/200912/169294.htm&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;使用rndc-confgen命令生成rndc的配置文件。&lt;br /&gt;
&amp;gt; $ rndc-confgen -a -r /dev/urandom&lt;/p&gt;

&lt;p&gt;在/etc路径下生成了rndc.key文件。&lt;/p&gt;

&lt;h3 id=&#34;配置bind对域名的解析&#34;&gt;配置BIND对域名的解析&lt;/h3&gt;

&lt;p&gt;这一步是必须完成的、最重要的步骤。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;新建yuantops.com域的zone文件，保存到/var/named/dynamic目录。&lt;br /&gt;
域的zone文件有自己的语法规范，配置起来需要事先对DNS的术语有一定了解。可以参看&lt;a href=&#34;http://www.zytrax.com/books/dns/ch8/soa.html&#34;&gt;文章一&lt;/a&gt;和 &lt;a href=&#34;http://www.zytrax.com/books/dns/ch6/mydomain.html&#34;&gt;文章二&lt;/a&gt;。&lt;br /&gt;
下面是域yuantops.com的zone文件yuantops.com.db的内容:&lt;br /&gt;
&amp;gt;$TTL   86400 ; 24 hours could have been written as 24h or 1d&lt;br /&gt;
; $TTL used for all RRs without explicit TTL value&lt;br /&gt;
$ORIGIN yuantops.com.&lt;br /&gt;
@  1D  IN  SOA ns1.yuantops.com. hostmaster.yuantops.com. (&lt;br /&gt;
                                  2002022401 ; serial&lt;br /&gt;
                                  3H ; refresh&lt;br /&gt;
                                  15 ; retry&lt;br /&gt;
                                  1w ; expire&lt;br /&gt;
                                  3h ; minimum    )&lt;br /&gt;
       IN  NS     ns1.yuantops.com. ; in the domain&lt;br /&gt;
              IN  MX  10 mail.yuantops.com. ;&lt;br /&gt;
              ; server host definitions&lt;br /&gt;
              ns1    IN  A      192.168.100.172;name server definition&lt;br /&gt;
              www    IN  A      192.168.100.172;web server definition&lt;br /&gt;
              ftp    IN  CNAME  www.yuantops.com.  ;ftp server definition&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将yuantops.com域的DNSSEC Key添加到/var/named/目录。&lt;br /&gt;
在生成DNSSEC Key的第一步中，我们得到了一对key文件。如果因为不准备部署DNSSEC key而跳过了第一步，那么现在这一步也应该跳过。&lt;br /&gt;
打开/var/named/Kyuantops.com.+163+15844.private文件，复制其中的Key字段到剪贴板。&lt;br /&gt;
新建/var/named/yuantops.com.key文件，将以下内容填入文件:&lt;br /&gt;
&amp;gt;key yuantops.com {&lt;br /&gt;
            algorithm HMAC-SHA256;&lt;br /&gt;
            secret &amp;ldquo;2viM+VhhgiFGMrOjLAqBtY9usGstiRuZdOElI5U6l/o=&amp;rdquo;;&lt;br /&gt;
};&lt;/p&gt;

&lt;p&gt;替代secret字段为剪贴板中的内容。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置BIND的配置文件/etc/named.conf，添加yuantops.com域的定义、DNSSEC Key定义。&lt;br /&gt;
named.conf文件是BIND服务器的全局配置文件，非常重要。我们要在里面加入对yuantops.com域的定义、yuantops.com域的DNSSEC Key的定义。&lt;br /&gt;
将以下内容填入/etc/named.conf文件:&lt;br /&gt;
&amp;gt;options {&lt;br /&gt;
                listen-on port 53 { any; };//注意，此处为any，不是127.0.0.1&lt;br /&gt;
                listen-on-v6 port 53 { ::1; };&lt;br /&gt;
                directory       &amp;ldquo;/var/named&amp;rdquo;;&lt;br /&gt;
                dump-file       &amp;ldquo;/var/named/data/cache_dump.db&amp;rdquo;;&lt;br /&gt;
                statistics-file &amp;ldquo;/var/named/data/named_stats.txt&amp;rdquo;;&lt;br /&gt;
                memstatistics-file &amp;ldquo;/var/named/data/named_mem_stats.txt&amp;rdquo;;&lt;br /&gt;
                allow-query     { any; }; //注意，此处是any，不是localhost&lt;br /&gt;
                recursion yes;&lt;br /&gt;
                dnssec-enable yes;&lt;br /&gt;
                dnssec-validation yes;&lt;br /&gt;
                dnssec-lookaside auto;&lt;br /&gt;
                /* Path to ISC DLV key */&lt;br /&gt;
                bindkeys-file &amp;ldquo;/etc/named.iscdlv.key&amp;rdquo;;&lt;br /&gt;
                managed-keys-directory &amp;ldquo;/var/named/dynamic&amp;rdquo;;&lt;br /&gt;
};&lt;br /&gt;
logging {&lt;br /&gt;
            channel default_debug {&lt;br /&gt;
            file &amp;ldquo;data/named.run&amp;rdquo;;&lt;br /&gt;
            severity dynamic;&lt;br /&gt;
        };&lt;br /&gt;
};&lt;br /&gt;
    // use the default rndc key&lt;br /&gt;
    include &amp;ldquo;/etc/rndc.key&amp;rdquo;;&lt;br /&gt;
    controls {&lt;br /&gt;
        inet 127.0.0.1 port 953&lt;br /&gt;
        allow { 127.0.0.1; } keys { &amp;ldquo;rndc-key&amp;rdquo;; };&lt;br /&gt;
    };&lt;br /&gt;
    zone &amp;ldquo;.&amp;rdquo; IN {&lt;br /&gt;
          type hint;&lt;br /&gt;
          file &amp;ldquo;named.ca&amp;rdquo;;&lt;br /&gt;
    }//;&lt;br /&gt;
&amp;gt;       include &amp;ldquo;/etc/named.rfc1912.zones&amp;rdquo;;&lt;br /&gt;
&amp;gt;       include &amp;ldquo;/etc/named.root.key&amp;rdquo;;&lt;br /&gt;
    include &amp;ldquo;yuantops.com.key&amp;rdquo;;&lt;br /&gt;
    zone &amp;ldquo;yuantops.com&amp;rdquo; IN {&lt;br /&gt;
      type master;&lt;br /&gt;
      file &amp;ldquo;dynamic/yuantops.com.db&amp;rdquo;;&lt;br /&gt;
      allow-update { key yuantops.com ; } ;&lt;br /&gt;
    };&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;修改配置文件的权限-使能被读取&#34;&gt;修改配置文件的权限，使能被读取&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;$ chmod 644 /etc/named.conf&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;启动bind服务器&#34;&gt;启动BIND服务器&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;$ service named start&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果以后BIND服务器设置有改动，需要重启named服务。&lt;/p&gt;

&lt;h3 id=&#34;将机器的dns服务器ip地址设为bind程序所在机器的ip地址&#34;&gt;将机器的DNS服务器IP地址设为BIND程序所在机器的IP地址&lt;/h3&gt;

&lt;p&gt;BIND服务器所在机器的IP地址为192.168.100.172。如果有一台192.168.100.139的机器想以192.168.100.172为DNS服务器，那么修改它的/etc/resolv.conf文件，将第一次出现的nameserver 地址改为192.168.100.172。&lt;/p&gt;

&lt;h3 id=&#34;验证bind服务已经成功安装并启动&#34;&gt;验证BIND服务已经成功安装并启动&lt;/h3&gt;

&lt;p&gt;在192.168.100.139机器上运行命令：&lt;br /&gt;
&amp;gt;$ dig @192.168.100.172 www.yuantops.com&lt;/p&gt;

&lt;p&gt;如果成功解析出IP地址，证明成功。否则，可以检查BIND服务器的/var/log/message日志文件，寻找原因。&lt;/p&gt;

&lt;h3 id=&#34;使用nsupdate命令操作bind服务器的配置&#34;&gt;使用nsupdate命令操作BIND服务器的配置&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>开源中国安卓客户端源码学习笔记 二 欢迎界面跳转与渐变效果</title>
      <link>https://blog.yuantops.com/tech/osc-android-app-notes-2/</link>
      <pubDate>Tue, 23 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/osc-android-app-notes-2/</guid>
      <description>&lt;p&gt;OSC客户端启动时会先显示欢迎界面，再跳转到主页，其中跳转过程有渐变效果。&lt;/p&gt;

&lt;p&gt;这里使用了AlphaAnimation类。AlphaAnimation类能实现渐进渐出的效果，官方文档里说“This animation ends up changing the alpha property of a Transformation”。alpha property可以理解为透明度，&amp;rdquo;0.0&amp;rdquo;为全透明，“0.5”为半透明，“1.0”时不透明。&lt;/p&gt;



	//渐变展示启动屏
	AlphaAnimation aa = new AlphaAnimation(0.3f,1.0f);
	aa.setDuration(3000);
	view.startAnimation(aa);
	aa.setAnimationListener(new AnimationListener()
	{
		@Override
		public void onAnimationEnd(Animation arg0) {
			redirectTo();
		}
		@Override
		public void onAnimationRepeat(Animation animation) {}
		@Override
		public void onAnimationStart(Animation animation) {}
	});



&lt;p&gt;另外，欢迎界面的图片可以更新。从代码分析，在将View设置为ContentView之前，程序会检查欢迎界面对应缓存文件夹里的图片文件，图片文件的文件名有一个时间期限，如果今天正好落在这个期限内，那么就将它设为背景图片。如此可以推测APP会在启动后自动下载新的图片文件(如果存在的话)到缓存文件夹，从而达到更新效果。&lt;/p&gt;

&lt;p&gt;果然，在跳转到Main Activity后，在onCreate()方法里调用了checkBackGround()方法。这个方法会新开一个Thread去服务器检查是否有新的图片需要下载，如果有，那么会下载下来。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>开源中国安卓客户端源码学习笔记 一</title>
      <link>https://blog.yuantops.com/tech/osc-android-app-notes-1/</link>
      <pubDate>Mon, 22 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/osc-android-app-notes-1/</guid>
      <description>&lt;p&gt;##前言
开源中国(OSCHINA)是国内一个开源社区,社区自己开发了Android和iOS平台的客户端，而且将各自的代码开源了。值得夸奖的是，他们的Android APP不是基于HTML，而是Android原生API。我最近在学习它Android App的&lt;a href=&#34;http://git.oschina.net/oschina/android-app&#34;&gt;源代码&lt;/a&gt;，毕竟像它这样性能优秀、注释齐全的开源项目是比较稀少的。&lt;/p&gt;

&lt;p&gt;希望能通过阅读源代码，学到一些Android开发的实战技巧，并加深对已有知识的理解。&lt;/p&gt;

&lt;p&gt;##学习笔记一 利用getApplication()共享全局数据&lt;br /&gt;
程序启动Activity是net.oschina.app.AppStart。这个Activity类持有一个自定义的AppContext成员。查看net.oschina.app.AppContext类的定义，作者说它是“全局应用程序类，用于保存和调用全局应用配置及访问网络数据”。&lt;/p&gt;

&lt;p&gt;AppContext类是Application类的子类。Google了getApplication()函数，找到了一篇介绍得比较明白的文章：&lt;br /&gt;
- &lt;a href=&#34;http://www.cnblogs.com/liu666bin/archive/2013/01/05/2846081.html&#34;&gt;android利用getApplication()共享全局数据&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在平时开发中，如果需要一些能被所有Activity和View访问到的全局数据，就可以自定义一个继承Application类的子类，扩展它所持有的成员。&lt;strong&gt;值得注意&lt;/strong&gt;，还需在android Manifest.xml文件中将application的android:name属性指定为自定义的类。&lt;/p&gt;

&lt;p&gt;另外,关于getApplication()和getApplicationContext()的区别,&lt;a href=&#34;http://stackoverflow.com/questions/5018545/getapplication-vs-getapplicationcontext&#34;&gt;stackoverflow&lt;/a&gt;上有人这么解释:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;虽然当前Anroid Activity和Service的实现方式使得getApplication()和getApplicationContext()返回相同的object，但不能保证它们将来会一直这样。  

如果你想在Manifest.xml文件中注册Application class，那么**永远不要**调用getApplicationContext()并将其cast为你的application类，因为它返回的很可能不是你的application实例。  

getApplication()仅仅在Activity和Service类中可以被调用，而getApplicationContext()则是在Context类中被声明的。这意味着，譬如说你写了一个Broadcast Receiver，Broadcast Receiver本身不是一个Context类，尽管它能通过onReceive()方式获得一个Context类的引用，这时你就只能调用getApplicationContext()了——这也就意味着，不能确保在BroadcastReceiver中访问到application。  

另外，Android的官方文档中提到，你**不应该**需要去继承Application类:  

There is normally no need to subclass Application. In most situation, static singletons can provide the same functionality in a more modular way. If your singleton needs a global context (for example to register broadcast receivers), the function to retrieve it can be given a  Context which internally uses Context.getApplicationContext() when first constructing the singleton.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然官方推荐用静态singleton的方式去设置全局数据，但是在回复中有人提到，在实际中还是继承Application的方式来得更方便。所以，到底用那种方式更好，就见仁见智吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>制作属于自己的字母favicon</title>
      <link>https://blog.yuantops.com/tech/make-custom-character-favicon/</link>
      <pubDate>Sat, 20 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/make-custom-character-favicon/</guid>
      <description>&lt;p&gt;每个自己搭建博客的人，应该都想自己的博客更具个性。favicon是浏览器浏览网页时标签左边的那个小图标，是可以自己设计的。&lt;/p&gt;

&lt;p&gt;这里，推荐一个网站：&lt;a href=&#34;http://faviconist.com/&#34;&gt;faviconist.com&lt;/a&gt;。你可以输入一个字母，得到这个字母的图标，而且字体、文字前景色、背景色都可以调整。调整到满意后，下载到本地，保存到对应的网页文件夹，就可以了。&lt;/p&gt;

&lt;p&gt;效果可以参见我的网页。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java 的一些术语解释</title>
      <link>https://blog.yuantops.com/tech/java-terminology-explanation/</link>
      <pubDate>Sun, 14 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/java-terminology-explanation/</guid>
      <description>

&lt;p&gt;作为JAVA初学者，往往弄不清楚一系列术语的概念。这篇文章搬运&lt;a href=&#34;http://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre&#34;&gt;文章一&lt;/a&gt;与&lt;a href=&#34;http://stackoverflow.com/questions/10858193/java-jdk-sdk-se&#34;&gt;文章二&lt;/a&gt;，解释JRE与JDK, JavaSE、JavaME与JavaEE，Java版本等术语 。&lt;/p&gt;

&lt;h3 id=&#34;jre-vs-jdk&#34;&gt;JRE vs JDK&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;JRE&lt;/strong&gt;: Java Runtime Environment&lt;br /&gt;
基本说来它是Java Virtual Machine，你的Java程序在它上面运行。它也为浏览器提供Applet运行插件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JDK&lt;/strong&gt;: Java Development Kit&lt;br /&gt;
Java软件开发包，它不仅&lt;strong&gt;包括&lt;/strong&gt; JRE,还包括编译器等其它工具(JavaDoc, Java Debugger等)。它用来创建、编译程序。&lt;/p&gt;

&lt;p&gt;一般说来，如果你仅仅想让Java程序在自己的电脑和浏览器上跑起来，那么只需安装JRE。如果你想用Java编程，那么需要安装JDK。&lt;/p&gt;

&lt;h3 id=&#34;javase-javame和javaee&#34;&gt;JavaSE，JavaME和JavaEE&lt;/h3&gt;

&lt;p&gt;因为围绕Java形成的生态圈十分庞大，所以Sun公司提供了Java的不同发行版。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JavaSE&lt;/strong&gt;: Java Standard Edition&lt;br /&gt;
适合于客户端软件、常规程序等。我们平时所使用的、所下载的Java版本一般都是它。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JavaME&lt;/strong&gt;: Java Mobile Edition&lt;br /&gt;
通常是老式手机游戏所产生的平台，它对Java进行了精简，使其更适合低性能的处理器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JavaEE&lt;/strong&gt;: Java Enterprise Edition&lt;br /&gt;
通常用来研发服务器端的产品，因此往往它包含很多服务器需要用到的包。&lt;/p&gt;

&lt;h3 id=&#34;java的版本号&#34;&gt;Java的版本号&lt;/h3&gt;

&lt;p&gt;我们在下载安装Java JRE或者JDK后，使用&amp;rdquo;java -version&amp;rdquo;命令查看当前的Java版本，会发现类似下面的信息：&lt;br /&gt;

java version &#34;1.7.0_71&#34;

Java 1.7是我机器上的java版本号，它也被称为Java 7：它们是一个东西，两个名称。再累赘一点地说，它也是JavaSE 7。&lt;/p&gt;

&lt;h3 id=&#34;扩展阅读&#34;&gt;扩展阅读&lt;/h3&gt;

&lt;p&gt;更详细、更权威的资料，可以阅读Oracle的&lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/tech/index.html&#34;&gt;Java SE Technologies文档&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SSL术语与基本原理</title>
      <link>https://blog.yuantops.com/tech/ssl-terminologies-and-concepts/</link>
      <pubDate>Sat, 06 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/ssl-terminologies-and-concepts/</guid>
      <description>

&lt;p&gt;非对称加密的又一大应用是SSL。对于SSL的介绍，阮一峰有一篇深入浅出的博客，推荐阅读：&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html&#34;&gt;数字签名是什么？&lt;/a&gt;。这篇文章也非常不错：&lt;a href=&#34;http://httpd.apache.org/docs/current/ssl/ssl_intro.html&#34;&gt;SSL/TLS Strong Ebcryption: An introduction&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;SSL协议对互联网的安全十分重要。要理解SSL协议，必须先理解几个基本概念：&lt;strong&gt;信息摘要(message digest)&lt;/strong&gt;，&lt;strong&gt;数字签名(digital signature)&lt;/strong&gt;，&lt;strong&gt;数字证书(digital certificate)&lt;/strong&gt;。阮一峰的博客里写得十分清楚了，看完后做一点自己的笔记。&lt;/p&gt;

&lt;h3 id=&#34;ssl术语&#34;&gt;SSL术语&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;公钥(public key): 非对称加密密钥对中可以分发给其它人的一方。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;私钥(private key): 非对称加密密钥对中自己保存的一方。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;信息摘要(message digest): 对一段很长的数据消息，计算它的Hash函数值，得到的一串*较短*且*定长*的短数值。Hash函数可以是MD5或者SHA 1。Hash函数过程是单向不可逆的，不可能通过message digest 反推出原数据信息。同时，message digest也是独一无二的。可以理解为某一段数据内容独一无二的特征值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数字签名(digital signature): 使用用户私钥对信息摘要(message digest)进行加密，生成的信息。数字签名只能用用户的公钥解开。反过来，如果用户Alice的公钥成功解密了数字签名，那么一定能确定这个签名的签发者是用户Alice(因为只可能是Alice的私钥签发了它)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数字证书(digital certificate): 由某个被信任的机构(如Certificate Authority，CA)签发、认证用户身份的数字文件。(数字证书的内容复杂，将在另外一篇博客中专门介绍)。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ssl基本原理&#34;&gt;SSL基本原理&lt;/h3&gt;

&lt;p&gt;这里介绍的是SSL的设计思想和大致原理，不是实现细节。转述自从阮一峰的博客。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;假设用户Alice有属于自己的公钥/私钥对。她准备和好朋友Bob，Susan等通信。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Alice把自己的公钥送给朋友们：Bob，Susan每人一把。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Bob如果要给Alice写一封保密的信，那么他写完后用Alice的公钥加密，就可以达到保密的效果。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Alice收到信后，用自己私钥解密，就看到了信件内容。这里要强调的是，只要Alice的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;试思考：如果Alice事先没有把自己公钥送给自己的朋友们，她自己手中也没有朋友们的公钥，那他们之间通信如何保证不被篡改？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;假设Alice要给Bob写信。她写好信(message)后，先使用Hash函数生成信息摘要(message digest)。然后，她使用私钥，对这个摘要加密，生成数字签名(digital signature)。最后，她把自己的信件内容、数字签名，还有自己的公钥一起发送给Bob。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bob收到了信件。他取出Alice的公钥、数字签名，用公钥解密数字签名，得到信息摘要;他再读出信件内容，用Hash函数自己计算内容的信息摘要。如果取出来的摘要和算出来的摘要吻合，那么这封信就未被修改过。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可是，万一黑客John截获了Alice发给Bob的信件，然后自己编造了一些内容，生成摘要、用自己密钥加密生成数字签名，再连同自己的公钥一起发给Bob，他就可以冒充Alice了。Bob如何确定取出的公钥就是Alice的，而不是别人(例如，黑客John)的？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bob无法确定公钥是不是属于Alice，于是想到一个办法：他建议Alice去找权威机构(例如，certificate authority，简称CA)给她的公钥做认证，做个证书(certificate)。Alice领取了一份申请表格，填入自己的姓名、住址、联系方式、和自己的公钥，跑到CA去提交。CA接受申请，确认是Alice本人无误，就用自己的私钥处理Alice的表格内容，生成数字签名并附在申请表格后面，这就成了“数字证书”(digital ceritificate)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;以后Alice给Bob写信，就会发送信件内容+数字签名+数字证书三部分。Bob收到来信，先检查数字证书的真伪。如果为真，那么从数字证书中取出Alice的公钥。这时可以确认得到的是Alice的真实公钥。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;数字证书的现实应用-https中的ssl协议&#34;&gt;数字证书的现实应用：https中的SSL协议&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;首先，客户端向服务器发出加密请求。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;服务器用自己的私钥加密网页，连同本身的数字证书，一起发送给客户端。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;客户端打开自己的“证书管理器”，看证书是否由“受信任的根证书颁发机构”颁发。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果证书合法，而且确实颁发给你所浏览的网址的，那么客户端就可以取出真实的公钥。否则客户端会提出警告。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;思考-ssl协议的实现流程-与ssl-certificate的实现细节&#34;&gt;思考：SSL协议的实现流程，与SSL certificate的实现细节&lt;/h3&gt;

&lt;p&gt;这篇文章为了解释SSL协议的原理，引入并介绍了“摘要”“数字签名”“数字证书”等概念。这篇文章主要介绍原理，而且用了比喻，可能在细节上有出入，这是需要注意的。在实际的互联网环境中，SSL协议的实现更为复杂精细。&lt;/p&gt;

&lt;p&gt;但就谈到的点而言，可能还存在这样的疑问：&lt;br /&gt;
&amp;gt; 客户端(浏览器)如何确认一份数字证书的真伪？&lt;/p&gt;

&lt;p&gt;这个问题值得思考。为了确认公钥是真实的，我们引入了“数字证书”为它担保——问题只不过换了一种问法，但信任锚点还是没能确认。在下一篇文章中，会讨论数字证书的细节，并介绍如何确认一份“数字证书”的真伪。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SSL证书的细节与制作方法</title>
      <link>https://blog.yuantops.com/tech/ssl-certificate-details-and-creation-guide/</link>
      <pubDate>Sat, 06 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/ssl-certificate-details-and-creation-guide/</guid>
      <description>

&lt;p&gt;在上篇文章中，讨论了数字证书(digital certificate)的重要意义。在实际中，Internt工程任务组(IETF)PKI X.509专门负责制定数字证书的格式，并提出了一套标准。根据这套标准(X.509)，互联网上的各级单位各自予以实现，从而形成一套完备的公钥基础设施(Public Key Infrastructure, PKI)。这是本篇文章将要讨论的内容。&lt;/p&gt;

&lt;h3 id=&#34;ssl证书的x-509标准&#34;&gt;SSL证书的X.509标准&lt;/h3&gt;

&lt;p&gt;X.509 规定一份digital certificate应该由这几部分构成：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Certificate Data&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Version (marked as X.509 v3, even if v4 or v5)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Serial number&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Signature algorithm ID&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Issuer name(DN, Distinguished Name)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Validity (start and end time)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Subject name(DN)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Subject Public key&lt;/li&gt;
&lt;li&gt;Extensions (added in X.509 v3): Extra identification information, usage constraints, policies, and general kitchen-sink area&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Certificate Signature Algorithm&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Certificate Signature&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;注:
- 一般Subject Name, 或者Issuer name + Serial number唯一确定一份证书;&lt;br /&gt;
- Certificate Data中的Signature algorithm ID必须和Certificate Signature Algorithm中的内容一致，标志CA用来生成Certificate Signature所用的加密算法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在Certificate Data的Subject name与Issuer name这两项中，其Distinguished Name包含更多字段(这些字段往往用字母简写)，以更好地作唯一标识：&lt;br /&gt;
- CN: Common Name, 证书持有者的名称&lt;br /&gt;
- O: Organization or Company, 持有者所在的公司/组织&lt;br /&gt;
- OU: Organization Unit, 持有者在公司/组织的部门&lt;br /&gt;
- L: City/Locality, 持有者所在的城市&lt;br /&gt;
- ST: State/Province, 持有者所在的州/省&lt;br /&gt;
- C: Country, 持有者所在的国家(ISO码)&lt;/p&gt;

&lt;h3 id=&#34;ssl-x-509证书的后缀名&#34;&gt;SSL X.509证书的后缀名&lt;/h3&gt;

&lt;p&gt;一份X.509 Certificate往往会以DER(Distinguished Encoding Rules)方式翻译成二进制格式的文件。如果有些传输过程不能处理二进制数据，那么二进制格式的文件会以Base64 编码转翻为ASCII文件。用Base64 编码后的数据被置于“&amp;mdash;&amp;ndash;BEGIN CERTIFICATE&amp;mdash;&amp;ndash;”和“&amp;mdash;&amp;ndash;END CERTIFICATE&amp;mdash;&amp;ndash;”之间，这就是PEM(Privacy-enhanced Electronic Mail)格式。&lt;/p&gt;

&lt;p&gt;不同格式的证书常见的后缀名有:&lt;br /&gt;
- cer, .crt, .der : 二进制DER格式&lt;br /&gt;
- pem: Base64 编码后的DER格式&lt;/p&gt;

&lt;h3 id=&#34;x-509的-证书链-与-信任锚点&#34;&gt;X.509的“证书链”与“信任锚点”&lt;/h3&gt;

&lt;p&gt;数字证书存在的意义，在于认证持有者的身份。譬如说，在Alice申请证书的时候，证书颁发机构(CA, Certificate Authority)会先确认Alice本人的信息与她申请书上所写的一致。&lt;/p&gt;

&lt;p&gt;由于证书上有第三方认证中心的真实性确认签名、由第三方认证中心的信用为这张证书的真实性背书，所以，只要确定了证书为真，就能确认证书持有者的身份为真。但这样问题还是没得到解决，而是变成了另一个问题：如何确定一张证书的真伪？&lt;/p&gt;

&lt;p&gt;为了回答这个问题，需要先了解实际部署在互联网上的证书颁发机构(CA, Certificate Authority)的架构。互联网中，一个证书颁发机构(CA, Certificate Authority)有自己的证书。一个证书颁发机构(CA, Certificate Authority)不仅可以给证书申请者颁发证书，也可以给其它证书颁发机构(CA, Certificate Authority)颁发证书。那么谁来给最顶层的证书颁发机构(top-level Certificate Authority)授权呢？答案是：它自己给自己签名，自己给自己授权(它拥有的证书，Issuer和Subject是一样的)。&lt;/p&gt;

&lt;p&gt;这样就形成了一个“证书链”(Certificate chain),也称“证书路径”(Certificate path)：最开始为用户持有的证书，最末尾为自己给自己签名的证书。证书链中:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每个证书(最末尾的证书除外)的颁发者(Issuer)是下一个证书的持有者(Subject);&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;每个证书的(最末尾的证书除外)的Certificate Signature都能用下一个证书中包含的Public Key解密;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;最末尾的证书是“信任锚点”(a trust anchor)——往往它会以某种值得信赖的方式，提前传递到你手中。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，确认一张证书真实性的过程，就是一个不断追溯，直到“信任锚点”的过程。&lt;/p&gt;

&lt;p&gt;在主流的浏览器(IE, Chrome, Firefox等)中，预置了主流证书颁发机构(VeriSign等)的根证书。当浏览器收到网站的SSL证书后，会有一系列验证过程，如果该证书的“证书链”中任意一环存储在本地，那么就能确认该证书为真实。浏览器对证书链的认证过程，将在另一篇文章中介绍。&lt;/p&gt;

&lt;h3 id=&#34;生成根证书与签发证书&#34;&gt;生成根证书与签发证书&lt;/h3&gt;

&lt;p&gt;上面讲了那么多，都是理论。现在转入实战，介绍如何生成一张证书, 以及这张证书的持有者如何为申请者签发证书。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Linux下最常使用的SSL根证书相关的命令是openssl的一套工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般情况下，用户制作证书要经过几个步骤：&lt;br /&gt;
1. 首先用openssl genrsa生成一个私钥&lt;br /&gt;
2. 然后用openssl req生产一个证书签发请求&lt;br /&gt;
3. 最后把证书签发请求交给CA，CA签发后就得到该CA认证的证书。&lt;/p&gt;

&lt;p&gt;如果生成证书签发请求时加上-X509参数，那么就直接生成一个self-signed的证书，即自己充当CA认证自己。&lt;/p&gt;

&lt;p&gt;一张self-signed的证书，不能证明持有者的身份。大部分软件在遇到这种证书时都会发出警告。使用自签发证书的主要意义也不是证明身份，而是使用户与系统间能SSL通信，保证信息传输时的安全。&lt;/p&gt;

&lt;p&gt;使用openssl工具制作证书时，会接触到新名词:&lt;br /&gt;
- CSR(Certificate Signing Request): 提交给CA的认证申请文件，包含了申请者的公钥和名字等信息，通常以.csr为后缀，是中间文件。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;制作自签名证书(根证书)步骤(参考&lt;a href=&#34;http://rhythm-zju.blog.163.com/blog/static/310042008015115718637/&#34;&gt;内容&lt;/a&gt;)：&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;生成一个RSA私钥private.key&lt;br /&gt;
&amp;gt; $ openssl genrsa -des3  -out private.key 1024&lt;/p&gt;

&lt;p&gt;参数解释：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;genrsa: 用于生成RSA密钥对的OpenSSL命令&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;des3: 使用 3-DES 对称加密算法加密密钥对，该参数需要用户在密钥生成过程中输入一个口令用于加密。今后使用该密钥对时，需要输入相应的口令。如果不加该选项，则不对密钥进行加密。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;out: 将生成的密钥保存到文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2014:  RSA模数位数，在一定程度上表征密钥强度。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;生成一个CA证书认证申请&lt;br /&gt;
&amp;gt;$ openssl req -new -days 365 -key private.key -out req.csr&lt;/p&gt;

&lt;p&gt;参数解释：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;req: 用于生成证书认证申请的openSSL命令&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;-new： 生成一个新的证书认证请求。加上这个参数后，会提示用户输入申请者的信息&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;-days 365: 证书的有效期：从生成之日起365天&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;-out req.csr: 证书申请保存的目的文件。为中间文件，可以在证书生成以后删除。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该命令会提示用户输入密钥的口令(如果上一步中没有加des3参数则不会)，以及一系列证书申请者的相关信息。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对CA证书申请进行签名&lt;br /&gt;
&amp;gt; $ openssl ca -selfsign -in req.csr -out ca.pem&lt;/p&gt;

&lt;p&gt;参数解释：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ca: 用于CA相关操作的命令&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;-selfsign: 自签名(用与证书中包含公钥所对应的密钥签名)&lt;/li&gt;
&lt;li&gt;-in req.csr: 证书认证申请文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;-out ca.pem: 证书保存到目的文件&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注：以上两个步骤可以合二为一。利用ca的-x509参数可以生成自签名的证书，将申请和签发两步一起完成：&lt;br /&gt;
&amp;gt; $ openssl req -new -x509 -days 365 -key private.key -out ca.pem&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;利用生成的根证书签发证书&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这一部分请参看&lt;a href=&#34;http://blog.yuantops.com/tech/SSL-creation-guide&#34;&gt;文章&lt;/a&gt;，因为下面的步骤可能有些问题。&lt;/p&gt;

&lt;p&gt;利用生成的根证书签发证书的过程，1，2步与上一部分相同，只是在第3部分，签名的时候有差异:&lt;br /&gt;
&amp;gt; $ openssl ca -in req.csr -cert ca.pem -out userca.pem -keyfile private.key&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  参数解释：  
  - ca: 用于CA相关操作的命令  
  - -in req.csr: 证书认证申请文件  
  - -cert ca.pem: 用于签发的CA证书  
  - -out userca.pem:  处理完成后输出的证书文件
  - -keyfile private.key: CA的私钥文件  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;一些思考与体会&#34;&gt;一些思考与体会&lt;/h3&gt;

&lt;p&gt;因为openssl工具十分强大，每个人的使用方法都不同，所以在参考别人的使用方法时会有很多疑惑。下面是一些思考与体会：(参考&lt;a href=&#34;http://www.cnblogs.com/littlehann/p/3738141.html&#34;&gt;这篇博客&lt;/a&gt;)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在生成过程中有很多文件扩展名(.crt、.csr、.pem、.key等等)，从本质上讲，扩展名并不具有任何强制约束作用，重要的是这个文件是由哪个命令生成的，它的内容是什么格式的。 使用这些特定的文件扩展名只是为了遵循某些约定俗称的规范，让人能一目了然。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;openssl的指令之间具有一些功能上的重叠，所以我们会发现完成同样一个目的(例如SSL证书生成)，往往可以使用看似不同的指令组达到目的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;释疑:openssl genrsa -des3 -out private.key 1024 命令生成的private.key真正包含了什么？&lt;br /&gt;
&amp;gt; 注意到, 在生成证书认证申请时($ openssl req -new -days 365 -key private.key -out req.csr)，参数只用了申请者的private.key，而理论上应该提供申请者的public.key。而且根据RSA加密的数学原理，不可能由private key推出public key。所以这往往会带来疑惑: public key从哪儿来？&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参考&lt;a href=&#34;http://stackoverflow.com/questions/5244129/use-rsa-private-key-to-generate-public-key&#34;&gt;这个回答&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;实际上，第一步( $ openssl genrsa -des3  -out private.key 1024 )命令生成的是public-private 的公钥/私钥对,这一对公钥/私钥都保存在private.key文件中。所以，准确说来这一行命令的作用是：生成用户的&lt;strong&gt;公钥/私钥对&lt;/strong&gt;，而不是生成用户的私钥。(虽然一般我们都按后者的方式说)。因此，答案就是：public key本身就包含在private.key中。&lt;/p&gt;

&lt;p&gt;另外，可以使用openssl命令，从private.key中提取出public.key&lt;br /&gt;
&amp;gt; $ openssl rsa -in private.key -pubout -out public.key&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SSH登录原理</title>
      <link>https://blog.yuantops.com/tech/ssh-login-procedure/</link>
      <pubDate>Fri, 05 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/ssh-login-procedure/</guid>
      <description>

&lt;p&gt;关于SSH登录的原理，阮一峰的这篇博客写得很清楚，值得一看。&lt;br /&gt;
&amp;gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html&#34;&gt;SSH原理与运用(一)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;读完这篇博客后，下面是笔记和摘抄。&lt;/p&gt;

&lt;h3 id=&#34;ssh密码登录的流程&#34;&gt;SSH密码登录的流程&lt;/h3&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;远程主机收到用户的登录请求，把自己的公钥发给用户。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用户使用这个公钥，将登录密码加密后，发送回来&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;如何防范-中间人-攻击&#34;&gt;如何防范&amp;rdquo;中间人&amp;rdquo;攻击&lt;/h3&gt;

&lt;p&gt;如果有人拦截了远程主机发给用户的公钥，然后将自己的公钥发送给用户，可能会造成远程主机密码泄漏(著名的“中间人攻击”)。用户要识别公钥的真伪，没有更好的办法，只有比较收到的公钥的fingerprint（公钥的MD5值）是不是与服务器公布在网站上的fingerprint相同。&lt;/p&gt;

&lt;p&gt;在用户初次SSH登录一台远程主机时，终端往往会显示远程主机的fingerprint和一条Warning，询问是否确定远程主机的身份并继续。当用户选择确认后，远程主机的公钥会记录到本地系统的known_hosts文件中。下次再登录时，系统如果发现远程主机的公钥记录在案，就不再发出Warning。&lt;/p&gt;

&lt;h3 id=&#34;ssh公钥登录的流程&#34;&gt;SSH公钥登录的流程&lt;/h3&gt;

&lt;p&gt;以密码方式SSH登录远程主机，每次都需要输入密码，这样既麻烦，又存在密码泄露的潜在危险。公钥登录可以解决这两个问题。(有的高安全规格的服务器甚至不允许用户以SSH密码登录，只允许以SSH公钥方式登录。)&lt;/p&gt;

&lt;p&gt;公钥登录的流程：&lt;br /&gt;
1. 用户将自己的公钥存储在远程主机上。&lt;br /&gt;
2. 登录时，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。&lt;br /&gt;
3. 远程主机用实现存储的公钥解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。&lt;/p&gt;

&lt;h3 id=&#34;linux下生成公钥-私钥对的命令&#34;&gt;Linux下生成公钥/私钥对的命令&lt;/h3&gt;

&lt;p&gt;在用SSH公钥登录时，第一步需要用户提供自己的公钥。Linux，特别是服务器环境下，经常会有用到公钥/私钥对的场景，生成它们的命令也十分基础。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;生成公钥/私钥对&lt;br /&gt;
&amp;gt;$ ssh-key&lt;/p&gt;

&lt;p&gt;运行命令，并确认它的默认设置，会在$HOME/.ssh/目录下生成两个文件： id_rsa.pub和id_rsa。rsa意味着它们是以RSA加密算法生成的。以pub为后缀的是公钥，可以分发出去(会在下一步添加到远程服务器)；后者是自己的私钥，要妥善保存。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;存储用户公钥到远程服务器&lt;br /&gt;
用户公钥需要添加到远程主机上对应用户的$HOME/.ssh/authorized_keys文件中，以字符串形式附到末尾。有两种方式可以做到：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ssh系列命令
&amp;gt; $ ssh-copy-id user@host&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;等价的手工操作&lt;br /&gt;
&amp;gt; $ ssh user@host #登录远程主机&lt;br /&gt;
&amp;gt; $ mkdir -p $HOME/.ssh #如果用户主目录下.ssh目录不存在则创建&lt;br /&gt;
&amp;gt; $ gedit .ssh/authorized_keys #用文本编辑器打开.ssh/authorized_keys文件，将上一步生成的id_rsa.pub文件里的内容附在末尾。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;个人思考-信任的锚点如何建立&#34;&gt;个人思考：信任的锚点如何建立&lt;/h3&gt;

&lt;p&gt;SSH无论密码登录还是公钥登录，为了保证传输的安全，不得不考虑各种潜在的安全漏洞。由于SSH引入了公钥/私钥机制，可以认为已经建立的连接是安全的。最高危的时刻是建立连接的时候：谁来确认对方的身份、建立对它的信任？&lt;/p&gt;

&lt;p&gt;机器是不能帮我们做到的。所以在首次登录远程主机时，终端会显示远程主机公钥的fingerprint，并询问是否要继续连接它。这时，就需要我们自行承担风险：我信任，或者不信任。一旦选择&amp;rdquo;信任&amp;rdquo;，就意味着建立了&amp;rdquo;信任的锚点&amp;rdquo;。后面的连接都会根据这个锚点而建立信任关系。&lt;/p&gt;

&lt;p&gt;SSH公钥登录的方式也是同理。对一台远程主机而言，当用户的公钥被附到authorized_key文件末尾时，就意味着建立了&amp;rdquo;信任的锚点&amp;rdquo;。执行这个操作的人，就是建立&amp;rdquo;信任的锚点&amp;rdquo;的人，显然也是承担风险的人。&lt;/p&gt;

&lt;p&gt;我觉得从这个角度来思考SSH登录的原理，也是很独特的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于Git,需要理解的几个关键概念</title>
      <link>https://blog.yuantops.com/tech/key-concepts-to-understand-git/</link>
      <pubDate>Fri, 05 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/key-concepts-to-understand-git/</guid>
      <description>

&lt;p&gt;Git的控制哲学十分优雅,特别是了解它后会更为之倾倒。Git的入门在此不赘述。在掌握常用命令之后,再思考下面这些概念,相信对Git的认识会得到提升。&lt;/p&gt;

&lt;h3 id=&#34;git基于commit-每个commit有独一无二的sha-1作为标志&#34;&gt;Git基于Commit,每个Commit有独一无二的SHA 1作为标志&lt;/h3&gt;

&lt;p&gt;Git有Working Tree,Index,Repo的概念。Working Tree指当前的工作目录,当这个目录下有改动时,通过add命令将改动添加到Index区域。当改动都被加到了Index、需要提交时,使用commit命令将它们提交到Repo中。这次提交会形成一个Commit记录,它相当于当前状态的一个SnapShot。&lt;/p&gt;

&lt;p&gt;基于Commit的版本控制是十分优雅的想法。原因在于：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每次Commit,系统只是保存了&lt;strong&gt;文件的改变&lt;/strong&gt;(而不是改变后的文件),这样节省了磁盘空间&lt;/li&gt;
&lt;li&gt;每次Commit都是在上次Commit的基础上发生的(当Git Repo初始化时建立第一个Commit,它是所有Commit的最终基础),包含了对上次Commit的引用,因此一次次的Commit形成了一个链式结构&lt;/li&gt;
&lt;li&gt;每个Commit都有&lt;strong&gt;唯一&lt;/strong&gt;的标志符号: (一般为)SHA 1值。它是Commit的内容经过数学计算得到的。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过引入Commit,我们的所有改动都被纳入系统中,使改动变得有迹可循。&lt;/p&gt;

&lt;h3 id=&#34;branch-head-tag本质上都是为commit所取的别名&#34;&gt;Branch, HEAD, TAG本质上都是为Commit所取的别名&lt;/h3&gt;

&lt;p&gt;只有先理解“Git基于Commit”,才能理解上面这句话。&lt;/p&gt;

&lt;p&gt;因为Repo的更改记录是以一个个Commit组织起来的,它们就像一个个节点,能确定某个确定时刻的目录状态。因此,当我们想要切换到某个状态时,就要在庞大的Commit网络中定位某个Commit,并转到那个Commit。但唯一标准Commit的SHA 1值是很长的一串数字,为了方便识别与输入,就给这些SHA 1添加字符串的别名。因此Branch,HEAD,TAG本质上都是SHA 1的别名,确定Commit用的。&lt;/p&gt;

&lt;p&gt;但Branch, HEAD, TAG毕竟有特殊的地方(不然为什么不给所有的Commit都取别名呢？),它们标记的是特殊的Commit：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Branch标记某个分支上离现在时刻最近的那次Commit。显然,随着在分支上不断提交Commit,Branch的指向对象也不断前进。试想一棵有枝干和树叶的树,那么Branch就是所有树枝末端的那片叶子。又因为每个Commit都包含它父Commit的标识(SHA 1值),所以确定了一个分叉的末端,就相当于确定了这个分叉上的所有Commit。一般而言,Git Repo都默认存在一个叫master的Branch。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HEAD标记当前工作在哪个Commit位置。试想我正在开发软件项目,5个不同分支对应相对5个独立的功能,我要接着修改哪一个分支,就把HEAD移到这个分支上。又因为Branch指向分支的最新Commit,所以也就是把HEAD移到了这个Branch上。当然,如果我不想接着某个Branch的最新进度修改,当然也是可以的,直接切换到那个Commit即可。总之,可以将HEAD想象成*我此时此刻站着干活的地方*。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;TAG是单纯的给Commit的SHA 1取的别名。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;checkout其实是在移动head&#34;&gt;Checkout其实是在移动HEAD&lt;/h3&gt;

&lt;p&gt;只有理解了HEAD的意义,才能理解上面这句话。&lt;/p&gt;

&lt;p&gt;当我们谈论“在不同branch之间切换时”,真正起作用的是HEAD。既然HEAD指向的是某个Commit,那么checkout的参数可以是任何能确定Commit的标志(Branch,TAG,或者直接某个SHA 1值)。当然,checkout命令的用法很多,也有特殊情况checkout命令不会改变HEAD指向的Commit。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SSL学习笔记 前言</title>
      <link>https://blog.yuantops.com/tech/ssl-series-introduction/</link>
      <pubDate>Sun, 30 Nov 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/ssl-series-introduction/</guid>
      <description>&lt;p&gt;最近实习时接触到了SSL协议，CA证书，ssh登录之类的东西，总是一知半解的感觉非常不好，于是我决定好好钻研一下。在网上查找了很多资料后，终于理清了很多以前很模糊的知识点。用几篇博客来记录一下，算是一个总结。&lt;/p&gt;

&lt;p&gt;SSL(Secured Sockets Layer)与SSH(Secure Shell)，是用来解决网络传输中安全问题的协议。如何保证传输安全，使消息不被窃听、不被篡改，这需要用到加密技术。所以，要理解SSL中CA certificate的意义、ssh登录的工作原理，首先得理解它们所基于的加密原理: &lt;strong&gt;非对称加密&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;非对称加密技术是在信息论的理论基础上，以数学为工具的现代加密技术。它是现在最先进、最不易破解的加密技术。由于非对称加密技术在这一系列概念中的基础性地位，会有单独一篇文章介绍它的历史渊源和数学原理。&lt;/p&gt;

&lt;p&gt;非对称加密技术与对称加密技术最明显的区别之处在于，它的密码都是以“&lt;strong&gt;公钥/密钥&lt;/strong&gt;”形式成对存在的。如果要使用非对称加密技术，就出现了很自然的疑问：如何生成这些公钥/密钥对呢？我又该如何使用、部署它们？在Linux系统中，有一些非常强大、非常好用的命令工具帮助我们操作它们。这些命令会在后续谈论应用的技术实现的文章中介绍。(默认Linux环境)&lt;/p&gt;

&lt;p&gt;非对称加密技术最著名的，也是本系列文章将会介绍的，是两大应用：SSH登录和SSL协议。SSH登录的原理相对简单，阮一峰的博客上有几篇文章介绍得非常详细好懂，因此只会有一篇文章讨论它。&lt;/p&gt;

&lt;p&gt;而SSL协议，内容会多一些。首先，参考阮一峰的博客，会有一篇文章关于SSL加密的基本原理(包括Digest, Signature, Certificate等概念)。其次，因为Certificate在现实中使用得非常广泛，会有一到两篇文章介绍Certificate证书与X.509标准，也会介绍CA以及Certificate的&amp;rdquo;信任链&amp;rdquo;，PKI等概念。然后，会有一篇文章介绍如何为自己的域名生成Certificate。最后，从另外一个角度出发，会有一篇文章讨论当浏览器通过https链接访问网页时的交互流程(基本上翻译一篇国外的博客)。&lt;/p&gt;

&lt;p&gt;非对称加密技术也可以在DNS系统中使用，即DNSSEC技术。关于这一技术，如果有时间的话，也会有一到两篇博客予以介绍。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>vim增加markdown语法高亮支持</title>
      <link>https://blog.yuantops.com/tech/vim-add-markdown-syntax-support/</link>
      <pubDate>Sun, 30 Nov 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/vim-add-markdown-syntax-support/</guid>
      <description>&lt;p&gt;markdown是一种非常简洁美观的语法格式，非常适合用来撰写博客(&lt;a href=&#34;http://www.jianshu.com/p/q81RER&#34;&gt;简书 语法简介&lt;/a&gt;)。在linux下，我个人最习惯用vim做文本编辑器。那么，如何使vim支持markdown的语法高亮呢？&lt;/p&gt;

&lt;p&gt;vim是支持自定义语法高亮插件的。于是，问题就变成了两部分：&lt;br /&gt;
1. 找到markdown语法高亮显示的vim配置文件&lt;br /&gt;
2. 在vim中导入这个配置文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;vim配置文件下载&lt;/strong&gt;&lt;br /&gt;
vim语法配置文件一般后缀为.vim。markdown的语法配置文件可以从下面链接中找到，假设它为markdown.vim, 将其下载到本地。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.vim.org/scripts/script.php?script_id=1242&#34;&gt;vim官网链接&lt;/a&gt;, 或者这个项目的最新&lt;a href=&#34;http://github.com/plasticboy/vim-markdown/&#34;&gt;github项目&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;配置文件导入&lt;/strong&gt;&lt;br /&gt;
vim自定义配置文件的导入和安装见&lt;a href=&#34;http://www.fleiner.com/vim/create.html&#34;&gt;链接&lt;/a&gt;。 在这里我将其转述如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在.vimrc文件(.vimrc文件一般在$HOME目录下，若不存在则新建)中添加一条语句，定义一种语法格式，以及这种格式对应的配置文件。&lt;br /&gt;
以本文为例，假设markdown.vim保存路径为$HOME/.vim/markdown.vim，则在.vimrc文件中添加&lt;br /&gt;
&amp;gt; au! Syntax markdown source $HOME/.vim/markdown.vim&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注&lt;/em&gt;: 配置文件路径一定要正确配置&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;再在.vimrc文件中添加一条语句，规定何种后缀名的文件适用这种语法格式。&lt;br /&gt;
以本文为例，我想后缀名为md与markdown的文件以markdown格式显示，那么在.vimrc中添加语句&lt;br /&gt;
&amp;gt; au BufRead,BufNewFile *.md set filetype=markdown&lt;br /&gt;
&amp;gt; au BufRead,BufNewFile *.markdown set filetype=markdown&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;保存.vimrc文件并退出，整个配置过程结束。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
