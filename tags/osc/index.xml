<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Osc on Yuantops&#39; Blog</title>
    <link>https://blog.yuantops.com/tags/osc/</link>
    <description>Recent content in Osc on Yuantops&#39; Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>yuan.tops@gmail.com (yuantops)</managingEditor>
    <webMaster>yuan.tops@gmail.com (yuantops)</webMaster>
    <copyright>All rights reserved.</copyright>
    <lastBuildDate>Sat, 27 Dec 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://blog.yuantops.com/tags/osc/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>OSC Android源码学习笔记 四 listview初始化、获取数据、加载数据的流程</title>
      <link>https://blog.yuantops.com/tech/osc-android-app-notes-4/</link>
      <pubDate>Sat, 27 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/osc-android-app-notes-4/</guid>
      <description>&lt;p&gt;OSC App显示的信息分为资讯(news)，博客(blog)，问答(Question)，动弹(tweet)几屏，每屏对应一个ListView。以资讯(news)为例，粗略看一下它的ListView是如何初始化、获取数据、加载数据的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;实例化一个ListViewNewsApapter并添加到lvNews：&lt;br /&gt;

lvNewsAdapter = new ListViewNewsAdapter(this, lvNewsData, R.layout.news_listitem);

ListViewNewsApapter这个类继承BaseAdapter，重写了getView()方法。值得注意的是，getView()方法中news实体被被作为Tag添加到了listView的ItemView中。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为lvNews设置lvNewsAdapter。lvNews和lvNewsAdapter都是Main这个类持有的变量，而不是某个函数的局部变量。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;为lvNews设置OnClickListener，这个Listener以匿名内部类方式初始化：
当点击单个item view时，从view中取出news这个Tag，然后使用UIHelper.showNewsRedirect()方法跳转到新闻阅读详情页。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实例化一个lvNewsHandler：&lt;br /&gt;

lvNewsHandler = this.getLvHandler(lvNews, lvNewsAdapter, lvNews_foot_more, lvNews_foot_progress, AppContext.PAGE_SIZE);
&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个Handler定义了当接收到有数据更新的通知时，应该作何处理。主要是通知adapter数据发生了变化：&lt;br /&gt;

adapter.notifyDataSetChanged();
&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;下载数据，加载数据：&lt;br /&gt;

loadLvNewsData(curNewsCatalog, 0, lvNewsHandler, UIHelper.LISTVIEW_ACTION_INIT);

新开进程，调用appContext.getNewList()从服务器获取数据。数据获取完成后，通过传入的lvNewsHandler发送Message，回调handleMessage(Message msg)方法。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>开源中国安卓客户端源码学习笔记 三 自定义Exception类</title>
      <link>https://blog.yuantops.com/tech/osc-android-app-notes-3/</link>
      <pubDate>Thu, 25 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/osc-android-app-notes-3/</guid>
      <description>&lt;p&gt;net.oschina.app包中包含四个类的定义文件，它们分别是AppConfig, AppException, AppManager, AppStart。其中AppStart类继承Activity，是跳转界面。AppException类是Exception的子类，是自定义的异常类。&lt;/p&gt;

&lt;p&gt;AppException类中有8个final static类型的类变量，定义异常类型: network, socket, http, xml, io, run, jason几种。这个类中有对应的静态方法，以Exception为形参，返回对应的新建对象。值得注意的是，代码中预留了debug的选项，如果在新建AppException对象时传入“debug”参数，那么对应的Exception信息会被写到文件中保存。&lt;/p&gt;

&lt;p&gt;这个类中定义了异常的处理方式：收集错误信息，然后显示异常信息&amp;amp;发送错误报告。显示异常信息和发送错误报告的过程在新建的Thread里完成。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>开源中国安卓客户端源码学习笔记 二 欢迎界面跳转与渐变效果</title>
      <link>https://blog.yuantops.com/tech/osc-android-app-notes-2/</link>
      <pubDate>Tue, 23 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/osc-android-app-notes-2/</guid>
      <description>&lt;p&gt;OSC客户端启动时会先显示欢迎界面，再跳转到主页，其中跳转过程有渐变效果。&lt;/p&gt;

&lt;p&gt;这里使用了AlphaAnimation类。AlphaAnimation类能实现渐进渐出的效果，官方文档里说“This animation ends up changing the alpha property of a Transformation”。alpha property可以理解为透明度，&amp;rdquo;0.0&amp;rdquo;为全透明，“0.5”为半透明，“1.0”时不透明。&lt;/p&gt;



	//渐变展示启动屏
	AlphaAnimation aa = new AlphaAnimation(0.3f,1.0f);
	aa.setDuration(3000);
	view.startAnimation(aa);
	aa.setAnimationListener(new AnimationListener()
	{
		@Override
		public void onAnimationEnd(Animation arg0) {
			redirectTo();
		}
		@Override
		public void onAnimationRepeat(Animation animation) {}
		@Override
		public void onAnimationStart(Animation animation) {}
	});



&lt;p&gt;另外，欢迎界面的图片可以更新。从代码分析，在将View设置为ContentView之前，程序会检查欢迎界面对应缓存文件夹里的图片文件，图片文件的文件名有一个时间期限，如果今天正好落在这个期限内，那么就将它设为背景图片。如此可以推测APP会在启动后自动下载新的图片文件(如果存在的话)到缓存文件夹，从而达到更新效果。&lt;/p&gt;

&lt;p&gt;果然，在跳转到Main Activity后，在onCreate()方法里调用了checkBackGround()方法。这个方法会新开一个Thread去服务器检查是否有新的图片需要下载，如果有，那么会下载下来。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>开源中国安卓客户端源码学习笔记 一</title>
      <link>https://blog.yuantops.com/tech/osc-android-app-notes-1/</link>
      <pubDate>Mon, 22 Dec 2014 00:00:00 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/osc-android-app-notes-1/</guid>
      <description>&lt;p&gt;##前言
开源中国(OSCHINA)是国内一个开源社区,社区自己开发了Android和iOS平台的客户端，而且将各自的代码开源了。值得夸奖的是，他们的Android APP不是基于HTML，而是Android原生API。我最近在学习它Android App的&lt;a href=&#34;http://git.oschina.net/oschina/android-app&#34;&gt;源代码&lt;/a&gt;，毕竟像它这样性能优秀、注释齐全的开源项目是比较稀少的。&lt;/p&gt;

&lt;p&gt;希望能通过阅读源代码，学到一些Android开发的实战技巧，并加深对已有知识的理解。&lt;/p&gt;

&lt;p&gt;##学习笔记一 利用getApplication()共享全局数据&lt;br /&gt;
程序启动Activity是net.oschina.app.AppStart。这个Activity类持有一个自定义的AppContext成员。查看net.oschina.app.AppContext类的定义，作者说它是“全局应用程序类，用于保存和调用全局应用配置及访问网络数据”。&lt;/p&gt;

&lt;p&gt;AppContext类是Application类的子类。Google了getApplication()函数，找到了一篇介绍得比较明白的文章：&lt;br /&gt;
- &lt;a href=&#34;http://www.cnblogs.com/liu666bin/archive/2013/01/05/2846081.html&#34;&gt;android利用getApplication()共享全局数据&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在平时开发中，如果需要一些能被所有Activity和View访问到的全局数据，就可以自定义一个继承Application类的子类，扩展它所持有的成员。&lt;strong&gt;值得注意&lt;/strong&gt;，还需在android Manifest.xml文件中将application的android:name属性指定为自定义的类。&lt;/p&gt;

&lt;p&gt;另外,关于getApplication()和getApplicationContext()的区别,&lt;a href=&#34;http://stackoverflow.com/questions/5018545/getapplication-vs-getapplicationcontext&#34;&gt;stackoverflow&lt;/a&gt;上有人这么解释:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;虽然当前Anroid Activity和Service的实现方式使得getApplication()和getApplicationContext()返回相同的object，但不能保证它们将来会一直这样。  

如果你想在Manifest.xml文件中注册Application class，那么**永远不要**调用getApplicationContext()并将其cast为你的application类，因为它返回的很可能不是你的application实例。  

getApplication()仅仅在Activity和Service类中可以被调用，而getApplicationContext()则是在Context类中被声明的。这意味着，譬如说你写了一个Broadcast Receiver，Broadcast Receiver本身不是一个Context类，尽管它能通过onReceive()方式获得一个Context类的引用，这时你就只能调用getApplicationContext()了——这也就意味着，不能确保在BroadcastReceiver中访问到application。  

另外，Android的官方文档中提到，你**不应该**需要去继承Application类:  

There is normally no need to subclass Application. In most situation, static singletons can provide the same functionality in a more modular way. If your singleton needs a global context (for example to register broadcast receivers), the function to retrieve it can be given a  Context which internally uses Context.getApplicationContext() when first constructing the singleton.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然官方推荐用静态singleton的方式去设置全局数据，但是在回复中有人提到，在实际中还是继承Application的方式来得更方便。所以，到底用那种方式更好，就见仁见智吧。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
