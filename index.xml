<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Yuantops&#39; Blog</title><link>https://blog.yuantops.com/</link><description>Recent content on Yuantops&#39; Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>yuan.tops@gmail.com (yuantops)</managingEditor><webMaster>yuan.tops@gmail.com (yuantops)</webMaster><copyright>All rights reserved.</copyright><lastBuildDate>Sun, 12 Sep 2021 00:00:00 +0800</lastBuildDate><atom:link href="https://blog.yuantops.com/" rel="self" type="application/rss+xml"/><item><title>最近一次重装系统</title><link>https://blog.yuantops.com/tech/reinstall-windows-10-for-dual-boot-system/</link><pubDate>Sun, 12 Sep 2021 00:00:00 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/reinstall-windows-10-for-dual-boot-system/</guid><description>
&lt;p&gt;上次重装系统是什么时候？很久很久之前了吧。&lt;/p&gt;
&lt;p&gt;手上这台二手Thinkpad T450s，装着 &lt;code&gt;Ubuntu&lt;/code&gt; 和 &lt;code&gt;Windows 10&lt;/code&gt; ，其中 &lt;code&gt;Ubuntu&lt;/code&gt; 是我装的; &lt;code&gt;Windows 10&lt;/code&gt; 继承自上任主人，我接手后几乎没有&amp;rdquo;装修&amp;rdquo;，一直凑合用着。最近，它越来越不趁手，终于我下定决心——重装Windows。&lt;/p&gt;
&lt;h2 id=&#34;镜像与烧录工具&#34;&gt;镜像与烧录工具&lt;/h2&gt;
&lt;p&gt;根据之前捣腾 &lt;code&gt;Ubuntu&lt;/code&gt; 的经验，需要准备三件东西:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统镜像&lt;/li&gt;
&lt;li&gt;将镜像烧录 U 盘的工具软件&lt;/li&gt;
&lt;li&gt;U盘，用作启动盘&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;哪个 &lt;code&gt;Windows&lt;/code&gt; 版本最好？在知乎网搜索一番，很多网友推荐 &lt;code&gt;Windows Enterprise LTSC 2019&lt;/code&gt; ，而且推荐一个神奇的下载网站 &lt;a href=&#34;https://msdn.itellyou.cn/&#34;&gt;I Tell You&lt;/a&gt;, 上面有各种各样镜像资源。LTSC 镜像下载链接是 `ed2k` 格式，依稀记得是一种BT下载协议（？），现在比较少见。我不得不先安装迅雷，再用迅雷处理这个小众的 `ed2k` 链接。说句题外话，迅雷居然还活着，实在令人震惊，但接着发现它趁我不备偷偷装上了一个奇怪软件，又有些唏嘘了:国产软件活着不容易啊，就连迅雷也堕落成流氓软件了！&lt;/p&gt;
&lt;p&gt;镜像烧录工具，知乎网友推荐用 &lt;a href=&#34;https://rufus.ie/zh/&#34;&gt;https://rufus.ie/zh/&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;U盘，我随手找到一个8G盘。&lt;/p&gt;
&lt;p&gt;这时候，准备工作完毕。&lt;/p&gt;
&lt;h2 id=&#34;重启电脑-开始重装&#34;&gt;重启电脑，开始重装&lt;/h2&gt;
&lt;p&gt;说下前情提要。这台 T450s 装过双系统，启动方案已经是 &lt;code&gt;UEFI&lt;/code&gt; ，上电后默认进入 Ubuntu Grub 引导，可以选择进入 Ubuntu 还是 Windows。(还记得昔日主流启动引导方案 &lt;code&gt;MBR&lt;/code&gt; 吗？现在已经称作 &lt;code&gt;Legacy/MBR&lt;/code&gt; 。真是历史的眼泪啊。)&lt;/p&gt;
&lt;p&gt;这里不详述 &lt;code&gt;UEFI/GPT&lt;/code&gt; 的先进性。在支持双系统启动这一点上， &lt;code&gt;UEFI/GPT&lt;/code&gt; 比起 &lt;code&gt;UEFI/GPT&lt;/code&gt; 要复杂一些: 需要修改 &lt;code&gt;BIOS&lt;/code&gt; 菜单，将 &lt;code&gt;Secure Boot&lt;/code&gt; 置为 &lt;code&gt;false&lt;/code&gt; 。具体可以参考&lt;a href=&#34;https://support.lenovo.com/hk/en/solutions/ht509044-how-to-enable-secure-boot-on-think-branded-systems-thinkpad-thinkstation-thinkcentre&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我的T450s已经配置过 &lt;code&gt;BIOS&lt;/code&gt; ，所以跳过上面这步。&lt;/p&gt;
&lt;p&gt;进入开机启动，眼疾手快，迅速按 &lt;code&gt;F12&lt;/code&gt; 进入启动菜单。选择从U盘启动，进入安装界面。&lt;/p&gt;
&lt;h2 id=&#34;新系统升级驱动&#34;&gt;新系统升级驱动&lt;/h2&gt;
&lt;p&gt;系统装好后，总感觉清晰度不够。我猜想，是驱动不适配。搜索 &lt;code&gt;驱动人生&lt;/code&gt; 关键字，这是类似驱动精灵的一款软件。为什么不直接安装驱动精灵？因为驱动精灵也长成流氓软件的模样了。。 &lt;code&gt;驱动人生&lt;/code&gt; 实际体验还可以，有点古典互联网软件那意思。&lt;/p&gt;
&lt;p&gt;驱动人生识别出系统显卡驱动需要升级。选自动升级，然后屏幕恢复正常。&lt;/p&gt;
&lt;h2 id=&#34;调整-bios-引导顺序&#34;&gt;调整 BIOS 引导顺序&lt;/h2&gt;
&lt;p&gt;重启电脑，如果什么都不做，将默认进入 Windows10。原因是，Windows10 装好后自动生成一条 Windows 引导记录，而且优先级最高。之前 &lt;code&gt;Ubuntu&lt;/code&gt; 的引导项仍然在那儿，只是往后挪了一位。电脑启动时，总是尝试按优先级加载，自然进入 Windows 。&lt;/p&gt;
&lt;p&gt;要找回 Linux GRUB 引导界面，只需进入 &lt;code&gt;BIOS&lt;/code&gt; 菜单，找到设置引导顺序的界面，把 Linux 引导条目挪到第一位。&lt;/p&gt;
&lt;h2 id=&#34;小问题-双系统-windows-时间对不上&#34;&gt;小问题：双系统，Windows 时间对不上？&lt;/h2&gt;
&lt;p&gt;原因是 Windows 和 Linux 处理硬件时间的方式不一样。参考网友的&lt;a href=&#34;https://blog.csdn.net/zhouchen1998/article/details/108893660&#34;&gt;解决方案&lt;/a&gt;, 用三行命令解决问题:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt install ntpdate;
sudo ntpdate time.windows.com;
sudo hwclock --localtime --systohc
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>一次顿悟</title><link>https://blog.yuantops.com/tech/some_eureka_moment/</link><pubDate>Wed, 01 Sep 2021 00:00:00 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/some_eureka_moment/</guid><description>&lt;p&gt;最近用 &lt;code&gt;Emacs&lt;/code&gt; &lt;code&gt;ox-hugo&lt;/code&gt; 写了几篇文章，体验比较糟，表现为总是无理由卡顿，特别是在 org 页面按下 `Ctrl-C, Ctrl-E`导出markdown时直接卡死，好几次只能强行杀掉Emacs 进程。&lt;/p&gt;
&lt;p&gt;总所周知，Emacs 是神的编辑器，肯定不会出问题；我不爽，必定是我不会用了。于是，我鼓足勇气，想看看是哪里出了问题。&lt;/p&gt;
&lt;p&gt;经过辛勤搜索，各种修改配置，纹丝不动。焦躁之余，不禁回忆起往事……&lt;/p&gt;
&lt;p&gt;原本我是坚定vim党，自得其乐。&lt;/p&gt;
&lt;p&gt;后来，受网络meme影响，终于买了一本讲Emacs的电子书，开始像八爪章鱼一样学按键，键位那么多，组合那么多。。。草草翻完一遍，只剩下 &amp;ldquo;这也行！&amp;rdquo; 的感叹号。试了 &lt;code&gt;Dired&lt;/code&gt;, &lt;code&gt;Magit&lt;/code&gt;, 自觉太复杂，难以记忆。放弃之。&lt;/p&gt;
&lt;p&gt;又过了一段时间，心又痒痒了……这次吃了 &lt;code&gt;org&lt;/code&gt; 的安利，GTD 好厉害！！大概实践了两个星期，只记得按 &lt;code&gt;Tab&lt;/code&gt; 键可以切换标题等级。&lt;/p&gt;
&lt;p&gt;下一次入坑，是受到 &lt;code&gt;ox-hugo&lt;/code&gt; 的蛊惑: 确实如行云流水，非常满意。&lt;/p&gt;
&lt;p&gt;想到这里，我顿悟了，我只是为了 &lt;strong&gt;org-mode 和 ox-hugo 啊&lt;/strong&gt; ！ Emacs 再怎么厉害，别人用得再怎么出神入化，用它写代码(特别写Java!!)、看小说、玩游戏、看视频…… 和我有什么关系呢? 弱水三千，只需取一瓢。&lt;/p&gt;
&lt;p&gt;于是，爽爽快快删掉攒了多年的配置:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;rm -fr .emacs.d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;热情投向 &lt;code&gt;spacemacs&lt;/code&gt; 怀抱:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone -b develop https://github.com/syl20bnr/spacemacs .emacs.d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动emacs。因为是spacemacs第一次加载配置文件，会有一些询问交互。一路选择最小化配置。&lt;/p&gt;
&lt;p&gt;最后修改 &lt;code&gt;.spacemacs&lt;/code&gt;, 加上 &lt;code&gt;ox-hugo&lt;/code&gt; 支持:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-emacs-lisp&#34; data-lang=&#34;emacs-lisp&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-emacs-lisp&#34; data-lang=&#34;emacs-lisp&#34;&gt;(setq-default dotspacemacs-configuration-layers
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;((org :variables
org-enable-hugo-support &lt;span style=&#34;color:#66d9ef&#34;&gt;t&lt;/span&gt;)))&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;重新加载配置，完完全全就好了！&lt;/p&gt;
&lt;p&gt;恭喜我自己 :)&lt;/p&gt;</description></item><item><title>H2 Database hack —— 批量插入的猥琐实现</title><link>https://blog.yuantops.com/tech/h2_database_hack_batch_insert/</link><pubDate>Fri, 27 Aug 2021 00:00:00 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/h2_database_hack_batch_insert/</guid><description>
&lt;p&gt;H2 数据库是一款优秀的内存数据库，它具备几个特点：体积小，文档全，功能完善，而且是Java写的。&lt;/p&gt;
&lt;p&gt;最近用到它这些优良特性，做内存计算。以内存模式启动了一个H2实例。接下来，要把外部数据导入H2数据库。这就面临一个问题：数据量大（几万+）的情况下，如何保证插入速度？&lt;/p&gt;
&lt;h2 id=&#34;常规方案&#34;&gt;常规方案&lt;/h2&gt;
&lt;p&gt;随便一种JDBC 持久层工具, 例如 &lt;strong&gt;JdbcTemplate&lt;/strong&gt;, &lt;strong&gt;MyBatis&lt;/strong&gt;,都封装了批量接口。怀着封装越少、效率越高的朴素信念，用H2原生JDBC Connection.insert() 方法，循环插入。2.7 万条数据，耗时约 3s。&lt;/p&gt;
&lt;p&gt;另外，h2 database 官方有一种做法：把数据先导到 csv 文件，然后加载csv。虽没有实际验证这种方案，但纸上谈兵分析，即使数据加载变快，但增加了两次I/O。效果估计不会特别优秀。&lt;/p&gt;
&lt;h2 id=&#34;快速方案&#34;&gt;快速方案&lt;/h2&gt;
&lt;p&gt;同事脑洞大开：内存数据库插入语句，先是SQL解析，再把Java对象写进内存。既然都是Java 对象，能不能跳过SQL这一遭，直接写内存?&lt;/p&gt;
&lt;p&gt;不经过JDBC，不经过SQL，这种思路也是不按常规出牌了。但原理非常说得通，而且肯定更快。&lt;/p&gt;
&lt;p&gt;经过一步步断点调试，找到了关键类: &lt;strong&gt;org.h2.table.Table&lt;/strong&gt; 。insert() 语句走到最后，是往table 里添加行(&lt;strong&gt;org.h2.result.Row&lt;/strong&gt;)。换言之，只要拿到 table，又按格式构造行，就可以了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;获取Table
按作者原意，应该是不希望使用者直接操作 Table 对象的。但是架不住我们猥琐啊，借助反射机制，什么都拿得到。
下面，是一步步抠出 Table 对象的实现。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; String sql = &amp;quot;select * from &amp;quot; + tableName;
try (JdbcPreparedStatement ps = (JdbcPreparedStatement) connection.prepareStatement(sql)) {
CommandContainer commandContainer = (CommandContainer) getFieldByForce(ps, JdbcPreparedStatement.class,
&amp;quot;command&amp;quot;);
Session session = (Session) getFieldByForce(ps, JdbcPreparedStatement.class, &amp;quot;session&amp;quot;);
Select command = (Select) getFieldByForce(commandContainer, CommandContainer.class, &amp;quot;prepared&amp;quot;);
Table table = new ArrayList&amp;lt;&amp;gt;(command.getTables()).get(0);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;构造行
待插入的数据格式是Map, key是列名，value是值。对应到 &lt;strong&gt;org.h2.result.Row&lt;/strong&gt; 的话 ，map每个entry对应一列。当然，涉及一些列名提取与转化，数据类型处理的工作。
下面是构造行的实现。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Row newRow = table.getTemplateRow();
Column[] columns = table.getColumns();
for (Column c : columns) {
int index = c.getColumnId();
String columnName = c.getName();
if (!map.containsKey(columnName)) {
newRow.setValue(c.getColumnId(), ValueNull.INSTANCE);
} else {
Object value = map.get(columnName);
if (value instanceof String) {
newRow.setValue(index, ValueString.get(value.toString()));
} else if (value instanceof Integer) {
newRow.setValue(index, ValueInt.get((Integer) value));
} else if (value instanceof Timestamp) {
newRow.setValue(index, ValueTimestamp.get(TimeZone.getDefault(), (Timestamp) value));
} else if (value instanceof BigDecimal) {
newRow.setValue(index, ValueDecimal.get((BigDecimal) value));
} else {
// todo 类型还需充分枚举
newRow.setValue(index, ValueString.get(value.toString()));
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提交插入
因为从 &lt;strong&gt;org.h2.engine.Session&lt;/strong&gt; 剥离出了Table对象，而h2是支持事务的数据库，所以在插入结束后，还需要执行commit，让改变生效。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;session.commit(false);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;最终效果&#34;&gt;最终效果&lt;/h2&gt;
&lt;p&gt;2.7w 条数据，耗时 700ms。相比传统方案(2.7w条数据，3000ms)，耗时减少了将近八成，颇为可观了。&lt;/p&gt;
&lt;h2 id=&#34;源码&#34;&gt;源码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;
import lombok.extern.slf4j.Slf4j;
import org.h2.command.CommandContainer;
import org.h2.command.dml.Select;
import org.h2.engine.Session;
import org.h2.jdbc.JdbcConnection;
import org.h2.jdbc.JdbcPreparedStatement;
import org.h2.result.Row;
import org.h2.table.Column;
import org.h2.table.Table;
import org.h2.value.*;
import org.springframework.util.ReflectionUtils;
import java.lang.reflect.Field;
import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;
@Slf4j
public class H2InsertUtil {
public static void batchInsert(Connection toSqlSession, String tableName, List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; data) {
assert isH2Dialect(toSqlSession);
try {
JdbcConnection connection = toSqlSession.unwrap(JdbcConnection.class);
doBatchInsert(connection, tableName, data);
} catch (SQLException e) {
throw new RuntimeException(&amp;quot;使用H2批量插入出错.&amp;quot;, e);
}
}
private static boolean isH2Dialect(Connection sqlSession) {
try {
return sqlSession.isWrapperFor(JdbcConnection.class);
} catch (SQLException e) {
log.warn(&amp;quot;判断connection类型时出错&amp;quot;, e);
return false;
}
}
private static void doBatchInsert(JdbcConnection connection, String tableName, List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; batchData) throws SQLException {
String sql = &amp;quot;select * from &amp;quot; + tableName;
try (JdbcPreparedStatement ps = (JdbcPreparedStatement) connection.prepareStatement(sql)) {
CommandContainer commandContainer = (CommandContainer) getFieldByForce(ps, JdbcPreparedStatement.class,
&amp;quot;command&amp;quot;);
Session session = (Session) getFieldByForce(ps, JdbcPreparedStatement.class, &amp;quot;session&amp;quot;);
Select command = (Select) getFieldByForce(commandContainer, CommandContainer.class, &amp;quot;prepared&amp;quot;);
Table table = new ArrayList&amp;lt;&amp;gt;(command.getTables()).get(0);
for (Map&amp;lt;String, Object&amp;gt; data : batchData) {
Row newRow = createRow(table, data);
table.addRow(session, newRow);
}
session.commit(false);
} catch (Exception e) {
log.error(&amp;quot;&amp;quot;, e);
throw e;
}
}
private static Object getFieldByForce(Object obj, Class&amp;lt;?&amp;gt; clazz, String fieldName) {
Field field = ReflectionUtils.findField(clazz, fieldName);
ReflectionUtils.makeAccessible(field);
return ReflectionUtils.getField(field, obj);
}
private static Row createRow(Table table, Map&amp;lt;String, Object&amp;gt; map) {
Row newRow = table.getTemplateRow();
Column[] columns = table.getColumns();
for (Column c : columns) {
int index = c.getColumnId();
String columnName = c.getName();
if (!map.containsKey(columnName)) {
newRow.setValue(c.getColumnId(), ValueNull.INSTANCE);
} else {
Object value = map.get(columnName);
if (value instanceof String) {
newRow.setValue(index, ValueString.get(value.toString()));
} else if (value instanceof Integer) {
newRow.setValue(index, ValueInt.get((Integer) value));
} else if (value instanceof Timestamp) {
newRow.setValue(index, ValueTimestamp.get(TimeZone.getDefault(), (Timestamp) value));
} else if (value instanceof BigDecimal) {
newRow.setValue(index, ValueDecimal.get((BigDecimal) value));
} else {
// todo 类型还需充分枚举
newRow.setValue(index, ValueString.get(value.toString()));
}
}
}
return newRow;
}
}
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>TCP TIME_WAIT 连接太多</title><link>https://blog.yuantops.com/tech/linux_tcp_time_wait_tuning/</link><pubDate>Tue, 24 Aug 2021 00:00:00 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/linux_tcp_time_wait_tuning/</guid><description>
&lt;p&gt;压测一个服务，性能卡住了上不去。错误信息提示是没有可分配端口。搜索发现别人也遇到过类似问题(&lt;a href=&#34;https://www.cnblogs.com/softidea/p/6062147.html&#34;&gt;linux 大量的TIME_WAIT解决办法&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;把解决配置摘录如下：&lt;/p&gt;
&lt;p&gt;配置 tcp 连接参数 vim /etc/sysctl.conf
编辑文件，加入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_fin_timeout = 30
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，也要关注系统本身对资源限制:
配置 /etc/security/limits.conf，把值加大:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;* soft nofile 65535
* hard nofile 65535
* soft nproc 65535
* hard nproc 65535
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;net-dot-ipv4-dot-tcp-fin-timeout-做了啥&#34;&gt;net.ipv4.tcp_fin_timeout 做了啥?&lt;/h2&gt;
&lt;p&gt;Stackoverflow 网友&lt;a href=&#34;https://stackoverflow.com/questions/46066046/unable-to-reduce-time-wait&#34;&gt;如是说&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;Your link is urban myth. The actual function of net.ipv4.tcp_fin_timeout is as follows:
This specifies how many seconds to wait for a final FIN packet before the socket is forcibly closed. This is strictly a violation of the TCP specification, but required to prevent denial-of-service attacks. In Linux 2.2, the default value was 180.
This doesn&#39;t have anything to do with TIME_WAIT. It establishes a timeout for a socket in FIN_WAIT_1, after which the connection is reset (which bypasses TIME_WAIT altogether). This is a DOS measure, as stated, and should never arise in a correctly written client-server application. You don&#39;t want to set it so low that ordinary connections are reset: you will lose data. You don&#39;t want to fiddle with it at all, actually.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是时候破除迷思了！这个参数和 &lt;strong&gt;TIME_WAIT&lt;/strong&gt; 没有直接关系。根据TCP/IP状态机，主动发起关闭的一方，将进入 &lt;strong&gt;FIN_WAIT_1&lt;/strong&gt; 状态，等待接收 &lt;strong&gt;FIN&lt;/strong&gt; 报文。 &lt;strong&gt;net.ipv4.tcp_fin_timeout&lt;/strong&gt; 规定在 &lt;strong&gt;FIN_WAIT_1&lt;/strong&gt; 状态的停留时间。时间一到，跳过 &lt;strong&gt;TIME_WAIT&lt;/strong&gt; 状态，连接被强行关闭。&lt;/p&gt;</description></item><item><title>nginx 反向代理不开启http1.1时的行为探究</title><link>https://blog.yuantops.com/tech/nginx_proxy_pass_without_enable_http1/</link><pubDate>Tue, 24 Aug 2021 00:00:00 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/nginx_proxy_pass_without_enable_http1/</guid><description>
&lt;p&gt;最近给一个tomcat服务加上nginx代理，陆续遇到一些问题（坑）。&lt;/p&gt;
&lt;p&gt;第一个坑，一个接口直接访问正常，经nginx代理后报104错误(104: Connection reset by peer)。奇葩之处在于，只有特定的接口出现这种错。&lt;/p&gt;
&lt;h2 id=&#34;先说解决方案-配置反向代理长链接&#34;&gt;先说解决方案：配置反向代理长链接&lt;/h2&gt;
&lt;p&gt;很容易搜到104错误的解决方案.在nginx配置中，加上下面两句:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;proxy_http_version 1.1;
proxy_set_header Connection &amp;quot;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加上之后，执行命令 &lt;strong&gt;nginx -s reload&lt;/strong&gt; 生效。&lt;/p&gt;
&lt;p&gt;翻看nginx&lt;a href=&#34;http://nginx.org/en/docs/http/ngx%5Fhttp%5Fproxy%5Fmodule.html#keepalive&#34;&gt;官方文档&lt;/a&gt;，这么说:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;
For HTTP, the proxy_http_version directive should be set to “1.1” and the “Connection” header field should be cleared:
upstream http_backend {
server 127.0.0.1:8080;
keepalive 16;
}
server {
...
location /http/ {
proxy_pass http://http_backend;
proxy_http_version 1.1;
proxy_set_header Connection &amp;quot;&amp;quot;;
...
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到这里，问题已经解决。我们再进一步，看看配置前后的区别。&lt;/p&gt;
&lt;h2 id=&#34;tcpdump-抓包&#34;&gt;tcpdump 抓包&lt;/h2&gt;
&lt;p&gt;在修改前后，各自抓包。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;tcpdump -iensxxx -vvvs0 -l -A &amp;lsquo;tcp port 80 or tcp port 8082&amp;rsquo; -w tcpdump.cap&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;wireshark分析&#34;&gt;wireshark分析&lt;/h2&gt;
&lt;p&gt;将*.cap文件用wireshark 打开.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在filter里输入 &lt;strong&gt;http.request &amp;amp;&amp;amp; http contains &amp;ldquo;HTTP/1.0&amp;rdquo;&lt;/strong&gt; ，过滤出nginx到上游服务的请求.&lt;/li&gt;
&lt;li&gt;随意选中一条记录。右键，&amp;rdquo;追踪流&amp;hellip;&amp;rdquo; -&amp;gt; &amp;ldquo;TCP流&amp;rdquo;。这样，筛选出了TCP会话的所有包记录。&lt;/li&gt;
&lt;li&gt;右键, &amp;ldquo;复制&amp;rdquo; -&amp;gt; &amp;ldquo;摘要为文本&amp;rdquo;，可以将报文导出为文本。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面的记录，第一条是异常响应报文，第二条是正常响应报文。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;--- not ok tcp.stream eq 75
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Content-Type: application/json;charset=UTF-8
Date: Mon, 23 Aug 2021 09:41:57 GMT
Connection: close
[{&amp;quot;xxxxxx&amp;quot;:&amp;quot;xxxxxxxxxxxxxxx&amp;quot;,&amp;quot;xxxx&amp;quot;:&amp;quot;xxx&amp;quot;,&amp;quot;xxxxxx&amp;quot;:&amp;quot;xxxxxxxxxxxxx&amp;quot;,&amp;quot;xxx&amp;quot;:xx}]
--- ok tcp.stream eq 104
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Mon, 23 Aug 2021 09:45:33 GMT
4d
[{&amp;quot;xxxxxx&amp;quot;:&amp;quot;xxxxxxxxxxxxxxx&amp;quot;,&amp;quot;xxxx&amp;quot;:&amp;quot;xxx&amp;quot;,&amp;quot;xxxxxx&amp;quot;:&amp;quot;xxxxxxxxxxxxx&amp;quot;,&amp;quot;xxx&amp;quot;:xx}]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以观察到:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;头部不一致。
&lt;ul&gt;
&lt;li&gt;异常报文多了 &amp;ldquo;Connection: close&amp;rdquo; ，含义是数据返回后将关闭连接。&lt;/li&gt;
&lt;li&gt;正常报文多了 &amp;ldquo;Transfer-Encoding: chunked&amp;rdquo;，含义是返回的数据采取“分块编码”, 也就是分多块返回。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;body不一致。
&lt;ul&gt;
&lt;li&gt;正常报文在body之前，声明了数据块的大小。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;我们使用HTTP1.0发起请求，但返回报文头部居然写着 HTTP/1.1。这是怎么回事??
参考 &lt;a href=&#34;https://stackoverflow.com/questions/19461312/why-tomcat-reply-http-1-1-respose-with-an-http-1-0-request&#34;&gt;https://stackoverflow.com/questions/19461312/why-tomcat-reply-http-1-1-respose-with-an-http-1-0-request&lt;/a&gt;, 返回头的HTTP版本号只是一个声明，告知调用方服务端所支持的最高HTTP版本。&lt;/li&gt;
&lt;/ol&gt;
&lt;!--listend--&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;
This Connector supports all of the required features of the HTTP/1.1 protocol, as described in RFC 2616, including persistent connections, pipelining, expectations and chunked encoding. If the client (typically a browser) supports only HTTP/1.0, the Connector will gracefully fall back to supporting this protocol as well. No special configuration is required to enable this support. The Connector also supports HTTP/1.0 keep-alive.
RFC 2616 requires that HTTP servers always begin their responses with the highest HTTP version that they claim to support. Therefore, this Connector will always return HTTP/1.1 at the beginning of its responses.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;为什么有的接口不报错&#34;&gt;为什么有的接口不报错?&lt;/h2&gt;
&lt;p&gt;在此之前，先思考一个问题：http协议是基于tcp的，tcp本身不处理数据包的边界，那客户端怎么做到恰到好处地读取数据？&lt;/p&gt;
&lt;p&gt;无外乎两种方案：1. 在报文中，先声明数据大小，客户端读满为止；2.约定一个边界，客户端看到这个记号再停。&lt;/p&gt;
&lt;p&gt;HTTP/1.0中，采用第一种方案，在HTTP头部利用 “Content-Length”声明http body的长度;&lt;/p&gt;
&lt;p&gt;HTTP/1.1协议引入 &amp;ldquo;Transfer-Encoding: chunked&amp;rdquo;头。浏览器不需要等到内容字节全部下载完成,只要接收到一个chunked块就可解析页面。这种情况下，每个chunk块之前会声明chunk大小，之后有分隔符。&lt;/p&gt;
&lt;p&gt;有了这些思考，再用wireshark来分析HTTP/1.0请求的返回报文。正常接口返回的TCP报文，虽然HTTP头部没有声明Content-Length，但因为数据量大，被拆分为若干个Frame。报错接口返回的报文，数据量很小。&lt;/p&gt;
&lt;p&gt;我的推测是：虽然它们都没有显式声明大小或者边界，但是当数据量大到被拆分为多个Frame时，客户端能基于Frame解析出来。&lt;/p&gt;</description></item><item><title>分布式追踪系统之我见</title><link>https://blog.yuantops.com/tech/thoughts_on_distributed_tracing_system/</link><pubDate>Wed, 31 Mar 2021 10:47:57 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/thoughts_on_distributed_tracing_system/</guid><description>
&lt;h2 id=&#34;一切的开始&#34;&gt;一切的开始&lt;/h2&gt;
&lt;p&gt;古早的时候，没人需要分布式追踪系统。大家系统架构简单，功能直来直去，有问题就看日志、查问题。&lt;/p&gt;
&lt;p&gt;后来，微服务流行起来。之前的模式，被称作“单体架构”。微服务粒度更小了，以前一个接口做的事，现在要拆散成很多部分，再通过相互调用组合到一起。系统更瘦了，但是管理起来更难了。&lt;/p&gt;
&lt;p&gt;当我有 10 个微服务时，出了故障还可以排查。如果有成千上万个微服务呢？随着时间发展，微服务之间的依赖会越来越复杂，一个接口背后可能是几十上百个微服务调用，没人能搞懂了。&lt;/p&gt;
&lt;p&gt;大家意识到，需要一个能展示整条调用链路情况的辅助系统。&lt;/p&gt;
&lt;h2 id=&#34;google-dapper&#34;&gt;Google Dapper&lt;/h2&gt;
&lt;p&gt;这时候，Google 公开了一篇论文 &lt;a href=&#34;https://research.google.com/archive/papers/dapper-2010-1.pdf&#34;&gt;Dapper - a Large-Scale Distributed Systems Tracing Infrastructure&lt;/a&gt;，介绍他们的分布式追踪技术。这篇文章提出了科学的分布式追踪模型，仿佛一盏指路明灯，此后几乎所有实现，都遵循这个模型。&lt;/p&gt;
&lt;p&gt;基于这篇论文，有了 Zipkin(Twitter 开源), 有了 OpenTracing。国内阿里鹰眼，也在概念上有借鉴。&lt;/p&gt;
&lt;h2 id=&#34;分布式追踪系统&#34;&gt;分布式追踪系统&lt;/h2&gt;
&lt;p&gt;一般而言，分布式追踪系统分为三部分，采集、上报、落盘与分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;采集: 对于已经存在大量系统，在代码中进行改造，工作量将相当可观，不现实。明智做法，是从中间件着手，力求侵入更小、开发者无感知。如果是 dubbo 调用，最合适是统一升级 dubbo jar 包。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上报：先把日志打印到本地，然后公共 agent 采集上报。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;落盘与存储：数据采集上来后，可以做很多事情。最简单的，放到 HBase + ElasticSearch，支持按 traceId 搜索。复杂点，接入流计算引擎，实时计算相关指标。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;我真的需要它吗&#34;&gt;我真的需要它吗&lt;/h2&gt;
&lt;p&gt;直说我的看法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果你的系统调用链深度顶多三层，依赖外部系统才一两个，常规日志监控手段足矣，分布式追踪系统并不是必须品。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果当前你的系统已经按微服务组织起来，但没有使用统一维护的中间件，那应该先改造现有系统，把中间件收敛起来，再统一升级。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;不错的参考资料&#34;&gt;不错的参考资料&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;阿里巴巴鹰眼技术解密 &lt;a href=&#34;https://www.cnblogs.com/gzxbkk/p/9600263.html&#34;&gt;https://www.cnblogs.com/gzxbkk/p/9600263.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分布式跟踪系统（一）：Zipkin的背景和设计 &lt;a href=&#34;https://blog.csdn.net/manzhizhen/article/details/52811600&#34;&gt;https://blog.csdn.net/manzhizhen/article/details/52811600&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>《宝刀》读后</title><link>https://blog.yuantops.com/opinions/2021-baodao-reading/</link><pubDate>Sat, 06 Feb 2021 12:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/2021-baodao-reading/</guid><description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/27039352/&#34;&gt;豆瓣链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;个人评分: 四星☆☆☆☆&lt;/li&gt;
&lt;li&gt;时间: &lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;&amp;lt;2021-02-06 Sat&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;刀不是刀光剑影江湖的刀，是藏（zang4）刀。因为一把好刀诞生，我、朋友、妻子、喇嘛舅舅、铁匠的旧生活发生了改变。&lt;/p&gt;
&lt;p&gt;这个故事说的是“改变”。这个故事通过一把刀引入很多戏剧性。朋友是个野心浪子，他促成剧情。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;朋友出现在小城，寻访刀&lt;/li&gt;
&lt;li&gt;梦中醒来，我脱口说出“刀”字&lt;/li&gt;
&lt;li&gt;喇嘛舅舅解梦&lt;/li&gt;
&lt;li&gt;雷电，铁匠打刀。刀成，铁匠倒下&lt;/li&gt;
&lt;li&gt;舅舅离开。朋友带刀离开。与妻子离婚。铁匠儿子上门&lt;/li&gt;
&lt;li&gt;我离开，去寻找朋友&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;粗略地看，在改变这个主题上，有“时代”和“个人”两条线。&lt;/p&gt;
&lt;p&gt;“时代”线上，有舅舅和铁匠。雷电，劈坏了传说中的龙头，舅舅不再需要履行看守职责，云游四海。舅舅为什么离开？固然是因为尘缘已了，更深层的原因，却是口口相传的故事无人再信，故事里的守护者自然不必再存在。铁匠本是传统云游四方的手艺人，在那个时代，铁匠四处流浪，“播撒男欢女爱的种子”。现在，铁匠却要定居，打出好刀后，苦等儿子上门找他。对铁匠和舅舅而言，“又是一种生活开始了”。&lt;/p&gt;
&lt;p&gt;“个人”线上，有我、妻子和朋友。朋友本意是搜寻好刀（卖出好价钱），经历宝刀出世的传奇，朋友觉得自己成了英雄，这股狂热不可阻挡地征服了旧情人，“令她心动”。最后，妻子发现和我并不相爱，离婚决定离开这座小城，结束平淡的婚姻和爱情。朋友也走了，去大城市，要把刀卖出大价钱。如果你说这是女人爱坏男人的剧情，不算离谱。&lt;/p&gt;
&lt;p&gt;说说结局吧。朋友带着刀，消失在城市里。我去找他，向人描述他和他那把刀的种种传奇，没人在意——这种故事太多，令人麻木。英雄和传说，在城市的大海里湮灭。&lt;/p&gt;
&lt;p&gt;其中又有一种隐喻：传统的、过去的传奇，在现代的城市里，注定会消散得无影无踪；有人试图抓住一次奇迹，但注定不会成功，因为你不可能抓住一件过去的东西。&lt;/p&gt;</description></item><item><title>使用自定义 Classloader 加载类，利用反射创建实例时出现 NoSuchMethodException</title><link>https://blog.yuantops.com/tech/nosuchmethodexception_when_using_classloader_and_reflection/</link><pubDate>Fri, 08 Jan 2021 17:33:57 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/nosuchmethodexception_when_using_classloader_and_reflection/</guid><description>
&lt;p&gt;最近在做一个需求，需要在程序运行时, 从当前 classpath 之外的指定路径加载(已经编译好的)类，并创建它的实例对象。&lt;/p&gt;
&lt;p&gt;在程序运行时改变程序结构，本是动态语言的技能点，不是 Java 的强项。但借助 Java 语言 &lt;code&gt;JavaCompiler&lt;/code&gt; 与 &lt;code&gt;反射&lt;/code&gt; 等动态相关特性，也能勉强做到。 好在就这个需求而言，我们拿到的是编译好的 &lt;code&gt;.class&lt;/code&gt; ，不需要编译开始从头做起。&lt;/p&gt;
&lt;p&gt;所以我们就从类的动态加载出发，开始做了。 下面是实施步骤，以及遇到的问题。&lt;/p&gt;
&lt;h2 id=&#34;步骤&#34;&gt;步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;我们使用了 Github 上一个可以动态加载 Maven 类的依赖库: &lt;a href=&#34;https://github.com/nanosai/modrun&#34;&gt;ModRun&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;将要加载的类所在 jar 包，连同它依赖的 jar 包，按 maven repository 目录结构放置。得到 ModRun 的一个 moduleClassloader。&lt;/li&gt;
&lt;li&gt;用 moduleClassLoader 加载类，得到 Class &lt;code&gt;clazz&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;使用反射，调用 &lt;code&gt;clazz.getDeclaredConstructor(xxxType1.class, xxxType2.class)&lt;/code&gt; ，得到构建函数。&lt;/li&gt;
&lt;li&gt;构建函数调用 &lt;code&gt;invoke()&lt;/code&gt;, 传入参数，预期得到所需要的对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;p&gt;进行到第 4 步，会报错，提示没有对应的构造函数。但肉眼看上去，同样签名的构造函数明明存在。何故？&lt;/p&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;在 StackOverflow 搜到答案: &lt;a href=&#34;https://stackoverflow.com/questions/2999824/classcastexception-when-creating-an-instance-of-a-class-using-reflection-and-cla&#34;&gt;StackOverflow 网友回答&lt;/a&gt; 。网友回复道: Since class objects depend on the actual class &lt;strong&gt;AND&lt;/strong&gt; on the classloader, they are really different classes。&lt;/p&gt;
&lt;p&gt;用 IDEA 断点调试，观察报错点，查看第 4 步入参的 classloader，与 clazz 的 classloader 确实不一样。如果改为传入 moduleClassLoader 加载的类，报错会消失，走到第 5 步；第 5 步会报错: object is not an instance of declaring class&lt;/p&gt;
&lt;p&gt;原因不变，还是因为传入的对象，与调用者不属于同一个 classloader，虽然类名相同，也是不同类。&lt;/p&gt;
&lt;h2 id=&#34;解决方法&#34;&gt;解决方法&lt;/h2&gt;
&lt;p&gt;放弃使用 ModRun ，用自定义的 ClassLoader 替代。在实现这个 ClassLoader 时，要将当前使用的 ClassLoader 设置为 parent。依据双亲委托机制，这样满足可见性原则。可以参考 &lt;a href=&#34;https://github.com/eclipse-vertx/vert.x/blob/master/src/main/java/io/vertx/core/impl/IsolatingClassLoader.java&#34;&gt;IsolatingClassLoader.java&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;java-类加载机制三大原则&#34;&gt;Java 类加载机制三大原则&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;委托原则： 如果一个类还没有被加载，类加载器会委托它的父加载器去加载它。&lt;/li&gt;
&lt;li&gt;可见性原则: 被父亲类加载器加载的类对于孩子加载器是可见的，但关系相反相反则不可见。&lt;/li&gt;
&lt;li&gt;独特性原则: 当一个类加载器加载一个类时，它的孩子加载器绝不会重新加载这个类。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Java 类加载器（ ClassLoader）浅析: &lt;a href=&#34;https://blog.csdn.net/BIAOBIAOqi/article/details/6864567&#34;&gt;https://blog.csdn.net/BIAOBIAOqi/article/details/6864567&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Class Loaders in Java: &lt;a href=&#34;https://www.baeldung.com/java-classloaders&#34;&gt;https://www.baeldung.com/java-classloaders&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Java 使用指定 classloader 创建 class</title><link>https://blog.yuantops.com/tech/define_class_with_custom_classloader/</link><pubDate>Wed, 06 Jan 2021 11:11:24 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/define_class_with_custom_classloader/</guid><description>&lt;p&gt;有时需要在程序运行时动态创建 Java 类（加载自定义文件，或者是加载 Javassist 之类字节码增强工具创建出来的字节码等）。要注意的是，不同类加载器加载的类，彼此是不可见的，也就不能直接实例化。&lt;/p&gt;
&lt;p&gt;要突破这个限制，需要一点 hack: 利用反射机制，在根据字节码创建类时，指定 classloader。下面的代码从著名的 &lt;code&gt;jodd&lt;/code&gt; 库摘录，请自行学习。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* Defines a class from byte array into the specified class loader.
* Warning: this is a &amp;lt;b&amp;gt;hack&amp;lt;/b&amp;gt;!
* @param className optional class name, may be &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt;
* @param classData bytecode data
* @param classLoader classloader that will load class
*/
public static Class defineClass(final String className, final byte[] classData, ClassLoader classLoader) {
if (classLoader == null) {
classLoader = Thread.currentThread().getContextClassLoader();
}
try {
final Method defineClassMethod = ClassLoader.class.getDeclaredMethod(&amp;quot;defineClass&amp;quot;, String.class, byte[].class, int.class, int.class);
defineClassMethod.setAccessible(true);
return (Class) defineClassMethod.invoke(classLoader, className, classData, 0, classData.length);
} catch (Throwable th) {
throw new RuntimeException(&amp;quot;Define class failed: &amp;quot; + className, th);
}
}
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>关于连接池大小</title><link>https://blog.yuantops.com/tech/about_pool_sizing/</link><pubDate>Wed, 09 Dec 2020 16:46:26 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/about_pool_sizing/</guid><description>
&lt;p&gt;这篇文章讲得很好，值得一读:&lt;/p&gt;
&lt;h2 id=&#34;about-pool-sizing&#34;&gt;About Pool Sizing&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing&#34;&gt;https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;综合CPU核数，磁盘IO，网络状况，得到一个经验公式:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;connections = ((core_count * 2) + effective_spindle_count)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;A formula which has held up pretty well across a lot of benchmarks for years is
that for optimal throughput the number of active connections should be somewhere
near ((core_count * 2) + effective_spindle_count). Core count should not include
HT threads, even if hyperthreading is enabled. Effective spindle count is zero if
the active data set is fully cached, and approaches the actual number of spindles
as the cache hit rate falls. ... There hasn&#39;t been any analysis so far regarding
how well the formula works with SSDs.
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>artifact存在, 但maven报错: Could not resolve artifact</title><link>https://blog.yuantops.com/tech/maven_cannot_resolve_local_artifact_error/</link><pubDate>Wed, 09 Dec 2020 16:33:48 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/maven_cannot_resolve_local_artifact_error/</guid><description>
&lt;p&gt;如果你遇到这个问题，而local repository里jar确实存在，一定看一眼你使用的maven版本：你可能遇到maven 3的一个坑。&lt;/p&gt;
&lt;p&gt;简而言之，maven3 开始验证本地仓库jar包的repository_id。&lt;/p&gt;
&lt;h2 id=&#34;原因&#34;&gt;原因&lt;/h2&gt;
&lt;p&gt;从maven3开始，从远程仓库下载jar包时，会在jar文件旁边生成一个`_maven.repositories`文件，文件里写明它来自哪个repository。&lt;/p&gt;
&lt;p&gt;如果当前项目的effective pom(`mvn &lt;effective-pom&gt;` 查看)里，生效的repository列表不包含这个jar包的repository_id，就会 &lt;strong&gt;报错&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;解决办法&#34;&gt;解决办法&lt;/h2&gt;
&lt;p&gt;简单粗暴: 把`_maven.repositories`全删掉&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;find ~/.m2/repository -name _maven.repositories -exec rm -v {} \;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;参考 &lt;a href=&#34;https://stackoverflow.com/questions/16866978/maven-cant-find-my-local-artifacts&#34;&gt;StackOverflow网友回答&lt;/a&gt; 。&lt;/p&gt;</description></item><item><title>手工验证一张数字证书的有效性</title><link>https://blog.yuantops.com/tech/validate_a_digital_certificate_step_by_step/</link><pubDate>Sun, 06 Dec 2020 12:17:47 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/validate_a_digital_certificate_step_by_step/</guid><description>
&lt;p&gt;上一篇 &lt;a href=&#34;https://blog.yuantops.com/tech/how%5Fdo%5Fweb%5Fbroswer%5Fvalidate%5Fssl%5Fcertificates/&#34;&gt;博客&lt;/a&gt; 讨论浏览器验证数字证书的流程。这篇文章更深入一步，用原始方法一步步手工验证证书的合法性。本文主要参考: &lt;a href=&#34;https://security.stackexchange.com/questions/127095/manually-walking-through-the-signature-validation-of-a-certificate&#34;&gt;回答&lt;/a&gt; 与 &lt;a href=&#34;https://segmentfault.com/a/1190000019008423&#34;&gt;X.509、PKCS文件格式介绍&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;基础名词&#34;&gt;基础名词&lt;/h2&gt;
&lt;h3 id=&#34;asn-dot-1-der与pem&#34;&gt;ASN.1, DER与PEM&lt;/h3&gt;
&lt;p&gt;ASN.1是一种接口描述语言，它用来定义一种数据结构。&lt;/p&gt;
&lt;p&gt;DER是一种编码规则，它用二进制表示ASN.1定义的数据。很多密码学标准使用ASN.1定义数据结构，用DER编码。&lt;/p&gt;
&lt;p&gt;但因为DER的内容是二进制的，不方便传输，人们对DER二进制内容进行Base64编码，将其转换为ASCII码，并在头和尾加上标签，就是PEM格式。PEM全称Privacy-Enhanced Mail，起初是为了便于邮件传输，后来在很多场景得到广泛应用。&lt;/p&gt;
&lt;h3 id=&#34;x-dot-509&#34;&gt;X.509&lt;/h3&gt;
&lt;p&gt;X.509是RFC5280定义的一种公钥证书格式(public key certificate)。X.509证书也被称为数字Digital Certificate。一张X.509包含一个Public Key和一个身份信息。X.509证书要么是自签发，要么是被CA签发。&lt;/p&gt;
&lt;h2 id=&#34;如何得到一张证书&#34;&gt;如何得到一张证书&lt;/h2&gt;
&lt;p&gt;借助浏览器，可以方便导出数字证书。&lt;/p&gt;
&lt;p&gt;打开chrome，访问本博客网址(&lt;a href=&#34;https://blog.yuantops.com&#34;&gt;https://blog.yuantops.com&lt;/a&gt;)，地址栏最左侧有个小锁图案 —— 这是网站受到HTTPS加密保护的标志。&lt;/p&gt;
&lt;p&gt;在&amp;rdquo;Details&amp;rdquo;标签，观察&amp;rdquo;Certificate Subject Alternative Name&amp;rdquo;字段，值包含&amp;rdquo;DNS Name: yuantops.com&amp;rdquo; &amp;ldquo;DNS　Name: *.yuantops.com&amp;rdquo;，说明证书的确属于这个域名。&lt;/p&gt;
&lt;p&gt;点击小锁　-&amp;gt; &amp;ldquo;certificate&amp;rdquo; -&amp;gt; &amp;ldquo;Details&amp;rdquo; -&amp;gt; &amp;ldquo;Export&amp;hellip;&amp;ldquo;，可以选择证书的导出格式。&lt;/p&gt;
&lt;p&gt;选择&amp;rdquo;Base64-encoded ASCII, single certificate&amp;rdquo;，得到一张PEM格式证书。将它保存为`sni.cloudflaressl.com`。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;-----BEGIN CERTIFICATE-----
MIIEwzCCBGmgAwIBAgIQDVZy4W9/IjNEOZEGQ2ADTjAKBggqhkjOPQQDAjBKMQsw
CQYDVQQGEwJVUzEZMBcGA1UEChMQQ2xvdWRmbGFyZSwgSW5jLjEgMB4GA1UEAxMX
Q2xvdWRmbGFyZSBJbmMgRUNDIENBLTMwHhcNMjAwODA3MDAwMDAwWhcNMjEwODA3
MTIwMDAwWjBtMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDVNh
biBGcmFuY2lzY28xGTAXBgNVBAoTEENsb3VkZmxhcmUsIEluYy4xHjAcBgNVBAMT
FXNuaS5jbG91ZGZsYXJlc3NsLmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IA
BCh3/Sz4YWHFP32cBLzErjTKy4/AdFKU37wFK8kzP7sdhM3/BxdJNKeRYNwcDimw
k76zgHaaGki0AzvCTMa+llWjggMMMIIDCDAfBgNVHSMEGDAWgBSlzjfq67B1DpRn
iLRF+tkkEIeWHzAdBgNVHQ4EFgQUi9pqgIAX5apgTXwOGZ9k1FALDL0wPgYDVR0R
BDcwNYIOKi55dWFudG9wcy5jb22CFXNuaS5jbG91ZGZsYXJlc3NsLmNvbYIMeXVh
bnRvcHMuY29tMA4GA1UdDwEB/wQEAwIHgDAdBgNVHSUEFjAUBggrBgEFBQcDAQYI
KwYBBQUHAwIwewYDVR0fBHQwcjA3oDWgM4YxaHR0cDovL2NybDMuZGlnaWNlcnQu
Y29tL0Nsb3VkZmxhcmVJbmNFQ0NDQS0zLmNybDA3oDWgM4YxaHR0cDovL2NybDQu
ZGlnaWNlcnQuY29tL0Nsb3VkZmxhcmVJbmNFQ0NDQS0zLmNybDBMBgNVHSAERTBD
MDcGCWCGSAGG/WwBATAqMCgGCCsGAQUFBwIBFhxodHRwczovL3d3dy5kaWdpY2Vy
dC5jb20vQ1BTMAgGBmeBDAECAjB2BggrBgEFBQcBAQRqMGgwJAYIKwYBBQUHMAGG
GGh0dHA6Ly9vY3NwLmRpZ2ljZXJ0LmNvbTBABggrBgEFBQcwAoY0aHR0cDovL2Nh
Y2VydHMuZGlnaWNlcnQuY29tL0Nsb3VkZmxhcmVJbmNFQ0NDQS0zLmNydDAMBgNV
HRMBAf8EAjAAMIIBBAYKKwYBBAHWeQIEAgSB9QSB8gDwAHYA9lyUL9F3MCIUVBgI
MJRWjuNNExkzv98MLyALzE7xZOMAAAFzyS9NoAAABAMARzBFAiB5au5KCRfkyBcI
7jECy/NvNPkKEoMUUTwZP+rZbHtn8AIhAKOR2Lh2zsCw+gy38abKie1fyd1rmm0c
GA/pP6PykChvAHYAXNxDkv7mq0VEsV6a1FbmEDf71fpH3KFzlLJe5vbHDsoAAAFz
yS9N0wAABAMARzBFAiALkQMvm51FKVO2JRFiWWEgqu4x9rGHy2JH6P2m18lrLQIh
AN1PcRtCiY+gihkncncx18OZM6e5CGZruk05EDGThLTvMAoGCCqGSM49BAMCA0gA
MEUCIHXeLOwERMHY88NliKhUzs1MwoJap9sNm9qQLGXYCpEMAiEA1ZsGvWxusXK9
tAgwUjlWi5Ke5rvM/i01sYl6bpls4Z0=
-----END CERTIFICATE-----
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;分析证书结构&#34;&gt;分析证书结构&lt;/h2&gt;
&lt;p&gt;RFC5280规定了X.509证书的语法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Certificate ::= SEQUENCE {
tbsCertificate TBSCertificate,
signatureAlgorithm AlgorithmIdentifier,
signatureValue BIT STRING }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据定义,证书由TBSCertificate, 签名算法，签名值三部分构成。 我们可以将它们分别提取出来。提取之前，先观察证书结构:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl asn1parse -i -in sni.cloudflaressl.com
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;选项解释&#34;&gt;选项解释&lt;/h4&gt;
&lt;p&gt;`-in filename`: 输入文件名&lt;/p&gt;
&lt;p&gt;`-i`: 标记实体，输出缩进标记，将一个ASN1实体下的其他对象缩进显示。此选项非默认选项，加上此选项后，显示更易看懂。&lt;/p&gt;
&lt;h4 id=&#34;输出&#34;&gt;输出&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt; 0:d=0 hl=4 l=1219 cons: SEQUENCE
4:d=1 hl=4 l=1129 cons: SEQUENCE
8:d=2 hl=2 l= 3 cons: cont [ 0 ]
10:d=3 hl=2 l= 1 prim: INTEGER :02
13:d=2 hl=2 l= 16 prim: INTEGER :0D5672E16F7F2233443991064360034E
31:d=2 hl=2 l= 10 cons: SEQUENCE
33:d=3 hl=2 l= 8 prim: OBJECT :ecdsa-with-SHA256
43:d=2 hl=2 l= 74 cons: SEQUENCE
45:d=3 hl=2 l= 11 cons: SET
47:d=4 hl=2 l= 9 cons: SEQUENCE
49:d=5 hl=2 l= 3 prim: OBJECT :countryName
54:d=5 hl=2 l= 2 prim: PRINTABLESTRING :US
58:d=3 hl=2 l= 25 cons: SET
60:d=4 hl=2 l= 23 cons: SEQUENCE
62:d=5 hl=2 l= 3 prim: OBJECT :organizationName
67:d=5 hl=2 l= 16 prim: PRINTABLESTRING :Cloudflare, Inc.
85:d=3 hl=2 l= 32 cons: SET
87:d=4 hl=2 l= 30 cons: SEQUENCE
89:d=5 hl=2 l= 3 prim: OBJECT :commonName
94:d=5 hl=2 l= 23 prim: PRINTABLESTRING :Cloudflare Inc ECC CA-3
119:d=2 hl=2 l= 30 cons: SEQUENCE
121:d=3 hl=2 l= 13 prim: UTCTIME :200807000000Z
136:d=3 hl=2 l= 13 prim: UTCTIME :210807120000Z
151:d=2 hl=2 l= 109 cons: SEQUENCE
153:d=3 hl=2 l= 11 cons: SET
155:d=4 hl=2 l= 9 cons: SEQUENCE
157:d=5 hl=2 l= 3 prim: OBJECT :countryName
162:d=5 hl=2 l= 2 prim: PRINTABLESTRING :US
166:d=3 hl=2 l= 11 cons: SET
168:d=4 hl=2 l= 9 cons: SEQUENCE
170:d=5 hl=2 l= 3 prim: OBJECT :stateOrProvinceName
175:d=5 hl=2 l= 2 prim: PRINTABLESTRING :CA
179:d=3 hl=2 l= 22 cons: SET
181:d=4 hl=2 l= 20 cons: SEQUENCE
183:d=5 hl=2 l= 3 prim: OBJECT :localityName
188:d=5 hl=2 l= 13 prim: PRINTABLESTRING :San Francisco
203:d=3 hl=2 l= 25 cons: SET
205:d=4 hl=2 l= 23 cons: SEQUENCE
207:d=5 hl=2 l= 3 prim: OBJECT :organizationName
212:d=5 hl=2 l= 16 prim: PRINTABLESTRING :Cloudflare, Inc.
230:d=3 hl=2 l= 30 cons: SET
232:d=4 hl=2 l= 28 cons: SEQUENCE
234:d=5 hl=2 l= 3 prim: OBJECT :commonName
239:d=5 hl=2 l= 21 prim: PRINTABLESTRING :sni.cloudflaressl.com
262:d=2 hl=2 l= 89 cons: SEQUENCE
264:d=3 hl=2 l= 19 cons: SEQUENCE
266:d=4 hl=2 l= 7 prim: OBJECT :id-ecPublicKey
275:d=4 hl=2 l= 8 prim: OBJECT :prime256v1
285:d=3 hl=2 l= 66 prim: BIT STRING
353:d=2 hl=4 l= 780 cons: cont [ 3 ]
357:d=3 hl=4 l= 776 cons: SEQUENCE
361:d=4 hl=2 l= 31 cons: SEQUENCE
363:d=5 hl=2 l= 3 prim: OBJECT :X509v3 Authority Key Identifier
368:d=5 hl=2 l= 24 prim: OCTET STRING [HEX DUMP]:30168014A5CE37EAEBB0750E946788B445FAD9241087961F
394:d=4 hl=2 l= 29 cons: SEQUENCE
396:d=5 hl=2 l= 3 prim: OBJECT :X509v3 Subject Key Identifier
401:d=5 hl=2 l= 22 prim: OCTET STRING [HEX DUMP]:04148BDA6A808017E5AA604D7C0E199F64D4500B0CBD
425:d=4 hl=2 l= 62 cons: SEQUENCE
427:d=5 hl=2 l= 3 prim: OBJECT :X509v3 Subject Alternative Name
432:d=5 hl=2 l= 55 prim: OCTET STRING [HEX DUMP]:3035820E2A2E7975616E746F70732E636F6D8215736E692E636C6F7564666C61726573736C2E636F6D820C7975616E746F70732E636F6D
489:d=4 hl=2 l= 14 cons: SEQUENCE
491:d=5 hl=2 l= 3 prim: OBJECT :X509v3 Key Usage
496:d=5 hl=2 l= 1 prim: BOOLEAN :255
499:d=5 hl=2 l= 4 prim: OCTET STRING [HEX DUMP]:03020780
505:d=4 hl=2 l= 29 cons: SEQUENCE
507:d=5 hl=2 l= 3 prim: OBJECT :X509v3 Extended Key Usage
512:d=5 hl=2 l= 22 prim: OCTET STRING [HEX DUMP]:301406082B0601050507030106082B06010505070302
536:d=4 hl=2 l= 123 cons: SEQUENCE
538:d=5 hl=2 l= 3 prim: OBJECT :X509v3 CRL Distribution Points
543:d=5 hl=2 l= 116 prim: OCTET STRING [HEX DUMP]:30723037A035A0338631687474703A2F2F63726C332E64696769636572742E636F6D2F436C6F7564666C617265496E6345434343412D332E63726C3037A035A0338631687474703A2F2F63726C342E64696769636572742E636F6D2F436C6F7564666C617265496E6345434343412D332E63726C
661:d=4 hl=2 l= 76 cons: SEQUENCE
663:d=5 hl=2 l= 3 prim: OBJECT :X509v3 Certificate Policies
668:d=5 hl=2 l= 69 prim: OCTET STRING [HEX DUMP]:3043303706096086480186FD6C0101302A302806082B06010505070201161C68747470733A2F2F7777772E64696769636572742E636F6D2F4350533008060667810C010202
739:d=4 hl=2 l= 118 cons: SEQUENCE
741:d=5 hl=2 l= 8 prim: OBJECT :Authority Information Access
751:d=5 hl=2 l= 106 prim: OCTET STRING [HEX DUMP]:3068302406082B060105050730018618687474703A2F2F6F6373702E64696769636572742E636F6D304006082B060105050730028634687474703A2F2F636163657274732E64696769636572742E636F6D2F436C6F7564666C617265496E6345434343412D332E637274
859:d=4 hl=2 l= 12 cons: SEQUENCE
861:d=5 hl=2 l= 3 prim: OBJECT :X509v3 Basic Constraints
866:d=5 hl=2 l= 1 prim: BOOLEAN :255
869:d=5 hl=2 l= 2 prim: OCTET STRING [HEX DUMP]:3000
873:d=4 hl=4 l= 260 cons: SEQUENCE
877:d=5 hl=2 l= 10 prim: OBJECT :CT Precertificate SCTs
889:d=5 hl=3 l= 245 prim: OCTET STRING [HEX DUMP]:0481F200F0007600F65C942FD1773022145418083094568EE34D131933BFDF0C2F200BCC4EF164E300000173C92F4DA000000403004730450220796AEE4A0917E4C81708EE3102CBF36F34F90A128314513C193FEAD96C7B67F0022100A391D8B876CEC0B0FA0CB7F1A6CA89ED5FC9DD6B9A6D1C180FE93FA3F290286F0076005CDC4392FEE6AB4544B15E9AD456E61037FBD5FA47DCA17394B25EE6F6C70ECA00000173C92F4DD3000004030047304502200B91032F9B9D452953B6251162596120AAEE31F6B187CB6247E8FDA6D7C96B2D022100DD4F711B42898FA08A1927727731D7C39933A7B908666BBA4D3910319384B4EF
1137:d=1 hl=2 l= 10 cons: SEQUENCE
1139:d=2 hl=2 l= 8 prim: OBJECT :ecdsa-with-SHA256
1149:d=1 hl=2 l= 72 prim: BIT STRING
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;输出格式解析&#34;&gt;输出格式解析&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;0:d=0 hl=4 l=1219 cons: SEQUENCE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;`0`: 表示节点在整个文件中的偏移长度
`d=0`: 表示节点深度
`hl=4`: 表示节点头字节长度
`l=1219`: 表示节点数据字节长度
`cons`: 表示该节点为结构节点，表示包含子节点或者子结构数据
`prim`: 表示该节点为原始节点，包含数据&lt;/p&gt;
&lt;h4 id=&#34;tbscertificate和signature位置&#34;&gt;tbsCertificate和signature位置&lt;/h4&gt;
&lt;p&gt;观察可知，tbsCertificate的偏移位置是4, 签名值signatureValue的偏移位置是1137。&lt;/p&gt;
&lt;h2 id=&#34;提取tbscertificate&#34;&gt;提取tbsCertificate&lt;/h2&gt;
&lt;p&gt;引用RFC5280 4.1.1.3:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The signatureValue field contains a digital signature computed upon
the ASN.1 DER encoded tbsCertificate. The ASN.1 DER encoded
tbsCertificate is used as the input to the signature function.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据上述定义，计算签名的输入是DER编码的tbsCertificate。而我们从浏览器导出的证书是PEM格式，需要使用openssl将其转化为DER格式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;openssl x509 -in sni.cloudflaressl.com -inform PEM -out sni.cloudflaressl.com.der -outform DER
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，我们从DER证书中提取tbsCertificate。 根据asn1parse输出结果第二行，tbsCertificate偏移位置是4, 大小是1133 = ４(头部长度) + 1129(数据长度)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;4:d=1 hl=4 l=1129 cons: SEQUENCE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用`dd` 按偏移位置截取。输出内容保存到`yuantops.tbs`。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;dd if=sni.cloudflaressl.com.der of=yuantops.tbs skip=4 bs=1 count=1133
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;提取signaturevalue&#34;&gt;提取signatureValue&lt;/h2&gt;
&lt;p&gt;根据asn1parse输出结果末尾一行:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;1149:d=1 hl=2 l= 72 prim: BIT STRING
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;signatureValue偏移量是1137。如果直接使用`dd`截取，将得到`BIT STRING`编码后的签名值，不能直接使用。需要用`ans1parse`的`-strparse`选项，将其转换为二进制数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;openssl asn1parse -in sni.cloudflaressl.com -strparse 1137 -out cloudflaressl.sig
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;签名数据保存在cloudflaressl.sig文件。&lt;/p&gt;
&lt;h4 id=&#34;选项解释-1&#34;&gt;选项解释&lt;/h4&gt;
&lt;p&gt;`-in filename` ：输入文件名，默认为标准输入。&lt;/p&gt;
&lt;p&gt;`-offset number`：开始数据分析的字节偏移量，分析数据时，不一定从头开始分析，可用指定偏移量，默认从头开始分析。&lt;/p&gt;
&lt;p&gt;`-strparse offset`：此选项也用于从一个偏移量开始来分析数据，不过，与-offset不一样。-offset分析偏移量之后的所有数据，而-strparse只用于分析一段数据，并且这种数据必须是SET或者SEQUENCE，它只分析本SET或者SEQUENCE范围的数据。&lt;/p&gt;
&lt;h4 id=&#34;查看提取的签名是否正确&#34;&gt;查看提取的签名是否正确&lt;/h4&gt;
&lt;p&gt;使用`od`命令，以16进制打印签名文件内容:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;`od -tx1 cloudflaressl.sig`
0000000 30 45 02 20 75 de 2c ec 04 44 c1 d8 f3 c3 65 88
0000020 a8 54 ce cd 4c c2 82 5a a7 db 0d 9b da 90 2c 65
0000040 d8 0a 91 0c 02 21 00 d5 9b 06 bd 6c 6e b1 72 bd
0000060 b4 08 30 52 39 56 8b 92 9e e6 bb cc fe 2d 35 b1
0000100 89 7a 6e 99 6c e1 9d
0000107
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与浏览器Certificate Viewer中看到的证书`SignatureValue`对比，二者应该相同。&lt;/p&gt;
&lt;p&gt;下一步，我们获取签发者的公钥。&lt;/p&gt;
&lt;h2 id=&#34;获取issuer公钥&#34;&gt;获取issuer公钥&lt;/h2&gt;
&lt;p&gt;在上一篇博客中提到，服务器返回给浏览器一组证书链。通过浏览器Certificate Viewer可以看到证书继承关系。 `sni.cloudflaressl.com`证书的签发者是`Cloudflare Inc ECC CA-3`。&lt;/p&gt;
&lt;p&gt;我们将其导出为文件，保存到本地，文件名为 `Cloudflare_Inc_ECC_CA-3`。&lt;/p&gt;
&lt;p&gt;从证书提取公钥:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;openssl x509 -in Cloudflare_Inc_ECC_CA-3 -noout -pubkey &amp;gt; Cloudflare_Inc_ECC_CA-3.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果想观察公钥内容，可以将其转换为PEM格式:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;openssl pkey -in Cloudflare_Inc_ECC_CA-3.pub -pubin -text
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEua1NZpkUC0bsH4HRKlAenQMVLzQS
fS2WuIg4m4Vfj7+7Te9hRsTJc9QkT+DuHM5ss1FxL2ruTAUJd9NyYqSb1w==
-----END PUBLIC KEY-----
Public-Key: (256 bit)
pub:
04:b9:ad:4d:66:99:14:0b:46:ec:1f:81:d1:2a:50:
1e:9d:03:15:2f:34:12:7d:2d:96:b8:88:38:9b:85:
5f:8f:bf:bb:4d:ef:61:46:c4:c9:73:d4:24:4f:e0:
ee:1c:ce:6c:b3:51:71:2f:6a:ee:4c:05:09:77:d3:
72:62:a4:9b:d7
ASN1 OID: prime256v1
NIST CURVE: P-256
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;验证签名&#34;&gt;验证签名&lt;/h2&gt;
&lt;p&gt;回顾签名流程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成ASN.1 DER格式的tbsCertificate&lt;/li&gt;
&lt;li&gt;使用摘要算法，计算tbsCertificate摘要值&lt;/li&gt;
&lt;li&gt;签发者(issuer)使用自己的私钥，使用signatureAlgorithm对摘要进行签名，得到signatureValue&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对应地，我们的验证流程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提取提取ASN.1 DER格式的tbsCertificate&lt;/li&gt;
&lt;li&gt;使用摘要算法，计算tbsCertificate摘要值 hash1&lt;/li&gt;
&lt;li&gt;提取证书的SignatureValue&lt;/li&gt;
&lt;li&gt;使用签发者(issuer)公钥，证书的摘要值hash1，证书的signatureValue，进行RSA签名认证。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以使用`openssl` 命令, 将｀2｀ `3` `4` 合成一步：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;openssl sha256 &amp;lt;yuantops.tbs -verify Cloudflare_Inc_ECC_CA-3.pub -signature cloudflaressl.sig
Verified OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者，将`3` `4` 合成一步：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;openssl sha256 &amp;lt;yuantops.tbs -binary &amp;gt;hash
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;openssl pkeyutl -verify -in hash -sigfile cloudflaressl.sig -inkey Cloudflare_Inc_ECC_CA-3.pub -pubin -pkeyopt digest:sha256
Signature Verified Successfully
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到此，证书签名验证结束。&lt;/p&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他　&lt;/h2&gt;
&lt;h3 id=&#34;为什么x509证书中-signaturevalue要进行bit-string编码&#34;&gt;为什么x509证书中，signatureValue要进行bit string编码?&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://crypto.stackexchange.com/questions/55574/why-is-the-signature-field-in-x-509-a-bit-string-despite-there-being-asn-1-der&#34;&gt;https://crypto.stackexchange.com/questions/55574/why-is-the-signature-field-in-x-509-a-bit-string-despite-there-being-asn-1-der&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://security.stackexchange.com/questions/161982/asn-1-encapsulated-bitstring-type-in-openssl&#34;&gt;https://security.stackexchange.com/questions/161982/asn-1-encapsulated-bitstring-type-in-openssl&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;为什么不解密signaturevalue-将得到的hash值与tbscertificate的hash值比较&#34;&gt;为什么不解密SignatureValue，将得到的hash值与tbsCertificate的hash值比较?&lt;/h3&gt;
&lt;p&gt;这一点上，我还没有特别明白。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://yongbingchen.github.io/blog/2015/04/09/verify-the-signature-of-a-x-dot-509-certificate/&#34;&gt;这篇文章&lt;/a&gt;　完全没有用到openssl验证签名，他手动用公钥解出了signature对应的hash值。&lt;/p&gt;
&lt;p&gt;但是，我Google公钥解密签名的方法，回答都说不能 &lt;strong&gt;解密*，只能 *验证&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;知乎问题　&lt;a href=&#34;https://www.zhihu.com/question/25912483&#34;&gt;RSA的公钥和私钥到底哪个才是用来加密和哪个用来解密？&lt;/a&gt; 下面 刘巍然的回答 详细论述了RSA加解密算法和签名体制的区别，他说道:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在签名算法中，私钥用于对数据进行签名，公钥用于对签名进行验证。这也可以直观地进行理解：对一个文件签名，当然要用私钥，因为我们希望只有自己才能完成签字。验证过程当然希望所有人都能够执行，大家看到签名都能通过验证证明确实是我自己签的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看来，似乎确实不能根据公钥对签名进行 &lt;strong&gt;解密&lt;/strong&gt;?&lt;/p&gt;</description></item><item><title>浏览器验证SSL数字证书的步骤</title><link>https://blog.yuantops.com/tech/how_do_web_broswer_validate_ssl_certificates/</link><pubDate>Tue, 24 Nov 2020 09:07:26 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/how_do_web_broswer_validate_ssl_certificates/</guid><description>
&lt;p&gt;浏览器和服务器使用SSL/TLS通信时，双方首先要通过几次握手(Handshake)，建立加密信道。简单说来，分为下面３步:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务器发送自己的SSL证书；&lt;/li&gt;
&lt;li&gt;浏览器验证服务器SSL证书；&lt;/li&gt;
&lt;li&gt;证书验证成功，双方协商得到对称加密密钥，并交换。双方拿到对称加密密钥后，后续的通信都会用它做对称加密。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文介绍的重点，在前２步。首先，转载一篇国外博客，讲述浏览器检查证书的过程；其次，会引述两个RFC协议的相关内容；最后，wireshark抓包进行验证。&lt;/p&gt;
&lt;h2 id=&#34;browsers-and-certificate-validation&#34;&gt;Browsers and Certificate Validation&lt;/h2&gt;
&lt;p&gt;原文地址: &lt;a href=&#34;https://www.ssl.com/article/browsers-and-certificate-validation/&#34;&gt;https://www.ssl.com/article/browsers-and-certificate-validation/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;a href=&#34;https://www.deepl.com/en/translator&#34;&gt;DeepL&lt;/a&gt; 翻译成中文，如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;## 证书和X.509格式
证书在各方面都是数字文件，这意味着它们需要遵循一种文件格式来存储信息（如签名、密钥、签发人等）。虽然私有的PKI配置可以为其证书实现任何格式，但公共信任的PKIs（即那些被浏览器信任的PKIs）必须符合RFC 5280，这就要求使用X.509 v3格式。
X.509 v3允许证书包含额外的数据，如使用限制或策略信息，作为扩展，每个扩展都是关键或非关键的。浏览器可以忽略无效的或未被识别的非关键扩展，但它们必须处理和验证所有关键扩展。
## 认证路径和路径处理
憑證機構使用私人密碼匙對所有簽發的證書進行加密簽署。这种签名可以不可撤销地证明证书是由某一特定的核证机 构签发的，而且在签署后没有被修改。
CA通过持有相应公钥的自发证书（称为根）来建立其签名密钥的所有权。憑證機構必須遵守嚴格的控制和審核程序來建立、管理和使用根證書，為了減少暴露，通常會使用根證書來簽發中間證書。这些中间证书可以用来签发客户的证书。
浏览器在出厂时都有一个内置的可信根列表。(这些根是来自通过浏览器严格标准的CA的根。) 为了验证证书，浏览器将获得一个证书序列，每个证书都签署了序列中的下一个证书，将签名CA的根与服务器的证书连接起来。
这个证书序列称为认证路径。路径的根部称为信任锚，服务器的证书称为叶子或终端实体证书。
### 路径的构造
通常情况下，浏览器必须考虑多个认证路径，直到他们能够为给定证书找到一个有效的路径。即使一个路径可能包含的证书可以正确地 &amp;quot;链 &amp;quot;到一个已知的锚，但由于路径长度、域名、证书使用或政策的限制，路径本身可能会被拒绝。
对于浏览器遇到的每一个新证书，构建和评估所有可能的路径都是一个昂贵的过程。浏览器已经实现了各种优化，以减少被拒绝的候选路径的数量，但深入探讨这些细节已经超出了本文的范围。
### 路径验证
候选认证路径构建完成后，浏览器使用证书中包含的信息对其进行验证。如果浏览器能够通过密码学的方式证明，从一个信任锚直接签署的证书开始，每个证书对应的私钥都被用来签发路径中的下一个证书，一直到叶子证书，那么这个路径就是有效的。
## 认证路径验证算法
RFC 5280描述了浏览器验证X.509证书认证路径的标准算法。
基本上，浏览器从信任锚（即根证书）开始，遍历路径中的所有证书，验证每张证书的基本信息和关键扩展。
如果该过程以路径中的最后一张证书结束，没有错误，那么该路径被接受为有效。如果产生错误，则该路径被标记为无效。
### 证书的基本处理
无论是否有任何扩展，浏览器必须始终验证基本的证书信息，如签名或签发人。下面的章节显示了浏览器执行检查的顺序。
1. 浏览器验证证书的完整性
证书上的签名可以用正常的公用钥匙加密法进行验证。如果签名无效，则认为该证书在签发后被修改，因此被拒绝。
2. 浏览器验证证书的有效性：
證書的有效期是指簽署憑證機構保證會維持其狀態資訊的時間間隔。浏览器会拒绝任何有效期在验证检查日期和时间之前或之后开始的证书。
3. 浏览器检查证书的撤销状态。
证书签发后，应该在整个有效期内使用。当然，在各种情况下，证书可能会在自然到期前失效。
这类情况可能包括主体改名或怀疑私钥泄露。在这样的情况下，CA需要撤销相应的证书，而用户也信任CA会通知浏览器其证书的撤销状态。
RFC 5280建议CA使用撤销列表来实现这一目的。
证书废止列表(CRL)
核證機關會定期發出一份經簽署、有時間標記的廢止證書清單，稱為證書廢止清單（CRL）。CRL分布在公开的存储库中，浏览器在验证证书时可以获得并查阅CA的最新CRL。
这种方法的一个缺陷是，撤销的时间粒度仅限于CRL的发布期。只有在所有当前已发布的CRL都被安排更新后，浏览器才会收到撤销的通知。根据签名CA的政策，这可能需要一个小时、一天甚至一周的时间。
在线证书状态协议(OCSP)
还有其他的方法来获取废止状态信息，其中最流行的是在线证书状态协议（OCSP）。
OCSP在标准文档RFC6960中进行了描述，它允许浏览器从在线OCSP服务器（也称为回复者）请求特定证书的撤销状态。如果配置得当，OCSP的即时性更强，而且避免了上面提到的CRL更新延迟问题。此外，OCSP Stapling还能提高性能和速度。
4. 浏览器验证发件人
证书通常与两个实体相关联。
签发人，也就是拥有签名密钥的实体，以及
主体，指的是证书认证的公钥的所有者。
浏览器会检查证书的签发人字段是否与路径中前一个证书的主题字段相同。为了增加安全性，大多数PKI实现也会验证发证者的密钥是否与签署当前证书的密钥相同。(请注意，这对于信任锚来说并不正确，因为根是自发的--即它们具有相同的签发人和主体)。
约束处理
X.509 v3格式允许CA定义约束或限制每个证书如何被验证和作为关键扩展使用。路径中的每张证书都可以施加额外的约束，所有后续证书都必须遵守。
证书约束很少影响普通互联网用户，尽管它们在企业SSL解决方案中相当常见。功能性约束可以达到多种操作目的，但其最重要的用途是缓解已知的安全问题。
5. 浏览器检查名称约束
具有适当名称限制的私有(但公众信任的)中间CA可以为组织提供对证书管理和签发的精细控制。证书可以被限制在一个公司或组织的域名的特定域或域树（即包括子域）。名称限制通常用于从公开信任的CA购买的中间CA证书，以防止中间CA为第三方域（如google.com）签发完全有效的证书。
6. 浏览器检查策略约束
證書政策是由核證機關所發表的法律文件，正式詳述其簽發及管理證書的程序。憑證機構可以根據一項或多項政策簽發證書，而每張證書都有這些政策的連結，以便信賴者在決定信任該證書前，可以評估這些政策。
出于法律和操作上的原因，证书可以对证书的政策进行限制。如果发现证书中包含关键策略约束，浏览器必须在进行之前对其进行验证。(然而，关键策略约束在现实世界中很少遇到，所以本文其余部分将不予考虑)。
7. 浏览器检查基本约束（也就是路径长度）。
X.509 v3格式允许签发人定义证书所能支持的最大路径长度。这提供了对每个证书在认证路径中可以放置多远的控制。这实际上是很重要的--浏览器曾经无视认证路径长度，直到一位研究人员在2009年的一次演讲中演示了他如何利用自己网站的叶子证书为一个大型电子商务网站伪造有效证书。
8. 浏览器验证密钥用途
钥匙用途 &amp;quot;扩展部分说明了证书中钥匙的用途，例如加密、签名、证书签名等。这些用途的例子包括加密、签名、证书签名等。浏览器会拒绝违反其密钥用途限制的证书，例如遇到服务器证书的密钥只用于CRL签名。
9. 浏览器继续处理所有剩余的关键扩展文件
浏览器在处理完上述扩展证书后，会继续验证当前证书指定为关键的所有剩余扩展证书，然后再进入下一个。如果浏览器到达一个路径的叶子证书时没有错误，那么该路径就会被接受为有效。如果产生任何错误，则路径被标记为无效，并且不能建立安全连接。
通过www.DeepL.com/Translator（免费版）翻译
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;两个重要rfc标准&#34;&gt;两个重要RFC标准&lt;/h2&gt;
&lt;h3 id=&#34;rfc-5280-pki-x-dot-509-v3规范&#34;&gt;[RFC 5280] PKI X.509 v3规范　&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc5280&#34;&gt;https://tools.ietf.org/html/rfc5280&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中，section-6 给出了证书validation算法。
第一部分的译文多次提到RFC 5820标准。这个标准定义了X.509格式，并给出了路径验证算法（section-6）。
在此，摘录关键部分:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;(a) for all x in {1, ..., n-1}, the subject of certificate x is
the issuer of certificate x+1;
(b) certificate 1 is issued by the trust anchor;
(c) certificate n is the certificate to be validated (i.e., the
target certificate); and
(d) for all x in {1, ..., n}, the certificate was valid at the
time in question
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据算法，第一个证书由trust anchor签发，下一个证书由这个证书签发……直到最后的叶子节点证书。这样由信任锚长出一个链条，一环扣一环，链条上每个节点都是可信的。&lt;/p&gt;
&lt;h3 id=&#34;rfc-5246-tls-1-dot-2规范&#34;&gt;[RFC 5246] TLS 1.2规范&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc5246&#34;&gt;https://tools.ietf.org/html/rfc5246&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中，section-7.4.2　规定，server要向client发送 &lt;em&gt;certificate_list&lt;/em&gt; 。服务器不是返回单独的某个证书，而是一个证书列表; 因为单独一个证书，没法形成certifate chain，也就无法完成validation: 这和[RFC 5280] 所述流程吻合。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;certificate_list
This is a sequence (chain) of certificates. The sender&#39;s
certificate MUST come first in the list. Each following
certificate MUST directly certify the one preceding it. Because
certificate validation requires that root keys be distributed
independently, the self-signed certificate that specifies the root
certificate authority MAY be omitted from the chain, under the
assumption that the remote end must already possess it in order to
validate it in any case.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里指定了证书的顺序，第一个是叶子证书。很好理解，因为重要数据在报文中的位置往往靠前。&lt;/p&gt;
&lt;h2 id=&#34;抓包看看&#34;&gt;抓包看看　&lt;/h2&gt;
&lt;p&gt;借助wireshark，我们实际操作一番。&lt;/p&gt;
&lt;p&gt;打开wireshark, 开始抓包，再访问百度官网(&lt;a href=&#34;https://www.baidu.com&#34;&gt;https://www.baidu.com&lt;/a&gt;)。抓包细节如下：　&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.yuantops.com/ox-hugo/ssl_certificate_wireshark.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description></item><item><title>怀念信息自由流动的博客时代</title><link>https://blog.yuantops.com/opinions/gone_are_the_days_of_blog/</link><pubDate>Wed, 26 Feb 2020 08:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/gone_are_the_days_of_blog/</guid><description>&lt;p&gt;因为新冠疫情，春节至今一直歪在家中，天天捧着手机。前几天一件小事，让我产生标题里的感慨。&lt;/p&gt;
&lt;p&gt;起因是这样。武汉封城近月余，城中情况如何，信息混杂得很，真假难以辨别。好几年前我已不用微博，现在信息源只剩豆瓣和虎扑，加上澎湃之类的新闻公众号。有一天，好几个公众号推送文章，主题是方方和她的“武汉日记”，说她仗义敢言，理性发声，“武汉日记”写得很好云云。方方是武汉本地作家，以前颇有耳闻她特立独行，于是起心找这一系列日记来读。　　&lt;/p&gt;
&lt;p&gt;在微信搜索框输入“方方”“武汉日记”“封城日记”，搜索结果都不是我想要的。绝大多数文章是对方方的赞扬，介绍她的背景、性格，然后顺带提到她的特殊创作——武汉日记。对方方本人的采访只有一两篇，其余几乎全是剪刀+浆糊生成，相似的结构、标题、样式……终于淘到一篇类似真身的“武汉日记”，看完却发现作者和方方本人八杆子打不着，应该是同名、抄袭或者不署名转载。这类爆款文章令人腻味。在微信找了一圈，无果。&lt;/p&gt;
&lt;p&gt;然后，尝试用百度搜索。百度搜索质量好不到哪里去，但翻了半天，好歹终于在一篇帖子里看到有人评论：公众号名字是“二湘的七维空间”。回到微信，果然就是它了。这个公众号作者依然不是方方本人，只是得到方方本人授权首发。整个搜索过程耗时将近半个小时。&lt;/p&gt;
&lt;p&gt;在微信世界里淘金不容易，此时我对“武汉日记”系列已兴趣大减。回想刚刚开始上大学时，大概10年11年，那时中文互联网不这样。那时是新浪博客、网易博客、各种博客的天下。那时，知道关键词就能用搜索引擎找到结果，点进去直接看原文。尤记得韩寒的《韩三篇》，当时掀起巨大争议，读者在博客下面评论，很热闹　——　绝对不需要像一个侦探一般四处勘探才看到内容。&lt;/p&gt;
&lt;p&gt;我认为，现在中文互联网环境恶化了，信息流动被人为阻碍了。腾讯的微信公众号、字节跳动的头条号、百度的百家号、新浪微博……互联网巨头的各种产品，携手筑起藩篱，阻碍信息的传播。一旦将内容视作资产，难免会引起各方争夺。伴随各种内容平台的兴起，博客时代落幕。凭借一串字母数字组成的URL，即可让信息在互联网上被任何人在任何地方自由访问，这是古老互联网时代的做法。开放、自由和分享的精神退去后，什么上场了？资本和权力。在我看来，事情没有变得更好。&lt;/p&gt;
&lt;p&gt;写下这篇博客，谨作缅怀 :-(&lt;/p&gt;</description></item><item><title>纪念李文亮医生</title><link>https://blog.yuantops.com/opinions/mourning-dr-liwenliang/</link><pubDate>Fri, 07 Feb 2020 08:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/mourning-dr-liwenliang/</guid><description>&lt;p&gt;2020年2月6日夜里，李文亮医生去世。我们的“吹哨者”走了。&lt;/p&gt;
&lt;p&gt;李医生是最先在微信群里提醒“疑似SARS疫情”、继而被武汉警方训诫、被各大媒体通报的8位“造谣者”之一。&lt;/p&gt;
&lt;p&gt;夜里在豆瓣上听闻噩耗，无比难过，更愤怒。我难过，因为李医生不过是个普通人，他在自己私人微信群里发言，没有违背任何法律，但却名声受损、最终没了命，留下孤儿寡母——对一个普通人，代价太大了。我愤怒，因为疫情失控到这步田地，证明李医生的警告是多么及时、正确，&amp;rdquo;训诫&amp;rdquo;是多么荒谬，却没有任何人道歉!&lt;/p&gt;
&lt;p&gt;到了半夜，豆瓣上纪念和怒火愈盛。过了凌晨十二点，居然刷到帖子“辟谣”(!)，说李文亮医生还在ICU抢救。忐忑之中怀着希望睡去。7号清早，看到武汉中心医院微博的声明截图，李文亮医生&amp;rdquo;于2020年2月7日凌晨2点58分去世&amp;rdquo;。再刷其他帖子，才明白这次“抢救”的奥妙：6号夜里人已宣告死亡，但不准停止“抢救”，ECMO哪怕过了几个小时也用上，一直拖到7号凌晨，这样就可宣布“抢救无效死亡”。这哪里是救人？分明是作秀，拿死人作道具，让人不齿，令人作呕。&lt;/p&gt;
&lt;p&gt;汹涌的愤怒是暂时，过一两天，舆论机器和“忘却的救主”合作，李医生的牺牲必然会被揩油、歪曲、诋毁，在纷争中走向湮灭。时间是记忆的敌人，给了他们篡改和掩埋的机会。所以我想，应该用一篇博客纪念李文亮医生，也提醒自己：在道歉之前，保持愤怒，不要忘记！&lt;/p&gt;</description></item><item><title>2020读书笔记</title><link>https://blog.yuantops.com/opinions/2020-my-reading/</link><pubDate>Thu, 06 Feb 2020 12:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/2020-my-reading/</guid><description>
&lt;h2 id=&#34;房奴&#34;&gt;房奴&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/33381271/&#34;&gt;豆瓣链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;个人评分: 四星☆☆☆☆&lt;/li&gt;
&lt;li&gt;时间: &lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;&amp;lt;2020-08-02 Sun&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在美国，几个普通人意外陷入断供危机（书中称为“止赎危机”），他们自救过程中，慢慢发现这是一场合谋：银行、证券公司、信托一起，用金融把戏堂而皇之将购房者推入陷阱。政府视而不见，法庭不明白其中诀窍，大众不理解甚至鄙视欠钱不还的行为。&lt;/p&gt;
&lt;p&gt;这本书主要将三个普通人与这架“止赎机器”抗争的故事。三人素不相识，在斗争过程中成为伙伴。他们查阅资料，恶补金融知识，研究整个链条上每个结点的作用，理解晦涩难懂的金融术语；翻看法条，寻找止赎案件漏洞；在博客上分享经验，帮助困友；发起线下聚会，扩大影响力……一场力量悬殊的较量，他们居然克服重重障碍，走得颇远：成功引起传统媒体注意，成立公益组织帮助了很多人，甚至推动了一些法案出台。&lt;/p&gt;
&lt;p&gt;故事没有戏剧性结局，止赎仍在发生，无人对这场公共政策的失败负责——就和社会上绝大多数矛盾一样，到最后往往大事化小，小事化无。在作者看来，银行和金融集团在犯罪，却没有受到惩罚，十分荒谬。&lt;/p&gt;
&lt;p&gt;这本书可以让你见识到:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一种高超的资本运作方式：资本主义发展到高级阶段，居然有如此高级的韭菜收割方式，冷血无情，毫不手软。相比之下，我们的开发商和政府真是稚嫩。&lt;/li&gt;
&lt;li&gt;美国法律体系多么复杂（联邦法律，各个州的法律各不相同），法律又是多么无孔不入，通过判决和发挥作用，规范各方势力。同时，法律又是所有人的武器。普通公民靠诉讼，在法庭捍卫自己的利益，也同时在捍卫法制的尊严；资本家也靠法律，无耻又“正当”地攫取别人的房产。无论如何，这都是文明社会的斗争，不再动刀动枪、拼死拼活。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同时，这本书的缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;线索凌乱，看得人稀里糊涂。作者介绍这场影响深远的公共事件，除了三个主角，还穿插进很多小人物。经常读到一半，突然冒出一个人名，讲一番他的悲惨经历，再接着由他扯回主角身上。三条主线汇集后，也没有什么令人印象深刻的事件。叙述整体显得平淡、无章法。&lt;/li&gt;
&lt;li&gt;金融术语翻译得有点生硬。个人观点。最典型的“止赎”一词，我看了一会儿才意识到，就是日常说的“断供”。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;钟鼓楼&#34;&gt;钟鼓楼&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/4619135/&#34;&gt;豆瓣链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;个人评分: ☆☆☆☆☆&lt;/li&gt;
&lt;li&gt;时间：&lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;&amp;lt;2020-01-02 Thu&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一本讲北京小市民的书，生动描述一段时间里鼓楼附近一群胡同居民的生活和矛盾，登场人物多，紧凑。穿插很多笔墨，写老北京民俗。这本书不仅有故事性，而且能丰富人文知识。&lt;/p&gt;
&lt;p&gt;书中人物基本涵盖当时社会各个阶层，高级领导，知识分子，演员/戏剧，工人，农民，个体户，国企员工……每个阶层的刻画都生动，在社会变革来临之际，个人被动参与成为时代洪流的分子，他们被裹挟，喜怒哀乐折射宏大里的真实色彩，居然能让我不觉疏离。将这么多人画得生动，情节安排得紧凑，是作者的笔力了得。&lt;/p&gt;
&lt;p&gt;当然读这本书也有一些别扭之处：一是夹叙夹议风格，旁白忒多了，简直像说书话本；二是老干体，遣词造句就是有些老旧口吻，我合理怀疑是作者故意对语言做“包浆”；三是里面青年人物思想的发展，有点突兀：最后一群年轻人，居然聚会讨论青年人的使命！想到八九十年代其他文学作品，都有类似情节，我合理推测那个时代，社会风气就是这么心怀天下、蓬勃向上。（想到2020年的今天，这种风气荡然无存，怀念之余令人神伤。）&lt;/p&gt;</description></item><item><title>浏览器会处理URL里的相对路径</title><link>https://blog.yuantops.com/tech/how_web_broswer_handles_url_relative_path/</link><pubDate>Thu, 21 Nov 2019 15:53:00 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/how_web_broswer_handles_url_relative_path/</guid><description>
&lt;p&gt;新系统上线前，安全部门扫描出一个高危漏洞：文件任意下载漏洞。渗透测试人员在URL里加上相对路径，不断发起HTTP请求，居然成功下载到Linux系统密码文件。修复漏洞挺简单，限制HTTP服务访问文件系统权限，不允许超出指定目录，几行代码搞定。&lt;/p&gt;
&lt;p&gt;修复之后准备进行验证，第一步当然是复现漏洞。没想到，这一步就挺曲折。&lt;/p&gt;
&lt;h2 id=&#34;消失的点号&#34;&gt;消失的点号&lt;/h2&gt;
&lt;p&gt;打开chrome，在地址栏输入带了相对路径( &lt;strong&gt;..&lt;/strong&gt; )的URL。URL指向一个文件，理论上，会触发文件下载。结果是：地址栏URL路径里点号全不见了，变成了一个正常地址。多试几遍，把双点号换成单点号，仍然如此。用 wiresharks 抓包看HTTP报文，请求头 &lt;em&gt;path&lt;/em&gt; 没有点号。这说明，浏览器做了手脚。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Google搜之，找到一份解析URI的RFC3968标准，专门有一章论述解析点号：&lt;a href=&#34;https://tools.ietf.org/html/rfc3986#section-5.2.4&#34;&gt;Remove Dot Segments&lt;/a&gt;。经过解析，点号和双点号会消失，这个过程被称为 &lt;strong&gt;remove_dot_segments&lt;/strong&gt; 。(RFC3968给出了这个过程的伪代码。)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Google官方在一篇文章里，将Chrome解析URL的过程称为 `Canonicalization` (&lt;a href=&#34;https://chromium.googlesource.com/chromium/src/+/master/docs/security/url%5Fdisplay%5Fguidelines/url%5Fdisplay%5Fguidelines.md#display-urls-in-canonical-form&#34;&gt;display-urls-in-canonical-form&lt;/a&gt;) 。经过解析，Chrome地址栏的点号变成实际值。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;结合两篇文档，原理清楚了：浏览器遵循RFC3968规范处理URL相对路径，所以点号和双点号都被干掉了。&lt;/p&gt;
&lt;h2 id=&#34;改用burp-suite重现问题&#34;&gt;改用Burp Suite重现问题&lt;/h2&gt;
&lt;p&gt;不能用浏览器复现问题，改尝试 &lt;strong&gt;curl&lt;/strong&gt; 命令。结果，curl也不能复现。好在可以借助 &lt;strong&gt;Burp Suite&lt;/strong&gt; 工具。&lt;/p&gt;
&lt;p&gt;Burp Suite是一款攻击web服务的集成工具，一般黑客用它来渗透网络。我们牛刀小用，用来拦截、修改HTTP请求报文。过程不在此赘述。总之，用它绕过了相对路径解析、重现了漏洞。&lt;/p&gt;
&lt;h2 id=&#34;修复漏洞&#34;&gt;修复漏洞&lt;/h2&gt;
&lt;p&gt;略。&lt;/p&gt;</description></item><item><title>2019阅读书单</title><link>https://blog.yuantops.com/opinions/2019-my-reading-list/</link><pubDate>Mon, 29 Jul 2019 22:48:40 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/2019-my-reading-list/</guid><description>
&lt;p&gt;今年我的工作有点变化，跳了一次槽，住处从杭州搬到深圳。深圳是个年轻城市，各种设施健全。没多久就发现，家附近步行十五分钟有一个社区图书站，与深圳图书馆总馆共享资源。从官网或微信公众号预约的书，两三天配送到站，晚上散步刚好顺便取回。虽然不是所有书都能预约，但已经很方便。&lt;/p&gt;
&lt;p&gt;如此优越的借书条件，自然不能浪费。看来，今年阅读量一定可以达到历史最高水平。&lt;/p&gt;
&lt;h2 id=&#34;押沙龙-押沙龙&#34;&gt;押沙龙，押沙龙！&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/4619135/&#34;&gt;豆瓣链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;个人评分: ☆☆☆☆☆&lt;/li&gt;
&lt;li&gt;时间：&lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;&amp;lt;2019-11-05 Tue&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;和它在图书馆偶遇，命中注定是我第一本福克纳。&lt;/p&gt;
&lt;p&gt;《押沙龙, 押沙龙！》讲美国南部一个家族兴衰史，跨度包含南北战争。作者自述创作意图，“一个男人想得到一个儿子,结果得到的太多了,这些儿子又毁掉了他的故事”。男人是主人公萨德本，他有两子，查尔斯·邦和亨利，前者死于后者枪下。译者在译序里解释道，押沙龙是圣经人物，深受其父宠爱却屡次忤逆作乱，在西方语境里几乎与“逆子”“孽障”同义。书名预示着，故事会以悲剧收尾。&lt;/p&gt;
&lt;p&gt;怀着崇拜心情，阅读这本作品。第一页就看得我气短：作者似乎打定主意不好好说话所以把句子写得特别长以至于一句话里包含很多短句而普通人不花一点功夫搞不明白要如何断句。通篇都是这种长句。读到第二章，故事好像和第一章对不上，原来是切换了视角。几乎每一章都有一个人口述，罗沙小姐、康普生先生、昆丁的大学室友，视角反复切换，每个人的叙述都只有部分，拼凑在一起，人物面貌、情节慢慢变清晰。所以，这本小说费脑子，没那么四平八稳。&lt;/p&gt;
&lt;p&gt;除了叙述角度变换，故事时间线也很跳跃。罗沙小姐邀请昆丁同去老宅，萨德本初到镇上，萨德本发家史，亨利杀死查尔斯，罗沙小姐和昆丁到了老宅并发现其中秘密，罗沙小姐重新拜访老宅，这些故事往往彼此穿插，倒叙中带有插叙，需要一边读、一边梳理。读到下半段，整个家族兴衰轮廓已经展现在眼前，后续的叙述开始填充更多细节。譬如在第一章出现的罗沙小姐，她对萨德本充满怨恨，直到书后半段才知道，是因为萨德本侮辱性地向她提出了“先生出男孩才结婚”的建议，她觉得自己被冒犯。再比如，查尔斯·邦这个人物，在一半位置出场，然后他和亨利交往、和朱迪斯订婚，接着死于亨利枪下，但原因直到最后揭晓：亨利不能容忍他的黑人血统。此类伏笔，最后让人收获一种“恍然大悟”的快感。&lt;/p&gt;
&lt;p&gt;回味这部小说，刻画人物很成功。朱迪斯的沉稳、坚强，查尔斯的敦厚、执着，都令人印象深刻。在全书浓重的悲剧氛围中，眼见萨德本百里地“起高楼，宴宾客，眼见它楼塌了!”，归结起来是萨德本人物性格使然。但与其说是他个人的悲剧，毋宁说是奴隶制瓦解前夕整个南方社会的悲剧。在小说结尾，施里夫问昆丁，你为什么恨南方。他激动地回答，不，我不恨！理智和情感的矛盾在这里爆发，颇有感染力(起码我被感染了)。&lt;/p&gt;
&lt;p&gt;全书最后，作者大发慈悲，赐下一张人物编年表。感动！我刚看完第一遍，头脑昏沉之际发现这张宝图，仿佛得到通关密码，终于搞懂整个时间线。根据年表指引，再返过去重读。重读一遍，发现一些细节，还有一些迷糊。再重读一遍，又有豁然开朗之感。到此时，我已经对作者佩服得五体投地。看到一则趣闻，有人抱怨說(福克纳的作品),讀了三遍還不懂,福克納告誡他去讀第四遍。看来不止我一个人有此遭遇，很多读者都这样。&lt;/p&gt;
&lt;h2 id=&#34;乌纳穆诺中篇小说选&#34;&gt;乌纳穆诺中篇小说选&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/26631626/&#34;&gt;豆瓣链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;个人评分: ☆☆☆☆☆&lt;/li&gt;
&lt;li&gt;时间：&lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;&amp;lt;2019-08-28 Wed&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;去还书，站在书架前，这本西班牙小说有点突出。拿回家，前言就让我虎躯一震：作者乌纳穆诺身世特殊，是乱伦所生，他父亲居然是他母亲的亲舅舅！！_(¦3」∠)_&lt;/p&gt;
&lt;p&gt;消化完这则人伦炸弹，接着读前言。译者介绍道，乌纳穆诺自己也饱受身世困扰，终其一生都在寻求心灵解脱，因此作品中多有哲学思考。读完全书，发现此言不假。&lt;/p&gt;
&lt;p&gt;《亚伯 桑切斯：一种激情》讲一对兄弟彼此嫉妒、一生较劲，但又在对方中寻找自己的故事。故事母题，是圣经里亚伯和该隐。作者在小说里反复提到这则故事，我找到圣经原文:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该隐与他兄弟亚伯说话，二人正在田间，该隐起来打他兄弟亚伯，把他杀了。——《创世记 4:8》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;华金医生嫉妒好友才华，几乎陷入病态。作家详细地描述了他嫉妒的心理和行为，入木三分。华金的女儿和亚伯的儿子亚伯林组建家庭，于是，不幸又延续到下一代。“两个家是两种令人悲哀的氛围，一是轻浮和冷漠，一是暗藏的、冰封的邪恶激情。”这是题目的来源。毫无疑问，一种激情指的是嫉妒。&lt;/p&gt;
&lt;p&gt;《两个母亲》讲一个不育寡妇，安排情人和别的女人结婚生子，然后抢夺孩子的故事。故事很短，结局很惨。男主性格懦弱，被两个女人争夺，没有自我主张，不堪忍受折磨，跳崖死了。寡妇名为拉克尔，名字来源于圣经里的拉结，拉结不能生育。&lt;/p&gt;
&lt;p&gt;《不折不扣一条汉子》讲一个美丽女儿被破产父亲“卖给”冰冷富豪，两人在相处中形成奇怪感情。丈夫“粗鲁而不可捉摸”，霸道总裁。妻子无比美丽，被丈夫降服，被丈夫迷惑，但是“她缺的是那爱的绝对确定性”。妻子感觉自己像受宠女奴，渴望得到超出附属物的对待。出于试探和挑衅，她出轨了。挑衅以失败告终，偷情的一对人被收拾得服服帖帖。但这位妻子也得以见到丈夫因暴怒而显露出的灵魂——丈夫爱他。最后，妻子死了，丈夫为她殉情。丈夫抑制在冰冷外表下的炽热火山，折磨妻子到死，又吞没自己。&lt;/p&gt;
&lt;p&gt;《殉道者圣曼努埃尔　布埃诺》讲一个神甫掩饰谎言的一生。村里人都爱戴他，崇敬他。但是，他清醒明白自己职业的性质，内心深藏矛盾。他说，“是的，我知道，所谓的社会革命的那些头头里有一个说过，宗教是人民的鸦片。鸦片……鸦片……鸦片，是啊。让我们给他们鸦片，让他们安睡，让他们做美梦。我本人忙得不亦乐乎，也是在给自己鸦片啊。”一个能力超群的明眼人，做着民众拥护的事，内心却在煎熬，因为他认识到自己是在麻痹大众。他死后被村民当作圣人，教会也要册封他。这个故事给我印象很深，因为我想，一个人的实践和他的理想信念不一定百分百吻合，有的觉醒者会选择破坏、反抗，有的却会选择维持。后者有时会成为圣徒，但也要铭记前者。&lt;/p&gt;
&lt;h2 id=&#34;在华五十年&#34;&gt;在华五十年&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.douban.com/doubanapp/dispatch/book/4882116&#34;&gt;豆瓣链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;时间: &lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;&amp;lt;2019-08-06 Tue&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;来源: 社区自助图书站&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在大陆受教育的人，肯定听过司徒雷登。我在杭州时，曾搜索杭城历史，知道他和杭州颇有渊源，死后连骸骨也安葬在杭州半山。但那时对他生平和事迹所知甚少，只知道是个美国人。读完这本书，才有了整体认识，改用敬意的眼光看他。我甚至感到遗憾：如果早半年看到这本书，定会去半山陵园瞻仰他。&lt;/p&gt;
&lt;p&gt;这本书大致分三部分：少年与青年阶段，燕京大学阶段，驻华大使阶段。司徒雷登父母是在华传教士，他在杭州出生，可以说与中国非常有渊源。儿童时回到美国接受教育。他的宗教背景，推动他成为一名传教士，在选择未来传教地点时，经过一番内心纠结，最后选择来中国。&lt;/p&gt;
&lt;p&gt;来华不久，他阴差阳错，开始负责筹建燕京大学。燕京大学的定位是一所教会大学，没有政府拨款，全靠同仁四处筹款。书中花了很大篇幅，介绍筹建细节：在美国找教会拨款、找基金会筹款、（甚至）找中国军阀和前清官员筹款买地。司徒雷登的个人能力在过程中得到了充分体现。燕京大学虽然是教会大学，但不保守刻板，在他主导下，宗教活动尽量不干扰校园秩序。正是由于他的开放胸襟，燕京大学为当时的中国培养了很多人才。司徒雷登因燕京大学赢得尊重，燕京大学与司徒雷登，算得上彼此成就。&lt;/p&gt;
&lt;p&gt;在中国的舞台上，司徒雷登最后以驻华大使的身份谢幕。作为战后的美国大使，他接触各色政治人物，一直在国共两党间斡旋。国共重庆谈判，在书里着墨比较多。如果书里是真话，美国人真心对和谈成功抱有过希望。后续局势开始恶化，他们感到十分遗憾。历史上，被CCP蒙蔽的人太多，本国人尚且不能幸免，又怎能苛责外国人呢？等到江山变红，上海解放，他坐飞机离开，颇有一点狼狈。作为教育家，司徒雷登先生非常成功；相比之下，作为政治人物的成就，不知道差到哪里去了。&lt;/p&gt;
&lt;p&gt;政治人物的回忆录，特别身处时代漩涡核心的人，谈到同一件历史大事，差异往往大得惊人。司徒雷登挺客气，对国内政客夸的多，贬的少（真是八面玲珑！）。但对于KMT官员，颇有一些负面评价。当时各个阶层都对KMT怨声载道，也说明了一点客观事实。&lt;/p&gt;
&lt;p&gt;最后，我个人挺感兴趣的两个点：1)教会的教籍似乎和中国人的档案系统很类似。书中提到，开始他教籍所在教会不太友好，经常针对他在华传教活动发起异议，后来换了一个教会才消停。2)他与助手兼好友——傅泾波的终生友谊。傅泾波工作上一生为他服务，非常得力；在司徒雷登晚年卧床的时候，认真照顾他，如同家人。颇有点恩来同志的辅佐才干。&lt;/p&gt;
&lt;p&gt;这本书翻译不觉拗口。看完去豆瓣翻评论，有人说大陆版颇有删节，已见怪不怪。待日后有机会再找原版读。&lt;/p&gt;
&lt;h2 id=&#34;全球首家交易所史话&#34;&gt;全球首家交易所史话&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/26953874/&#34;&gt;豆瓣链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;时间: &lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;&amp;lt;2019-07-30 Tue&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;去图书站还书，它正躺在书架上，刚好我那时在准备证券从业考试，便将它借回。&lt;/p&gt;
&lt;p&gt;书名足够直观，讲的是全球首家证券交易所初期的一些故事。地点在荷兰阿姆斯特丹，作者围绕着东印度公司股票的发行、流通、交易，通过一些具体事例，展示了现代证券市场一些交易手法的萌芽形态。对我而言，这些概念原本是枯燥的、抽象的，通过历史事件的演绎，变得丰满、具体。书中介绍了好些证券行业术语，对加深理解很有帮助：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《愤怒的投资者》: &lt;strong&gt;远期交易&lt;/strong&gt;, &lt;strong&gt;裸卖空&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;《第一次繁荣》: &lt;strong&gt;做市商&lt;/strong&gt;, &lt;strong&gt;股票交易所&lt;/strong&gt;, &lt;strong&gt;郁金香狂热&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;《犹太裔商人》: &lt;strong&gt;经纪人&lt;/strong&gt; , &lt;strong&gt;投机商&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;《交易俱乐部》: &lt;strong&gt;证券抵押贷款(回购)&lt;/strong&gt;, &lt;strong&gt;中央结算&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;《投机交易》: &lt;strong&gt;期权&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为刚转行证券业的新手，虽然故事里的金额有些算不太清楚，但仍不失故事本身的趣味。如果一个读者完全没有金融背景，单单拓宽眼界也是好的。&lt;/p&gt;
&lt;p&gt;最后，说一些不足之处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;翻译水平一般。以P176为例，&amp;rdquo;萨尔瓦多通过东印度公司的会计将一份价值3000荷兰盾的股票转入摩恩斯的账户作为贷款抵押品&amp;rdquo;，结合上下文，这里的&amp;rdquo;价值3000荷兰盾&amp;rdquo;应该是票面价值。不知原文如何用词，译文应该注明为好。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原文最后没有介绍全球首个证券交易所的结局，有些不圆满。维基百科上，阿姆斯特丹证券交易所&lt;a href=&#34;https://zh.wikipedia.org/wiki/阿姆斯特丹证券交易所&#34;&gt;中文词条&lt;/a&gt;是这么说的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2000年9月22日，阿姆斯特丹证券交易所与布鲁塞尔证券交易所和巴黎证券交易所合并成立了欧洲证券交易所。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;无人生还&#34;&gt;无人生还&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/24859822/&#34;&gt;豆瓣链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;时间:&lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;&amp;lt;2020-01-02 Thu&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最近一段时间看阿加莎·克里斯蒂的侦探小说比较多，陆陆续续借了几本，大多是新星出版社的。马普尔小姐系列，大侦探波洛系列，都挺不错。这本书不属于这两个系列，有独立的人物和情节设定，而且非常有名：据说是“风雪山庄”推理模式的开山鼻祖。当然看的时候我不知道，在豆瓣评论区被科普的。&lt;/p&gt;
&lt;p&gt;情节是一群人住进孤岛上一个山庄，天气恶劣与外界隔绝。然后陆陆续续发生死亡事件，直到全部死光。最后靠一份遗书解谜。书中恐怖气氛渲染到位，如果一边看一边跟着想，是有点怕怕的。作为一种侦探套路的开山之作，虽然细节处有些不严谨，但无碍这部作品整体的优秀。&lt;/p&gt;
&lt;p&gt;不想再多说情节上的精巧、创新，更想讨论这部小说里凶手的动机。认为法律缺失，导致坏人没有得到制裁，所以想替天行道，伸张真正的正义——这是凶手的出发点。该如何看待他的行为？他以正义之名所行复仇，真的正义吗？这是很有趣的辩题。这部作品出版于1939年，在它之后的很多创作出现了相同主题。就拿动漫《死亡笔记》来说，开头就是一个高智商少年突然获得任意杀人能力，开始自己做法官、杀死很多逍遥法外的“罪犯”。我个人不认可。单人意志是偶然的，他的道德标准只代表他个人，不具有普遍性。对于社会而言，需要一套约束多数的规则。法律就是这样一套规则，是最大公约数。&lt;/p&gt;
&lt;p&gt;故事里死掉的人，大部分法律无法审判。逼得未婚先孕女仆自尽，怂恿小孩冒险游泳继而丧命，故意派下属去战争前线送死……难道这些罪大恶极的行径，我们只能眼睁睁看着无能为力？在我看来，答案是肯定的。顶多能谴责。我害怕&amp;rdquo;铁面无私&amp;rdquo;的执法者！&lt;/p&gt;
&lt;p&gt;PS:《无人生还》后来被阿加莎本人改编成舞台剧。&lt;a href=&#34;https://book.douban.com/subject/5260192/&#34;&gt;豆瓣链接&lt;/a&gt; 先借的剧本，看了没懂，还了。据说剧本修复了一些漏洞，情节更合理。可惜啊可惜，知道时已经还给图书馆，不能对比验证了。 :-(&lt;/p&gt;
&lt;h2 id=&#34;约翰-克利斯朵夫&#34;&gt;约翰·克利斯朵夫&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/26978476/&#34;&gt;豆瓣链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;时间: &lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;&amp;lt;2019-12-22 Sun&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有一些书，无数次听说，但一直鼓不起勇气去读。《约翰·克利斯朵夫》无疑就是这样一本书。傅雷家书里，经常列举约翰·克利斯朵夫的例子鼓励傅聪，让他做一个好艺术家。可以说久闻大名。&lt;/p&gt;
&lt;p&gt;我看的版本分了上中下三册，每册厚度都很可观。下了很大决心开始啃这套书。从克利斯朵夫出生、成长、流亡到享有盛名，小说勾勒了他的一生。克利斯朵夫是音乐家，一生和庸俗的艺术界斗争，直到最后。看完之后，沉浸感很强。一个英雄的成长，往往经历锤炼。纵观克利斯朵夫一生，除了感慨他毅力坚定，还有其他：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;健康体魄很重要，极大塑造了秉性。克利斯朵夫继承了家族的好身体，精力旺盛，体格健壮。他对于人生和艺术的健康态度，无疑源于他旺盛的生命力。他的知己奥里维与他恰恰相反，自小体弱多病，性格变得理性、纤细。两相对比，更羡慕健壮前者，甚至是艳羡。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一生知己难寻。奥里维能理解他的作曲，达到心灵契合，在人格上和他相互补充。何其幸运！苏兹老人更是如此。一位痴迷音乐的长者，到了人生暮年遇到赏识的作曲家，未曾谋面便已通过乐章了解他的灵魂，把他视作挚友。当他们偶然相聚，彼此得到慰藉，收到友谊滋润，令人感动。就如作者所写，“一个艺术家倘使能知道自己的思想在世界上会结交到这些不相识的朋友，他将要感到多么幸福，——他的心会多么温暖，加增多少勇气……可是事实往往并不如此：各人都孤零零的活着，孤零零的死掉，而且感觉得越深切，越需要互相倾诉的时候，越不敢把各人的感觉说出来。”作者在《巨人传》序里写到，英雄在苦难中求助，求一个朋友。当两颗伟大的心灵知道彼此的存在，那就从对方得到了慰藉，从而更加英勇。世界上庸人纷纷扰扰，精神交往难得。谁不羡慕这样的境界，谁不想得到这样一个知己？&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;生活中的心理学&#34;&gt;生活中的心理学&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/20501403/&#34;&gt;豆瓣链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;时间: &lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;&amp;lt;2019-12-07 Sat&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Kindle上看的。没看完，翻译太垃圾，读不下去。&lt;/p&gt;
&lt;h2 id=&#34;麦客&#34;&gt;麦客&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/27067323/&#34;&gt;豆瓣链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;时间: &lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;&amp;lt;2019-11-30 Sat&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从社区图书馆随手取回。翻了两页，甚是后悔。简直是糟蹋纸张。&lt;/p&gt;
&lt;h2 id=&#34;尼罗河上的惨案&#34;&gt;尼罗河上的惨案&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/25697546/&#34;&gt;豆瓣链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;时间：&lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;&amp;lt;2019-11-22 Fri&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;又一本阿加莎作品。看的时候觉得精彩，过了俩月，完全不记得情节。我老了 :(&lt;/p&gt;
&lt;h2 id=&#34;东方快车谋杀案&#34;&gt;东方快车谋杀案&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/24153048/&#34;&gt;豆瓣链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;&amp;lt;2019-11-22 Fri&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一则集体复仇故事。结局一反套路，凶手没有伏法。阿婆（跟着别人如此称呼作者）让波洛侦探揭示真相，却不下定论。最终，恶贯满盈者得到报应，其余皆大欢喜。法庭审判缺席、凶手伏诛的故事，不是一次读到——它让人想到《无人生还》。这两个故事有很多类似：《无》是一人杀多人，《东》是多人杀一人;两个故事都有“孤岛”的外部设定： 《无》发生在一座与世隔绝的孤岛，《东》发生在一列被困的雪地列车；两个故事里，最后胜利的都不是法律，而是人情；从情节来说，《无》更精巧，连环谋杀堪称完美，结局引人深思；《东》结局令人舒适。&lt;/p&gt;
&lt;p&gt;同样是绕过法庭私刑杀人，为什么《东方快车谋杀案》轻易就得到我的理解甚至赞同？我自认守法公民。剖析一番，找到两个解释：1. 罪犯实在罪无可恕，法律同样会判他死刑，所以他们的行为没有超出法律范围，只是提前一步未经授权进行了执法。2. 我只是个庸碌的普通读者 :)&lt;/p&gt;
&lt;h2 id=&#34;迷雾&#34;&gt;迷雾&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/26824581/&#34;&gt;豆瓣链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;时间: &lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;&amp;lt;2019-11-17 Sun&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我承认，这本书看得我迷失自己。当书里主人翁居然跳出来和作者对话时，我脑子明显抽搐。认清本质，不要被骗，这书讲哲学的。&lt;/p&gt;
&lt;h2 id=&#34;破镜谋杀案&#34;&gt;破镜谋杀案&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/25986370/&#34;&gt;豆瓣链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;时间：&lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;&amp;lt;2019-11-17 Sun&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文学作品中，对人性的刻画往往令人印象深刻。看完《破镜谋杀案》，脑子里全是这起谋杀的起因。死者被害，根源在她的性格：为人善良，缺失同理心，却又格外热情鲁莽，易于自我感动，无意间伤害他人而不自知。这样的人实在令人厌烦。&lt;/p&gt;
&lt;p&gt;作家洞察力敏锐，准确从生活中抽象出这类人，予以描绘，或者加以批判。《钟鼓楼》里，这个形象是詹丽颖。刘心武心存仁厚，只降给她生活和工作的打压，不像阿婆在《破镜谋杀案》里夺取她的性命。在我推测，全世界作家笔下曾都出现这个形象。&lt;/p&gt;
&lt;p&gt;这本小说还让我学到一则科学知识：孕妇感染风疹，会导致胎儿畸形，危害极大。现在结婚都有婚检，我留心检查项目，确实有风疹筛查。 :)&lt;/p&gt;
&lt;h2 id=&#34;第六感觉&#34;&gt;第六感觉&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/27146579/&#34;&gt;豆瓣链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;时间：&lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;&amp;lt;2019-11-16 Sat&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一位加拿大华人医生的行医小记。通过这本书，得以管窥国外成熟医疗体系，和国内差别太大。读完几点感受：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;国外保险公司强大，在医疗系统里举足轻重。国内保险基本缺位。医疗保险保护病人，也保护医生。&lt;/li&gt;
&lt;li&gt;国外医生行医，也要随时注意从程序上保护自己，提防文明形式的“医闹” —— 法律诉讼。&lt;/li&gt;
&lt;li&gt;我国医生太艰难，待遇和地位远低于国外同行。这不是某几个人的问题，甚至不是一个医疗行业的问题，而要归咎于更高层 —— The Establishment。&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>How to blog with ox-hugo in Emacs</title><link>https://blog.yuantops.com/tech/blogging-with-ox-hugo/</link><pubDate>Thu, 25 Jul 2019 14:47:00 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/blogging-with-ox-hugo/</guid><description>
&lt;p&gt;我的&lt;a href=&#34;https://blog.yuantops.com/tech/emacs-orgmode-hugo-with-oxpandoc/&#34;&gt;一篇老博客&lt;/a&gt;，介绍了用Emacs和Org-mode写博客的工作流。总的来说，勉强符合预期，流程稍显磕绊。今天偶然发现，用Org-mode写博客有了正规军： &lt;code&gt;ox-hugo&lt;/code&gt; 。简单试用之后,发现 &lt;code&gt;ox-hugo&lt;/code&gt; 表现很流畅，几乎就是对之前流程的升级，于是毫不犹豫选 &lt;code&gt;ox-hugo&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ox-hugo&lt;/code&gt; 是一个工作在Org-mode的Emacs包，安装过程可以说平平无奇：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;M x&lt;/code&gt; &lt;code&gt;package-refresh-contents&lt;/code&gt; :: 更新安装源&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加Emacs配置。修改细节与Emacs配置风格相关，我使用&lt;a href=&#34;https://github.com/purcell/emacs.d&#34;&gt;Purcell维护的.emacs.d配置&lt;/a&gt;，仅供参考。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在 &lt;code&gt;.emacs.d/lisp/&lt;/code&gt; 目录下，新增配置文件 &lt;code&gt;init-ox-hugo.el&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-emacs-lisp&#34; data-lang=&#34;emacs-lisp&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-emacs-lisp&#34; data-lang=&#34;emacs-lisp&#34;&gt; (require-package &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ox-hugo&lt;/span&gt;)
(with-eval-after-load &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ox&lt;/span&gt; (require &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ox-hugo&lt;/span&gt;))
(provide &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;init-ox-hugo&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在入口配置文件 &lt;code&gt;.emacs.d/init.el&lt;/code&gt; 中，引用新增的配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;
(require &#39;init-ox-hugo)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;写博客旧流程&#34;&gt;写博客旧流程&lt;/h2&gt;
&lt;p&gt;现在，org文件可以直接导出为Hugo支持的Markdown格式了。这一点 &lt;code&gt;ox-pandoc&lt;/code&gt; 也能做到，但 &lt;code&gt;ox-hugo&lt;/code&gt; 还能做得更多。&lt;/p&gt;
&lt;p&gt;回顾之前的工作流:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新建xx.org文件&lt;/li&gt;
&lt;li&gt;&lt;p&gt;输入二级标题，接着插入 &lt;code&gt;front matter&lt;/code&gt; 。 &lt;code&gt;front matter&lt;/code&gt; 内容大致如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;+++
title = &amp;quot;&amp;quot;
date = &amp;quot;&amp;quot;
Categories = [&amp;quot;Tech&amp;quot;]
Tags = [&amp;quot;Emacs&amp;quot;]
Description = &amp;quot;&amp;quot;
keywords = [&amp;quot;&amp;quot;]
+++
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;写博客正文&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按下 &lt;code&gt;C-c C-e&lt;/code&gt; , 将二级标题对应的subtree导出为Markdown格式文件&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将Markdown格式文件保存到contents/tech/目录。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;front matter&lt;/code&gt; 是hugo渲染文件需要的必要元信息, 例如文章标签、分类、标题等。ox-hugo改进之一，是使用org-mode语法放置元信息，不再需要手动设置 &lt;code&gt;front matter&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;Org-mode支持为headline设置 tags。 &lt;code&gt;ox-hugo&lt;/code&gt; 沿用这点，org-mode的tag就是文章标签, 以@开头的tag就是文章分类。其他例如作者、日期、文件名的元信息，通过 &lt;code&gt;:PROPERTIES:&lt;/code&gt; 设置。在导出Markdown格式时，ox-hugo会自动提取这些数据。因为ox-hugo可以一次导出所有subtree，因此 &lt;code&gt;ox-hugo&lt;/code&gt; 官方推荐做法是，所有文章放到一个org文件，&lt;a href=&#34;https://ox-hugo.scripter.co/doc/screenshots/#screenshot-one-post-per-subtree&#34;&gt;每个Subtree对应一篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对于习惯一个org文件对应一篇文章的作者而言，ox-hugo也予以尊重，&lt;a href=&#34;https://ox-hugo.scripter.co/doc/org-meta-data-to-hugo-front-matter/&#34;&gt;在文件头添加对应配置项即可&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;我的实践&#34;&gt;我的实践&lt;/h2&gt;
&lt;p&gt;对本博客而言，考虑到1)文章固定只有3个分类，2)现在已有很多存量md格式的文章，我采取一种折中做法: 一个分类对应一个org文件，org文件里每个subtree对应一篇文章。这样兼顾现状，而且新文章顺利迁移到新做法。就每个org文件来说，元信息分为两大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对整个文件都生效的配置，放到文件开头；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;#+author: yuan.tops@gmail.com
#+hugo_base_dir: ../
#+HUGO_SECTION: tech
# Categories
#+filetags: @tech
#+hugo_auto_set_lastmod: t
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对单篇文章生效的配置，放到subtree的标题下面。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-props&#34;&gt;:PROPERTIES:
:EXPORT_HUGO_CATEGORIES: Tech
:EXPORT_DATE: &amp;quot;2019-07-24T22:29:52+08:00&amp;quot;
:EXPORT_HUGO_PUBLISHDATE: &amp;quot;2019-07-24T22:29:52Z&amp;quot;
:EXPORT_FILE_NAME: blogging-with-ox-hugo
:EXPORT_DESCRIPTION: 发现一个用Emacs写blog的新工具: ox-hugo。它与org-mode融合得非常自然，更好用。本文记录如何在Emacs中配置与使用ox-hugo。
:END:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以本文为例，配置如图:
&lt;img src=&#34;https://blog.yuantops.com/ox-hugo/screenshot-org-subtree.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Emacs学习曲线盘旋上升, Org-mode也是如此。不断折腾，乐在其中！&lt;/p&gt;</description></item><item><title>Bash Guideline Notes</title><link>https://blog.yuantops.com/tech/bash-guideline-study-notes/</link><pubDate>Thu, 25 Jul 2019 00:00:00 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/bash-guideline-study-notes/</guid><description>
&lt;h2 id=&#34;关于重定向顺序&#34;&gt;关于重定向顺序&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Note that the order of redirections is signi cant. For example, the command &lt;br /&gt;
&lt;br /&gt;
ls &amp;gt; dirlist 2&amp;gt;&amp;amp;1 &lt;br /&gt;
directs both standard output ( file descriptor 1) and standard error ( le descriptor 2) to the file dirlist, while the command ls 2&amp;gt;&amp;amp;1 &amp;gt; dirlist directs only the standard output to file dirlist, because the standard error was made a copy of the standard output before the standard output was redirected to dirlist. &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;将stdout-和-stderr-重定向到-文件&#34;&gt;将Stdout 和 Stderr 重定向到 文件&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;This construct allows both the standard output ( file descriptor 1) and the standard error output ( file descriptor 2) to be redirected to the file whose name is the expansion of word. &lt;br /&gt;
&lt;br /&gt;
There are two formats for redirecting standard output and standard error:&lt;br /&gt;
&lt;br /&gt;
&amp;amp;&amp;gt;word and &lt;br /&gt;
&lt;br /&gt;
&amp;gt;&amp;amp;word
&lt;br /&gt;
Of the two forms, the first is preferred. This is semantically equivalent to&lt;br /&gt;
&amp;gt;word 2&amp;gt;&amp;amp;1&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;here-document&#34;&gt;Here Document&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;Here Documents
This type of redirection instructs the shell to read input from the current source until a line containing only word (with no trailing blanks) is seen.
All of the lines read up to that point are then used as the standard input for a command.
The format of here-documents is:
&amp;lt;&amp;lt;[-]word
here-document
delimiter
No parameter expansion, command substitution, arithmetic expansion, or pathname expansion is performed on word. If any characters in word are quoted, the delimiter is the result of quote removal on word, and the lines in the here-document are not expanded. If word is unquoted, all lines of the here-document are subjected to parameter expansion, command substitution, and arithmetic expansion. In the latter case, the character sequence \&amp;lt;newline&amp;gt; is ignored, and \ must be used to quote the characters \, $, and `.
If the redirection operator is &amp;lt;&amp;lt;-, then all leading tab characters are stripped from input lines and the line containing delimiter. This allows here-documents within shell scripts to be indented in a natural fashion.
$ cat &amp;lt;&amp;lt;EOF &amp;gt; print.sh
#!/bin/bash
echo \$PWD
echo $PWD
EOF
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>Understanding XOR</title><link>https://blog.yuantops.com/tech/understanding-xor/</link><pubDate>Thu, 25 Jul 2019 00:00:00 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/understanding-xor/</guid><description>&lt;blockquote&gt;
&lt;p&gt;We can interpret the action of XOR in a number of different ways, and this helps to shed light on its properties. The most obvious way to interpret it is as its name suggests, ‘exclusive OR’: A ⊕ B is true if and only if precisely one of A and B is true. Another way to think of it is as identifying difference in a pair of bytes: A ⊕ B = ‘the bits where they differ’. This interpretation makes it obvious that A ⊕ A = 0 (byte A does not differ from itself in any bit) and A ⊕ 0 = A (byte A differs from 0 precisely in the bit positions that equal 1) and is also useful when thinking about toggling and encryption later on. &lt;br /&gt;
&lt;br /&gt;
The last, and most powerful, interpretation of XOR is in terms of parity, i.e. whether something is odd or even. For any n bits, A1 ⊕ A2 ⊕ … ⊕ An = 1 if and only if the number of 1s is odd. This can be proved quite easily by induction and use of associativity. It is the crucial observation that leads to many of the properties that follow, including error detection, data protection and adding. &lt;br /&gt;
&lt;br /&gt;
Essentially the combined value x ^ y ‘remembers’ both states, and one state is the key to getting at the other.&lt;/p&gt;
&lt;/blockquote&gt;</description></item><item><title>[译文]让Siri变身完美家庭助手：兼容Apple Homekit不支持的设备</title><link>https://blog.yuantops.com/tech/homebridge-plugin-tutorial/</link><pubDate>Sun, 29 Jul 2018 17:48:19 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/homebridge-plugin-tutorial/</guid><description>
&lt;p&gt;译文一篇,
原文地址：&lt;a href=&#34;http://blog.theodo.fr/2017/08/make-siri-perfect-home-companion-devices-not-supported-apple-homekit/&#34;&gt;http://blog.theodo.fr/2017/08/make-siri-perfect-home-companion-devices-not-supported-apple-homekit/&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;Apple推出Homekit已有一段时间，作为智能家具解决布局的重要一环，Homekit在中文互联网上的资料可算寥寥。这篇文章介绍了Homekit平台抽象的关键概念，以及Homebridge这一款破解了Homekit协议、并支持插件化开发扩展的优秀程序。&lt;/p&gt;
&lt;p&gt;文章还包含了一个详细教程，一步步教你写简单的Homebridge插件。&lt;/p&gt;
&lt;p&gt;即使不是开发者，读完这篇文章，最起码可以让你打开iOS
“家庭”应用时不至于一头雾水。&lt;/p&gt;
&lt;p&gt;========================分割线，以下是正文===============================&lt;/p&gt;
&lt;h1 id=&#34;为什么是homekit&#34;&gt;为什么是Homekit?&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/homekit/&#34;&gt;Homekit&lt;/a&gt;是Apple开发的家庭配件管理框架。有了Homekit，Apple设备用户可以使用同一套界面，管理不同厂商的接入设备。它使Siri变得更强，能听懂发给这些设备的指令。&lt;/p&gt;
&lt;p&gt;如果你有一部iPhone或者Apple TV，Homekit可以在Home
Assistant等互联协议的基础上做更多好玩的事。iPhone原生支持Homekit，你可以通过&amp;rdquo;家庭&amp;rdquo;app
或者快速访问标签，方便地管理设备。Apple
TV则可以作为设备中枢，让你设置自动化任务，并且让你在非家庭网络下也能掌控家中情况。&lt;/p&gt;
&lt;h1 id=&#34;工作原理&#34;&gt;工作原理&lt;/h1&gt;
&lt;h2 id=&#34;homekit-accessory-protocol&#34;&gt;Homekit Accessory Protocol&lt;/h2&gt;
&lt;p&gt;Homekit为家庭和各种连接设备定义了一组布局(layout)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;家庭(Home)：家庭是一处住所，它有一个由各种配件组成的网络。&lt;/li&gt;
&lt;li&gt;房间(Room)：每个家庭有一个或多个房间，每个房间有一个或多个配件。&lt;/li&gt;
&lt;li&gt;平台(Platform)：平台指的是一组配件。&lt;/li&gt;
&lt;li&gt;配件(Accessory)：配件指的是一台支持自动化的物理设备。&lt;/li&gt;
&lt;li&gt;桥(Bridge)：桥是一种特殊配件，通过它可以和那些不能与Homekit直接通信的配件通信。举例来说，桥可能是一个灯光的中枢，灯光之间通信时并不使用Homekit
Accessory Protocol协议。&lt;/li&gt;
&lt;li&gt;服务(Service)：一个服务对应配件的一种功能。车库门除了提供开关门的服务，还可能额外提供开关车库灯的服务。&lt;/li&gt;
&lt;li&gt;特征(Characteristic)：每个服务都有一些被称为特征的属性。对车库门而言，它有 &lt;code&gt;Current Door State&lt;/code&gt; 和
&lt;code&gt;Target Door State&lt;/code&gt;
两个boolean值。服务的所有特征共同定义了它的当前状态。特征有3种权限：读，写，通知。&lt;a href=&#34;https://github.com/KhaosT/HAP-NodeJS/blob/master/lib/gen/HomeKitTypes.js&#34;&gt;这里&lt;/a&gt;能找到各种服务列表，以及与之关联的特征。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了确定要操作的设备以及要触发的动作，iOS的&amp;rdquo;家庭&amp;rdquo;应用和Siri发出的每一个请求，都会使用上面的布局。&lt;/p&gt;
&lt;p&gt;然而，当前市面上只有少量设备支持Homekit。对其他设备来说，需要在Homekit和设备间设置一个代理(proxy)。大多数厂商会自己定义一套与设备交互的方式(API或者协议)。代理接收Homekit请求，然后将它们翻译成设备能听懂的语言。&lt;/p&gt;
&lt;h2 id=&#34;homebridge&#34;&gt;Homebridge&lt;/h2&gt;
&lt;p&gt;本文使用的代理是&lt;a href=&#34;https://github.com/nfarina/homebridge&#34;&gt;Homebridge&lt;/a&gt;，一款用&lt;a href=&#34;https://github.com/KhaosT/HAP-NodeJS&#34;&gt;HAP-node.js&lt;/a&gt;写的NodeJS服务器。Homebridge实例化出一个
&lt;code&gt;桥&lt;/code&gt;
，然后你用iOS的&amp;rdquo;家庭&amp;rdquo;应用把它添加到Homekit。Homebridge支持社区开发的插件，从而在Homekit和五花八门的&amp;rdquo;智能家居&amp;rdquo;设备间建立连接。&lt;/p&gt;
&lt;p&gt;社区开发者已经为很多家庭自动化设备开发了插件(例如&lt;a href=&#34;https://github.com/KraigM/homebridge-nest&#34;&gt;Nest&lt;/a&gt;,
&lt;a href=&#34;https://github.com/devbobo/homebridge-lifx-lan&#34;&gt;Lifx&lt;/a&gt;, 甚至是&lt;a href=&#34;https://github.com/home-assistant/homebridge-homeassistant&#34;&gt;所有兼容Home
Assitant的设备&lt;/a&gt;)。如果你没找到要找的插件，这篇教程正是为你而写。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.theodo.fr/wp-content/uploads/2017/08/workflow.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h1 id=&#34;自己开发插件&#34;&gt;自己开发插件&lt;/h1&gt;
&lt;h2 id=&#34;要求&#34;&gt;要求&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;你已经在LAN中一台设备上安装了Homebridge，而且处于运行状态。参考&lt;a href=&#34;https://github.com/nfarina/homebridge#installation&#34;&gt;这些教程&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;你已经在iOS的&amp;rdquo;家庭&amp;rdquo;应用中，添加了Homebridge配件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;教程&#34;&gt;教程&lt;/h2&gt;
&lt;p&gt;我们来动手写一个假的开关插件。&lt;/p&gt;
&lt;p&gt;新建一个目录，包含2个文件：管理依赖的 &lt;code&gt;package.json&lt;/code&gt; 文件，以及放插件核心逻辑的 &lt;code&gt;index.js&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;我们对开关API的设定如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在LAN里，能通过HTTP协议层的RESTful API控制它&lt;/li&gt;
&lt;li&gt;在LAN里，开关的IP地址是192.168.0.10&lt;/li&gt;
&lt;li&gt;对 &lt;code&gt;/api/status&lt;/code&gt; 的GET请求返回一个boolean值，代表开关的当前状态。这个请求会读取开关的 &lt;code&gt;On&lt;/code&gt; 特征&lt;/li&gt;
&lt;li&gt;对 &lt;code&gt;/api/order&lt;/code&gt; 的POST请求里携带一个代表开关目标的boolean值，将触发对应动作。这个请求会写入开关的 &lt;code&gt;On&lt;/code&gt;
特征&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个Homebridge插件将提供一个新配件，包含两个服务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AccessoryInformation&lt;/code&gt; 服务。不管什么类型的配件都必须提供的服务，用来广播设备相关的信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Switch&lt;/code&gt; 服务，对应我们实际的开关。这个服务需要的特征只包含一个boolean值 &lt;code&gt;On&lt;/code&gt;
(参考&lt;a href=&#34;https://github.com/KhaosT/HAP-NodeJS/blob/master/lib/gen/HomeKitTypes.js#L3219&#34;&gt;服务和特征的对应关系表&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一步，把插件注入homebridge。控制逻辑在javascript对象 &lt;code&gt;mySwitch&lt;/code&gt; 里：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Service, Characteristic;
module.exports = function (homebridge) {
Service = homebridge.hap.Service;
Characteristic = homebridge.hap.Characteristic;
homebridge.registerAccessory(&amp;quot;switch-plugin&amp;quot;, &amp;quot;MyAwesomeSwitch&amp;quot;, mySwitch);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在HAP-node.js和Homebridge框架下，把核心逻辑放到 &lt;code&gt;mySwitch&lt;/code&gt; 对象的 &lt;code&gt;getService&lt;/code&gt;
函数。在这个函数里实例化服务。我们还要在这个函数里定义，当Homekit请求到来时，要调用哪个服务哪个特征的getter和setter。&lt;/p&gt;
&lt;p&gt;我们需要实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AccessoryInformation&lt;/code&gt; 服务，包含：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Manufacturer&lt;/code&gt; 特征&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Model&lt;/code&gt; 特征&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SerialNumber&lt;/code&gt; 特征&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Switch&lt;/code&gt; 服务，保护：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;On&lt;/code&gt; 特征 —— 这个服务仅需包含这一个特征&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;AccesoryInformation&lt;/code&gt; 的特征是可读的，可以在插件初始化时设置。特征 &lt;code&gt;On&lt;/code&gt;
不同，它是可写的，需要getter和setter。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;mySwitch.prototype = {
getServices: function () {
let informationService = new Service.AccessoryInformation();
informationService
.setCharacteristic(Characteristic.Manufacturer, &amp;quot;My switch manufacturer&amp;quot;)
.setCharacteristic(Characteristic.Model, &amp;quot;My switch model&amp;quot;)
.setCharacteristic(Characteristic.SerialNumber, &amp;quot;123-456-789&amp;quot;);
let switchService = new Service.Switch(&amp;quot;My switch&amp;quot;);
switchService
.getCharacteristic(Characteristic.On)
.on(&#39;get&#39;, this.getSwitchOnCharacteristic.bind(this))
.on(&#39;set&#39;, this.setSwitchOnCharacteristic.bind(this));
this.informationService = informationService;
this.switchService = switchService;
return [informationService, switchService];
}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面，我们来实现 &lt;code&gt;On&lt;/code&gt; 特征的getter和setter。把这部分逻辑放到 &lt;code&gt;mySwitch&lt;/code&gt; 对象的原型函数里。&lt;/p&gt;
&lt;p&gt;基于开关提供的RESTful API，做出如下假设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对 &lt;a href=&#34;http://192.168.0.10/api/status&#34;&gt;http://192.168.0.10/api/status&lt;/a&gt; 的GET请求，将返回 &lt;code&gt;{ currentState: }&lt;/code&gt;
，反映开关当前状态&lt;/li&gt;
&lt;li&gt;对 &lt;a href=&#34;http://192.168.0.10/api/order&#34;&gt;http://192.168.0.10/api/order&lt;/a&gt; 的POST请求，发送 &lt;code&gt;{ targetState: }&lt;/code&gt;
，代表想让开关达到的目标状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们使用 &lt;code&gt;request&lt;/code&gt; 和 &lt;code&gt;url&lt;/code&gt; 模块处理HTTP请求。&lt;/p&gt;
&lt;p&gt;上面的URL要配置在Homebridge的全局JSON配置文件里，然后变成配置对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const request = require(&#39;request&#39;);
const url = require(&#39;url&#39;);
function mySwitch(log, config) {
this.log = log;
this.getUrl = url.parse(config[&#39;getUrl&#39;]);
this.postUrl = url.parse(config[&#39;postUrl&#39;]);
}
mySwitch.prototype = {
getSwitchOnCharacteristic: function (next) {
const me = this;
request({
url: me.getUrl,
method: &#39;GET&#39;,
},
function (error, response, body) {
if (error) {
me.log(&#39;STATUS: &#39; + response.statusCode);
me.log(error.message);
return next(error);
}
return next(null, body.currentState);
});
},
setSwitchOnCharacteristic: function (on, next) {
const me = this;
request({
url: me.postUrl,
body: {&#39;targetState&#39;: on},
method: &#39;POST&#39;,
headers: {&#39;Content-type&#39;: &#39;application/json&#39;}
},
function (error, response) {
if (error) {
me.log(&#39;STATUS: &#39; + response.statusCode);
me.log(error.message);
return next(error);
}
return next();
});
}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，通过全局安装方式，把插件添加到Homebridge：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npm install -g switch-plugin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用你最爱的文本编辑器，打开位于Homebridge目录的config.json文件。在accessory部分，把下面内容添加到数组:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
&amp;quot;accessory&amp;quot;: &amp;quot;MyAwesomeSwitch&amp;quot;,
&amp;quot;getUrl&amp;quot;: &amp;quot;http://192.168.0.10/api/status&amp;quot;,
&amp;quot;postUrl&amp;quot;: &amp;quot;http://192.168.0.10/api/order&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启Homebridge。打开iOS的&amp;rdquo;家庭&amp;rdquo;应用，现在你应该可以开、关这个假开关了。&lt;/p&gt;</description></item><item><title>树莓派连接DHT11温度湿度传感器</title><link>https://blog.yuantops.com/tech/rasp-pi-dht11/</link><pubDate>Sat, 28 Jul 2018 20:30:45 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/rasp-pi-dht11/</guid><description>
&lt;p&gt;记录一下给树莓派安装温度湿度传感器的过程。&lt;/p&gt;
&lt;p&gt;树莓派主板有一排GPIO扩展口，可以方便地驱动硬件。温度湿度传感器DHT11是一种常见传感器，很适合作为入门器件，探索树莓派的硬件能力。&lt;/p&gt;
&lt;p&gt;我上次接触硬件知识还是在大二的单片机小学期，几乎已经忘光，正好趁机抢救性回忆一下。&lt;/p&gt;
&lt;h1 id=&#34;目标&#34;&gt;目标&lt;/h1&gt;
&lt;p&gt;在树莓派上读到温度和湿度数据。&lt;/p&gt;
&lt;h1 id=&#34;元件清单&#34;&gt;元件清单&lt;/h1&gt;
&lt;p&gt;除了传感器DHT11，还需要连接线、面包板等元件，在淘宝上很好买到。&lt;/p&gt;
&lt;p&gt;我额外买了一块树莓派特制GPIO扩展板，用它把树莓派的40根针脚延长到面包板，类似USB延长线。很怀疑这是来自中国的&amp;rdquo;微创新&amp;rdquo;，值得赞美，因为确实解决了树莓派针脚空间狭小不便于插线的小痛点。&lt;/p&gt;
&lt;p&gt;下面是元件清单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;树莓派Model 3 B&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;DHT11传感器。我用的是三脚型号。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;面包板&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;杜邦线/连接线&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;插线&#34;&gt;插线&lt;/h1&gt;
&lt;p&gt;在实际插线之前，有必要先来认识树莓派针脚。树莓派3代一共40根针脚，这么辨认物理编号：横着放，让2排针脚在上面，上面那排是偶数，从左到右是2到40；下面那排是奇数，从左到右是1到39。&lt;/p&gt;
&lt;p&gt;40根针脚里，有28根GPIO针脚。这28根针脚，又有两种命名规则：BCM编号，WiringPi编号。还要注意，树莓派2代和3代的对应关系不一样，参考网上资料时要看清针脚图的型号。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BCM编号，就是我们常看见的 &lt;code&gt;GPIOxx&lt;/code&gt; 里面的 &lt;code&gt;xx&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;WiringPi编号，是 &lt;a href=&#34;http://wiringpi.com/&#34;&gt;WiringPi库&lt;/a&gt;
使用的编号。除非是用WiringPi库驱动针脚，否则不需关注。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对我这样的新手而言，最初物理编号和BCM编号两套规则切换起来有些烦人，需要一些细心。&lt;/p&gt;
&lt;p&gt;下面的接线方案，用的是物理编号：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左边 &lt;code&gt;+&lt;/code&gt; 接3.3V电源，选择 &lt;code&gt;1&lt;/code&gt; 口。&lt;/li&gt;
&lt;li&gt;中间 &lt;code&gt;DATA&lt;/code&gt; ，选择 &lt;code&gt;7&lt;/code&gt; 口。&lt;/li&gt;
&lt;li&gt;右边 &lt;code&gt;-&lt;/code&gt; 接地，选择 &lt;code&gt;14&lt;/code&gt; 口。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;安装命令&#34;&gt;安装命令&lt;/h1&gt;
&lt;p&gt;DHT11是非常成熟通用的传感器，对它的驱动封装也特别多，不需再造轮子。货比三家，我发现Adafruit公司开源的代码质量最高，运行起来最稳定。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装Adadruit公司的开源库：&lt;a href=&#34;https://github.com/adafruit/Adafruit_Python_DHT&#34;&gt;Adafruit Python DHT&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在安装目录下, 进入example目录，运行 &lt;code&gt;AdafruitDHT.py&lt;/code&gt;
文件:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pi@raspberrypi:~/Adafruit_Python_DHT/examples $ python AdafruitDHT.py
0 30.0 C 70.0%
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我房间此时是30摄氏度，湿度70%。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至此DHT11温度湿度传感器的安装完成。&lt;/p&gt;
&lt;p&gt;更进一步，在手机上查看，或者在LCD显示屏上展示，请期待后续文章。&lt;/p&gt;</description></item><item><title>诚实与圣徒——读《美人赠我蒙汗药》</title><link>https://blog.yuantops.com/opinions/talk-between-wangshuo-and-xiaobo-review/</link><pubDate>Sun, 20 May 2018 09:48:12 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/talk-between-wangshuo-and-xiaobo-review/</guid><description>&lt;p&gt;周六读完《美人赠我蒙汗药》，想到老侠悲剧性的结局，眼前不由得浮现出一个受难基督的形象：为自己的信念奉献生命。&lt;/p&gt;
&lt;p&gt;老侠的书我读得不多，这本书让我得以窥见他的观点。他和王朔的谈话，围绕“文化”“知识分子”等话题，批判机关枪横扫文坛诸多名人，读来爽快。除了臧否人物，我更有兴趣的是老侠在二人谈话中表露的观点。&lt;/p&gt;
&lt;p&gt;老侠对基督教为代表的西方文化，抱有彻底好感，甚至是崇拜。对中国文化传统，老侠没太多好话，把孔子、屈原一帮人贬得一无是处（见《欺世盗名的传统》），批评“中国文化中没有宗教情怀，没有神秘主义”(见《可怜人必有可恨之处》)。他站在什么立场立论、以什么尺度批判呢？在聊到刘小枫时，老侠肯定了刘小枫参照基督教批评中国传统的路数，他说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;中国传统中的人格弱点，很重要的原因是传统中没有一个超越性的绝对尺度，实用得很，一个民族、一个人，没有一种自律或者他率的非实用尺度，就没有了底线，什么事都敢做，凶残虚伪且丑态百出。西方文化，从圣 奥古斯丁开始，就为人的自我认识树起了一个绝对的尺度，正是在这一神学的尺度下，人世才罪恶重重，人性的弱点才能凸现出来，人才能反省自己，心存敬畏。——《可怜人必有可恨之处》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老侠提到一个概念：&amp;rdquo;绝对尺度&amp;rdquo;。他对实用性尺度嗤之以鼻。在中国传统中，充满权数、谋略，发展到当代文坛，又出现了各式各样“献媚”。老侠瞧不起“学术掮客”，特意点名余杰、摩罗、孔庆东三位，批评他们自夸和献媚，十分龌龊。&lt;/p&gt;
&lt;p&gt;对中国知识分子，老侠抛出一个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就是当持续了半个世纪的民族大灾难已经发生而且余震不断的时候，应该用什么样的姿态和方式去面对灾难？我觉得最大的虚伪是他们首先搞清自己，把自己放在控诉者和审判者的位置上，从来没有人或者是极少有人问过自己，出于自愿也好，被逼无奈也好，我是否参与了制造这灾难？我是不是同谋者？我应不应该负一份哪怕仅仅是道义上的责任？——《年轻一代的”身体政治学”》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老侠无疑是拿着“绝对尺度”的尺子在量人。面对苦难追究责任，很多人会逃避，自觉不自觉作出自我辩护。这些东西体现在作品中，就变成“中国的文字都带有虚饰性，美化自己和美化苦难，美化苦难就等于为苦难开脱。”这一点挺操蛋。在文艺作品中，作家不批判反省苦难，而是作出一种坚忍不拔、等待光明的姿态，从苦难里扒出来鸡毛蒜皮的美好、希望、浪漫，最终发一通“歌颂人民”的赞美。这似乎是一种流感，从文化作品到宣传材料，全是染上这种套路。把灾难变成喜事，从苦难里获取道德力量，是“一种不诚实，一种献媚”，实在让人反胃。&lt;/p&gt;
&lt;p&gt;老侠口中的“绝对尺度”，标准定得高。他举了几个达标的例子：法国的现代圣女薇依，不忍心在异国多领救济量，饿死在异国；法国作家纪德，揭露苏联治下恐怖真相。不合格的例子比比皆是：国外的高尔基，配合苏联当局对苏联情况三缄其口。国内的知识分子，老侠就认为钱钟书和杨绛对那段经历表现得太云淡风清，“既对苦难和社会不公正保持沉默，又能把自己塑造成似神的人格。”老侠显然不满意，因为他是积极的行动者，把沉默者都视作了妥协者，乃至帮凶。即使是陈寅恪，老侠承认他是中国知识分子的代表，却还认为他“仍然不够层次”。&lt;/p&gt;
&lt;p&gt;不会有一点苛刻吗？我想，老侠期待知识分子在承担道义上有更多勇气、做得更多。的确算苛责了。陈寅恪这样标志性的人物，即使什么话都不说，下场也很悲惨。那些大声说话的知识分子，下场更是无语形容，不能因为名气不大就认为他们不存在。写到这里，我突然意识到一点：**老侠在期待别人做圣徒。**&lt;/p&gt;
&lt;p&gt;耶稣基督背负了拯救人类的十字架，最后流尽鲜血死去。这样一个受难者的形象，多么光辉、崇高，指引人。老侠作为知识分子，认为把自己和同类都应肩负道义上的责任，做一个在“绝对尺度”上站得住脚的人。所以，看到从灾难里生存下来的人保持沉默、为自己开脱，或是在作品里渲染苦难的必要，他感到失望和愤怒。这是他的立场。但是，勇气要付出代价，无比沉重，老侠对此节又没有展开详谈。&lt;/p&gt;
&lt;p&gt;如果我是在一年前读到这本书，肯定不会如此正面地去理解老侠。我会觉得他是站着说话不腰疼，怂恿别人去送死。但是就像耶稣在被钉上十字架的一刻，他作为人子的使命就终结了，他会复活升入天国。老侠要求别人“诚实”，做圣徒，他自己率先作出了榜样，他确实做到了自己说的，一切诋毁都显得苍白，让我无话可说，只能献上自己的敬意。&lt;/p&gt;
&lt;p&gt;（最后，是我从书中的一些摘录:）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于“理想”&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;老侠：不能实现的才是理想，能实现的就不是理想。理想对人的意义不在于它可以实现，变成现实的好处利益，而在于它为人类反省自身提供了一个绝对的尺度或参照系。理想来自现实的残缺，它激发人们对现实的不满、对自身的不满，因而激发人们对自身和现实的怀疑和批判。&lt;/p&gt;
&lt;p&gt;老侠：天堂只在虚无飘渺处，在天上，而人间、地上没有天堂，永远没有。凡是企图建立人间的尘世的世俗天堂的任何理想，只要一投入实践，都注定要创造出人间地狱、尘世灾难。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;关于“自由”&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;老侠：自由所允许的束缚只有自律式的自我约束。西方的自由社会也有种种约束，道德的、法律的、宗教的，但这些约束在一个可以自我选择的制度中，都能还原为一种自愿的自我约束。道德是我选择的伦理标准，法律是我投票认可的社会规则，宗教是我信仰的终极价值。&lt;/p&gt;
&lt;/blockquote&gt;</description></item><item><title>Go从GitHub安装命令时指定commit/tag</title><link>https://blog.yuantops.com/tech/go-install-cmd-on-specific-git-tag/</link><pubDate>Mon, 14 May 2018 09:49:03 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/go-install-cmd-on-specific-git-tag/</guid><description>&lt;p&gt;Go的版本管理是一大痛点，最近我就亲身经历了一遭。在&lt;a href=&#34;https://blog.yuantops.com/tech/hugo-travis-ci-auto-deploy-to-gh-pages/&#34;&gt;Blog自动部署实践&lt;/a&gt;一文中，我把部署博客的工作流交给了Travis
CI。第二天，我照例打开Google Analytics查看访问量，发现前一天的访问量跌到0：一定出了什么问题。&lt;/p&gt;
&lt;p&gt;我从GitHub上把 &lt;code&gt;gh-pages&lt;/code&gt; 分支pull下来，grep我的Google Analysis跟踪码，居然没有。在本地用 &lt;code&gt;hugo&lt;/code&gt;
命令生成静态文件，在public目录里发现每篇文章的html页面都包含Google Analytics跟踪代码。到此基本确定问题：Travis
CI build生成的静态网页货不对版，因为默认使用最新版本 &lt;code&gt;hugo&lt;/code&gt; 命令，所以绝对是 &lt;code&gt;hugo&lt;/code&gt; 版本更新导致的兼容问题。&lt;/p&gt;
&lt;p&gt;解法也很简单，在 &lt;code&gt;.travis.yml&lt;/code&gt; 文件里安装指定版本的 &lt;code&gt;hugo&lt;/code&gt; 命令，让它和我本地&lt;code&gt;hugo&lt;/code&gt;命令的版本号保持一致。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.travis.yml&lt;/code&gt; 用go get安装Go命令。虽然官方不支持指定commit，但我在&lt;a href=&#34;https://stackoverflow.com/questions/30188499/how-to-do-go-get-on-a-specific-tag-of-a-github-repository&#34;&gt;Stackoverflow:How to do
“go get” on a specific tag of a github
repository&lt;/a&gt;
上找到了曲线救国方法，摘录如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. Run the get command without the tag - it should clone the master branch.
2. Move to the clone directory and checkout the tag or branch that you want.
3. Run the go get command again, it should process the command on the checked out branch.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事实上，这个方法行之有效。更新后， &lt;code&gt;.travis.yml&lt;/code&gt; 文件的install部分长这样:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;install:
- go get -d github.com/spf13/hugo
- cd $GOPATH/src/github.com/spf13/hugo
- git checkout tags/v0.20.7
- go get github.com/spf13/hugo
- cd $TRAVIS_BUILD_DIR
- hugo version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我指定安装v0.20.7版本的hugo，并手工打出版本号确认。重新部署后，Google Analytics统计恢复正常。&lt;/p&gt;</description></item><item><title>本博客现已支持HTTPS</title><link>https://blog.yuantops.com/tech/announcement-blog-https-supported/</link><pubDate>Sat, 12 May 2018 12:59:10 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/announcement-blog-https-supported/</guid><description>&lt;p&gt;赶个晚集，给博客加上了HTTPS支持。现在以&lt;code&gt;http://&lt;/code&gt;访问博客，会自动跳转到&lt;code&gt;https://&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;感谢Cloudflare提供的福利，让个人博客也能免费享受SSL。&lt;/p&gt;</description></item><item><title>Blog自动部署实践: Hugo &#43; Travis CI -&gt; GitHub Pages</title><link>https://blog.yuantops.com/tech/hugo-travis-ci-auto-deploy-to-gh-pages/</link><pubDate>Sat, 12 May 2018 08:45:52 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/hugo-travis-ci-auto-deploy-to-gh-pages/</guid><description>
&lt;p&gt;这个博客托管在GitHub
Pages上已经有一段时间。最初使用的静态站点生成工具是Jekyll，后来&lt;a href=&#34;http://blog.yuantops.com/tech/transfer-from-jekyll-to-hugo/&#34;&gt;换成Hugo&lt;/a&gt;，因为是免费，一直都还比较满意。只有一个小痛点，博客从写完到部署的步骤多：写文章
-&amp;gt; build -&amp;gt;
deploy…&lt;/p&gt;
&lt;p&gt;我之前&lt;a href=&#34;http://blog.yuantops.com/tech/emacs-orgmode-hugo-with-oxpandoc/&#34;&gt;写过一篇用Emacs写博客的workflow&lt;/a&gt;，把&amp;rdquo;写文章&amp;rdquo;的流程优化了一把。之后又小打小闹，用GitHub的webhook做了一个commit
message关键字触发的小服务，把&amp;rdquo;build&amp;rdquo;和&amp;rdquo;deploy&amp;rdquo;做成自动化。这个服务跑在免费的Google
Cloud上，使用体验还不错，可惜主机没续费，服务直接停掉，源码也丢失了。&lt;/p&gt;
&lt;p&gt;随手Google一把GitHub Page的持续集成，才后知后觉地发现自己想要的东东已经有了成熟解决方案，而且还可以 &lt;strong&gt;免费&lt;/strong&gt;
用：&lt;a href=&#34;https://travis-ci.org/&#34;&gt;Travis CI&lt;/a&gt;。于是我颇愉快地接受它，并简单地在这里记录下来。&lt;/p&gt;
&lt;h1 id=&#34;什么是travis-ci&#34;&gt;什么是Travis CI&lt;/h1&gt;
&lt;p&gt;一个持续化集成平台，类似Jenkins。功能强大，和GitHub的集成尤其好，我们用它部署个人博客算大材小用。它有两个版本:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://travis-ci.org/&#34;&gt;https://travis-ci.org/&lt;/a&gt; 免费版本，可以集成GitHub的public项目&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://travis-ci.com/&#34;&gt;https://travis-ci.com/&lt;/a&gt; 商业版本，可以集成GitHub的private项目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们使用第一个，免费版本。&lt;/p&gt;
&lt;h1 id=&#34;本博客现状回顾&#34;&gt;本博客现状回顾&lt;/h1&gt;
&lt;p&gt;在进一步描述具体步骤之前，有必要先简要回顾本博客的现状：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;生成静态站点文件&lt;/li&gt;
&lt;li&gt;两个git分支, &lt;code&gt;hugo&lt;/code&gt;: 存放博客源码, &lt;code&gt;gh-pages&lt;/code&gt;: 存放Hugo生成的静态站点文件&lt;/li&gt;
&lt;li&gt;自定义域名: `blog.yuantops.com`, 而不是默认的yuantops.github.io&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;配置travis-ci&#34;&gt;配置Travis CI&lt;/h1&gt;
&lt;h2 id=&#34;为travis-ci生成github-token&#34;&gt;为Travis CI生成GitHub Token&lt;/h2&gt;
&lt;p&gt;打开GitHub。路径: &amp;ldquo;Settings&amp;rdquo;-&amp;gt;&amp;ldquo;Developer settings&amp;rdquo;-&amp;gt;&amp;ldquo;Personal access
tokens&amp;rdquo;-&amp;gt;&amp;ldquo;Generate new token&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;因为是public项目，而且Travis CI是用来push代码，所以只需勾选 &lt;code&gt;public_repo&lt;/code&gt;, &lt;code&gt;repo:status&lt;/code&gt;,
&lt;code&gt;repo_deployment&lt;/code&gt; 三项。&lt;/p&gt;
&lt;p&gt;Token一会儿就会隐藏，不能找回，所以拷贝好，进入下一步。&lt;/p&gt;
&lt;h2 id=&#34;配置travis-ci构建选项&#34;&gt;配置Travis CI构建选项&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;用GitHub方式登录Travis CI(&lt;a href=&#34;https://travis-ci.org/&#34;&gt;https://travis-ci.org/&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Settings&amp;rdquo;-&amp;ldquo;General&amp;rdquo; 勾选&amp;rdquo;Build only if .travis.yml is present&amp;rdquo;和&amp;rdquo;Build
pushed branches&amp;rdquo;两项。&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Settings&amp;rdquo;-&amp;ldquo;Environment Variables&amp;rdquo;
添加&amp;rdquo;GITHUB&lt;sub&gt;TOKEN&lt;/sub&gt;&amp;ldquo;，值是上一步得到的Token&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;在git根目录下添加-travis-yml-文件&#34;&gt;在git根目录下添加 &lt;code&gt;.travis.yml&lt;/code&gt; 文件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;language: go
go:
- &amp;quot;1.8&amp;quot; # 指定Golang 1.8
# Specify which branches to build using a safelist
# 分支白名单限制: 只有hugo分支的提交才会触发构建
branches:
only:
- hugo
install:
# 安装最新的hugo
- go get github.com/spf13/hugo
script:
# 运行hugo命令
- hugo
deploy:
provider: pages # 重要，指定这是一份github pages的部署配置
skip-cleanup: true # 重要，不能省略
local-dir: public # 静态站点文件所在目录
target-branch: gh-pages # 要将静态站点文件发布到哪个分支
github-token: $GITHUB_TOKEN # 重要，$GITHUB_TOKEN是变量，需要在GitHub上申请、再到配置到Travis
fqdn: blog.yuantops.com # 如果是自定义域名，此处要填
keep-history: true # 是否保持target-branch分支的提交记录
on:
branch: hugo # 博客源码的分支
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把 &lt;code&gt;.travis.yml&lt;/code&gt; 放到hugo分支，push到GitHub。&lt;/p&gt;
&lt;h1 id=&#34;自动部署&#34;&gt;自动部署&lt;/h1&gt;
&lt;p&gt;上述操作完成后，自动部署就生效了。我们写完一篇博客，只需在hugo分支提交commit、再push到GitHub，Travis
CI会自动触发后续的构建、部署动作。&lt;/p&gt;</description></item><item><title>用Benchmark验证sync.Pool对GC latency的优化效果</title><link>https://blog.yuantops.com/tech/sync-pool-benchmark/</link><pubDate>Fri, 11 May 2018 10:33:25 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/sync-pool-benchmark/</guid><description>
&lt;p&gt;可能是为了避免重复造轮子，Go官方库推出了sync.Pool:一个thread-safe、可回收/重用对象的内存池。对性能优化狂魔而言，sync.Pool无疑是一个优化GC的好工具，因为理论上重用对象会减少了GC次数，缩短latency。这篇文章是sync.Pool的性能验证报告：sync.Pool确实能极大减少GC次数。&lt;/p&gt;
&lt;h1 id=&#34;benchmark关注什么&#34;&gt;Benchmark关注什么？&lt;/h1&gt;
&lt;p&gt;在写Benchmark代码之前，要先确定如何衡量GC效果。很直观地，GC次数越少，效果越好。但GC次数的粒度太大，说服力不够，还需要其他的指标。&lt;/p&gt;
&lt;p&gt;这篇文章&lt;a href=&#34;https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/&#34;&gt;Golang real time
gc&lt;/a&gt;
给我了答案。不断往一个size固定的buffer里覆盖写入数据，记录写入耗时。被覆盖掉的数据会变成垃圾，继而触发GC，所以耗时就是latency。&lt;/p&gt;
&lt;p&gt;原文引述如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;The benchmark program repeatedly pushes messages into a size-limited buffer. Old messages constantly expire and become garbage.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是，Benchmark的实现，以及关注的指标就确定了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GC次数&lt;/li&gt;
&lt;li&gt;数据写入耗时&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;代码实现&#34;&gt;代码实现&lt;/h1&gt;
&lt;h2 id=&#34;不用sync-pool的实现&#34;&gt;不用sync.Pool的实现&lt;/h2&gt;
&lt;p&gt;见&lt;a href=&#34;https://play.golang.org/p/049Xmy1lTfV&#34;&gt;https://play.golang.org/p/049Xmy1lTfV&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)
const (
windowSize = 200000
msgCount = 100000000
)
type (
message []byte
buffer map[int]message
)
var worst time.Duration
func mkMessage(n int) message {
m := make(message, 1024)
for i := range m {
m[i] = byte(n)
}
return m
}
func pushMsg(b *buffer, highID int) {
start := time.Now()
m := mkMessage(highID)
(*b)[highID%windowSize] = m
elapsed := time.Since(start)
if elapsed &amp;gt; worst {
worst = elapsed
}
}
func main() {
b := make(buffer, windowSize)
for i := 0; i &amp;lt; msgCount; i++ {
pushMsg(&amp;amp;b, i)
}
fmt.Println(&amp;quot;Worst push time: &amp;quot;, worst)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;用sync-pool的实现&#34;&gt;用sync.Pool的实现&lt;/h2&gt;
&lt;p&gt;见&lt;a href=&#34;https://play.golang.org/p/Wop29wN7&#34;&gt;https://play.golang.org/p/Wop29wN7&lt;/a&gt;&lt;sub&gt;Dp&lt;/sub&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;sync&amp;quot;
&amp;quot;time&amp;quot;
)
const (
windowSize = 200000
msgCount = 100000000
)
type (
message []byte
buffer map[int]message
)
var worst time.Duration
//pool for statistics model
var statModelPool = sync.Pool{
New: func() interface{} {
return make(message, 1024)
},
}
func mkMessage(n int) message {
m := statModelPool.Get().(message)
for i := range m {
m[i] = byte(n)
}
return m
}
func pushMsg(b *buffer, highID int) {
start := time.Now()
m := mkMessage(highID)
if highID &amp;gt; windowSize {
statModelPool.Put((*b)[highID%windowSize])
}
(*b)[highID%windowSize] = m
elapsed := time.Since(start)
if elapsed &amp;gt; worst {
worst = elapsed
}
}
func main() {
b := make(buffer, windowSize)
for i := 0; i &amp;lt; msgCount; i++ {
pushMsg(&amp;amp;b, i)
}
fmt.Println(&amp;quot;Worst push time: &amp;quot;, worst)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;运行代码&#34;&gt;运行代码&lt;/h1&gt;
&lt;p&gt;因为要观察GC次数，我们需要打开GODEBUG的GCTRACE开关`GODEBUG=gctrace=1`。&lt;/p&gt;
&lt;p&gt;(下面的数据是在我的Thinkpad T450上跑出来的。)&lt;/p&gt;
&lt;h2 id=&#34;不使用sync-pool的实现&#34;&gt;不使用sync.Pool的实现&lt;/h2&gt;
&lt;p&gt;触发454次GC，最差写入耗时50.40ms。&lt;/p&gt;
&lt;p&gt;摘录一部分output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ GODEBUG=gctrace=1 go run benchmark_gc.go
gc 1 @0.041s 0%: 0.044+0.39+0.037 ms clock, 0.13+0.19/0.26/0.40+0.11 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 4 P
...
gc 454 @106.994s 4%: 0.012+29+0.045 ms clock, 0.048+1.6/26/39+0.18 ms cpu, 422-&amp;gt;437-&amp;gt;219 MB, 439 MB goal, 4 P
Worst push time: 50.401524ms
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;用sync-pool的实现-1&#34;&gt;用sync.Pool的实现&lt;/h2&gt;
&lt;p&gt;触发22次GC，最差写入耗时36.14ms&lt;/p&gt;
&lt;p&gt;摘录一部分output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; GODEBUG=gctrace=1 go run benchmark_gc_pool.go
gc 1 @0.045s 0%: 0.047+1.2+0.077 ms clock, 0.19+0.12/1.1/0.50+0.30 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 4 P
# command-line-arguments
gc 1 @0.007s 6%: 0.051+2.2+0.024 ms clock, 0.15+0.32/2.1/1.5+0.073 ms cpu, 4-&amp;gt;4-&amp;gt;3 MB, 5 MB goal, 4 P
.....
gc 22 @76.006s 0%: 0.015+53+0.039 ms clock, 0.062+1.7/32/0.62+0.15 ms cpu, 401-&amp;gt;401-&amp;gt;205 MB, 411 MB goal, 4 P
Worst push time: 36.141858ms
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;结论&#34;&gt;结论&lt;/h1&gt;
&lt;p&gt;sync.Pool的效果很不错，值得尝试。&lt;/p&gt;</description></item><item><title>Emacs Golang开发环境配置指南</title><link>https://blog.yuantops.com/tech/emacs-config-go-dev-environ/</link><pubDate>Thu, 04 Jan 2018 00:31:08 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/emacs-config-go-dev-environ/</guid><description>
&lt;h1 id=&#34;安装go&#34;&gt;安装Go&lt;/h1&gt;
&lt;p&gt;虽然像是废话，但为了配置过程的完整性，还是记下来吧。&lt;/p&gt;
&lt;p&gt;官网install链接: &lt;a href=&#34;https://golang.org/doc/install&#34;&gt;https://golang.org/doc/install&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;装好后记得配置 &lt;code&gt;$GOPATH&lt;/code&gt; 。为了能在任何地方使用Go编译出来的命令，还可以把 &lt;code&gt;$GOPATH/bin&lt;/code&gt; 附到环境变量$PATH。&lt;/p&gt;
&lt;p&gt;我在Mac上使用iTerm2+oh-my-zsh，所以把它们写到 &lt;code&gt;.zshrc&lt;/code&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# go path
export GOPATH=~/go
# add go commands to system path
export PATH=$GOPATH/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;让go-get命令绕过great-wall的束缚&#34;&gt;让go get命令绕过Great Wall的束缚&lt;/h1&gt;
&lt;p&gt;有了Go的开发环境，我们就可以用它编译、安装一些十分有用的小命令了。但在此之前，还有一些客观存在的技术障碍需要扫除。&lt;/p&gt;
&lt;p&gt;一般 &lt;code&gt;go get&lt;/code&gt;
命令会自动帮我们下载源码、编译、安装命令，如果托管源码的网站被block了(如gopkg.in)，整个过程就会卡住，卡到人抓狂(记得在内心f**k
GFW哦~)。&lt;/p&gt;
&lt;p&gt;这时，如果电脑上刚好运行着shadowsocks，事情就变得简单了。go get
支持http_proxy和https_proxy，我们需要动一点手脚，把sock5协议转换成http协议。&lt;/p&gt;
&lt;p&gt;(以下步骤的前提是电脑上运行着shadowsocks。)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装 polipo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew install polipo
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置 polipo 在家目录下新建 &lt;code&gt;.polipo&lt;/code&gt; 文件，内容如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#必填
socksParentProxy = &amp;quot;localhost:1080&amp;quot;
socksProxyType = socks5
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行 polipo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;polipo &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认会监听8123端口的http请求。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在go get命令前加上http_proxy参数&lt;/p&gt;
&lt;p&gt;以不幸被墙的cobra命令为例,它的代码网址是https协议,用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https_proxy=127.0.0.1:8123 go get -v github.com/spf13/cobra/cobra
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是http_proxy, 用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http_proxy=127.0.0.1:8123 go get -v github.com/blah/blah
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;安装goimports-gocode等有用工具&#34;&gt;安装goimports，gocode等有用工具&lt;/h1&gt;
&lt;h2 id=&#34;goimports&#34;&gt;goimports&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;goimports命令能自动格式化代码，自动添加、移除imports，而且与Emacs集成良好。可以替代官方gofmt命令。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go get -u golang.org/x/tools/cmd/goimports
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gocode&#34;&gt;gocode&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;gocode命令能为代码自动补全提供后台支持，是Emacs下Go代码补全必不可少的backend。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go get -u github.com/nsf/gocode
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;godef&#34;&gt;godef&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;godef命令能在Go源码变量、函数定义间跳转，是查看变量、函数、文件定义的好助手。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go get github.com/rogpeppe/godef
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;安装emacs&#34;&gt;安装Emacs&lt;/h1&gt;
&lt;p&gt;呃。。。这一步就略过吧&lt;/p&gt;
&lt;h1 id=&#34;emacs配置go-mode&#34;&gt;Emacs配置Go mode&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装go-mode&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加自动格式化的hook(需要安装goimports命令)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;;; Call Gofmt before saving
(setq gofmt-command &amp;quot;goimports&amp;quot;)
(add-hook &#39;before-save-hook &#39;gofmt-before-save)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置自动补齐(需要安装gocode命令)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;;;autocomplete
(set (make-local-variable &#39;company-backends) &#39;(company-go))
(company-mode)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置自动跳转按键(需要安装godef命令)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;;; Godef jump key binding
(local-set-key (kbd &amp;quot;M-,&amp;quot;) &#39;godef-jump)
(local-set-key (kbd &amp;quot;M-.&amp;quot;) &#39;pop-tag-mark)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Orgmode利用ox-pandoc导出hugo博客的workflow</title><link>https://blog.yuantops.com/tech/emacs-orgmode-hugo-with-oxpandoc/</link><pubDate>Sun, 10 Dec 2017 13:16:22 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/emacs-orgmode-hugo-with-oxpandoc/</guid><description>
&lt;p&gt;使用Emacs有一年多了吧，终于开始体会到它的强大。这段盘旋上升的磨合期，值得写几篇文章记录一下。这篇博客就是我用orgmode + hugo写博客的个人实践，希望对orgmode中文用户/hugo blogger有所启发。&lt;/p&gt;
&lt;h1 id=&#34;之前的workflow&#34;&gt;之前的workflow&lt;/h1&gt;
&lt;p&gt;自从转到hugo后，我发博客的workflow是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在org文件里添加内容&lt;/li&gt;
&lt;li&gt;按下 &lt;code&gt;C-c C-e&lt;/code&gt; （export命令），再按 &lt;code&gt;C-s&lt;/code&gt; (只导出当前subtree)，再按 &lt;code&gt;m o&lt;/code&gt;
(导出格式markdown)，生成markdown 内容&lt;/li&gt;
&lt;li&gt;把markdown内容保存到 &lt;code&gt;hugo/content/&lt;/code&gt; 目录，手动加上文件头(front matter)&lt;/li&gt;
&lt;li&gt;本地部署hugo server，检查效果。无误则运行部署脚本 &lt;code&gt;deploy.sh&lt;/code&gt; push到github仓库的 &lt;code&gt;hugo&lt;/code&gt; 分支&lt;/li&gt;
&lt;li&gt;github上我给 &lt;code&gt;hugo&lt;/code&gt; 分支加了webhook，会触发构建，部署生成的html内容到 &lt;code&gt;gh-pages&lt;/code&gt; 分支&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这段流程一直还凑合，直到我的博客里出现表格：org导出的markdown表格会变成一坨翔，我要在第4步浪费很多时间人肉调整格式。&lt;/p&gt;
&lt;p&gt;怒google一把，发现是&lt;a href=&#34;http://orgmode.org/manual/Markdown-export.html&#34;&gt;org markdown官方导出引擎不支持table&lt;/a&gt;导致的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Since md is built on top of the HTML back-end, any Org constructs not supported by Markdown, such as tables, the underlying html back-end (see HTML export) converts them.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;搜索时我发现有网友提到 &lt;code&gt;ox-pandoc&lt;/code&gt;
，点进去github主页看了看，pandoc和orgmode的天作之合啊。pandoc对表格的支持无懈可击，还有啥好说，马上就决定是它了！&lt;/p&gt;
&lt;h1 id=&#34;emacs安装ox-pandoc&#34;&gt;Emacs安装ox-pandoc&lt;/h1&gt;
&lt;h2 id=&#34;安装pandoc&#34;&gt;安装pandoc&lt;/h2&gt;
&lt;p&gt;因为ox-pandoc是对pandoc的调用封装，所以首先得装上pandoc。pandoc可能是haskell语言最著名的作品了，支持非常多种文件格式的互转，极其强大。官网有安装文档，不再赘述。
确认已装好:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pandoc -v
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装ox-pandoc&#34;&gt;安装ox-pandoc&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;官方github: &lt;a href=&#34;https://github.com/kawabata/ox-pandoc&#34;&gt;ox-pandoc主页&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;init.el&lt;/code&gt; 加上elpa源:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;(setq package-archives
&#39;((&amp;quot;melpa&amp;quot; . &amp;quot;http://melpa.milkbox.net/packages/&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加hook:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;(with-eval-after-load &#39;ox
(require &#39;ox-pandoc))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删掉旧的markdown导出：&lt;/p&gt;
&lt;p&gt;找到类似配置，删掉&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;&#39;(require &#39;ox-md nil t)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重启emacs&lt;/p&gt;
&lt;p&gt;打开org文件，按下 &lt;code&gt;C-c C-e&lt;/code&gt; ，弹出的orgmode export dispather窗口中应该出现了 &lt;code&gt;p&lt;/code&gt;
开头的很多选项，而且原来 &lt;code&gt;m&lt;/code&gt; 开头的markdown选项不见了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;配置ox-pandoc-参数&#34;&gt;配置ox-pandoc 参数&lt;/h2&gt;
&lt;p&gt;ox-pandoc的导出选项可以配置在文档头部，就像org原生的导出选项配置一样。将官方wiki上关于文档的描述翻译如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Value nil overrides preceding option setting.
nil会覆盖之前为某个选项设置的值。
Value t means only specify option, but not its value.
t会打开某个选项的开关，而不会设置它的值。
Options are delimited by space.
多个选项间用空格分隔。
#+PANDOC_OPTIONS: can be specified multiple times.
#+PANDOC_OPTIONS: 能多次使用。
If you want to specify the option value which include space character, quote entire option-value pair.
如果某个选项的值包含空格，那么要将“选项-值”都放到引号里。
Specifying Multiple values to single options by using colon-sparated lists.
给一个选项指定多个值，要使用逗号分隔的列表。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如，ox-pandoc给导出文档添加目录:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#+PANDOC_OPTIONS: toc-depth:3
#+PANDOC_OPTIONS: toc:t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再例如，使用ox-pandoc &lt;code&gt;C-c C-e p l&lt;/code&gt; 导出latex文档，如果中文不能正常显示，需要加上这两行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#+PANDOC_OPTIONS: pdf-engine:xelatex
#+PANDOC_OPTIONS: &amp;quot;variable:CJKmainfont:Noto Sans CJK SC&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;xelatex&lt;/em&gt; 是latex的一种处理引擎，对中文支持不错。如何安装xelatex，这里不赘述。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Noto Sans CJK SC&lt;/em&gt; 是我系统(Ubuntu)上安装的中文字体。用下面的命令查看安装了哪些中文字体:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fc-list :lang=zh
# 命令output: 字体名是两个冒号之间的、第一个逗号前的内容
# /usr/share/fonts/opentype/noto/NotoSansCJK-Light.ttc: Noto Sans CJK SC,Noto Sans CJK SC Light:style=Light,Regular
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;配置hugo-front-matter的snippet&#34;&gt;配置hugo front-matter的snippet&lt;/h2&gt;
&lt;p&gt;如果你像我一样正在用Emacs的 &lt;code&gt;yasnippet&lt;/code&gt;
包，可以参考我的做法，迅速添加带标题和日期的hugo文件头。这里参考了：&lt;a href=&#34;http://whyarethingsthewaytheyare.com/setting-up-the-blog/#workflow&#34;&gt;setting-up-the-blog&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;添加yasnippet模板文件，然后在org的subtree开头按下 &lt;code&gt;hmatter [TAB]&lt;/code&gt; 即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# key: hmatter
# name: hugo-blog-matter
# --
#+BEGIN_SRC xxx
+++
title = &amp;quot;`(cdr (assoc &amp;quot;ITEM&amp;quot; (org-entry-properties)))`&amp;quot;
date = &amp;quot;`(format-time-string &amp;quot;%Y-%m-%dT%H:%M:%S&amp;quot;)`Z&amp;quot;
Categories = [&amp;quot;Tech&amp;quot;]
Tags = [&amp;quot;&amp;quot;]
Description = &amp;quot;&amp;quot;
+++
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;现在的workflow&#34;&gt;现在的workflow&lt;/h1&gt;
&lt;p&gt;基本和之前的一样，但是现在导出按键顺序变成了&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;hmatter [TAB]&lt;/code&gt; 插入front-matter，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C-c C-e&lt;/code&gt; export命令，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C-s&lt;/code&gt; 只导出当前subtree，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p g&lt;/code&gt; 用pandoc导出github风格的markdown.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在导出的格式堪称完美，达到了我的预期。&lt;/p&gt;
&lt;p&gt;其实，最理想的workflow应该是写一个function把上述几步串起来，而且已经有人这么做了。等我哪天开始学elisp了，再来自己造轮子吧！&lt;/p&gt;</description></item><item><title>Emacs macOS配置中文字体</title><link>https://blog.yuantops.com/tech/emacs-macos-chn-font-conf/</link><pubDate>Sun, 10 Dec 2017 00:50:07 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/emacs-macos-chn-font-conf/</guid><description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;从网上攒来的emacs字体配置地址&lt;br /&gt;
&lt;a href=&#34;https://github.com/yuantops/emacs.d/blob/universal/lisp/init-fonts.el&#34;&gt;https://github.com/yuantops/emacs.d/blob/universal/lisp/init-fonts.el&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;列出系统提供的所有字体&lt;br /&gt;
参考链接 &lt;a href=&#34;http://cnborn.net/blog/2014/10/emacs-chinese-font-on-osx/&#34;&gt;http://cnborn.net/blog/2014/10/emacs-chinese-font-on-osx/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;(print (font-family-list))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;找到中文字体，添加到chn font list 开头&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>sed和awk学习笔记</title><link>https://blog.yuantops.com/tech/sed_awk_notes/</link><pubDate>Sat, 09 Dec 2017 17:12:59 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/sed_awk_notes/</guid><description>
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;为什么加上单引号: 防止shell
expansion&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Enclosing the instruction in single quotes is not requir ed in all cases but you should get in the habit of always doing it. The enclosing single quotes prevent the shell from interpreting special characters or spaces found in the editing instruction.(The shell uses spaces to determine individual arguments submitted to a program;characters that are special to the shell are expanded before the command is invoked.)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通用语法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;awk -f scriptfile file
sed -f sedscript file
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令的组成: pattern和procedure&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;sed&#34;&gt;sed&lt;/h2&gt;
&lt;h3 id=&#34;sed里的模式空间-pattern-space&#34;&gt;sed里的模式空间 pattern space&lt;/h3&gt;
&lt;p&gt;Sed maintains a pattern space, a workspace or temporary buffer where a
single line of input is held while the editing commands are applied.*&lt;/p&gt;
&lt;p&gt;pattern space的内容是动态的(dynamic)，sed脚本中的任何一条命令都可能改变其中内容。&lt;/p&gt;
&lt;p&gt;As a consequence, any sed command might change the contents of the
pattern space for the next command.&lt;/p&gt;
&lt;h3 id=&#34;sed的addressing策略&#34;&gt;sed的addressing策略&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;vim中的替换命令默认只对当前行生效；sed不一样，sed命令默认对所有行生效。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以在命令前指定address。address可以是一个正则表达式,a line number,或者line addressing
symbol&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If no address is specified, then the command is applied to each
line.&lt;/li&gt;
&lt;li&gt;If there is only one address, the command is applied to any line
matching the address.&lt;/li&gt;
&lt;li&gt;If two comma-separated addresses are specified, the command is
performed on the first line matching the first address and all
succeeding lines up to and including a line matching the second
address.&lt;/li&gt;
&lt;li&gt;If an address is followed by an exclamation mark (!), the
command is applied to all lines that do not match the address.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于行号：sed 内部维护的行号，不是文件的行号。输入是多个文件时，只会有一个行号1。 The line number refers
to an internal line count maintained by sed. This counter is not
reset for multiple input files. Thus, no matter how many files were
specified as input, there is only one line 1 in the input stream&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果指定了两个address,那么命令只会在它们组成的range内生效。理解为：第一个address enable，第二个address
disable。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;地址后面出现的惊叹号，作用是反转地址匹配结果。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;sed的命令分组&#34;&gt;sed的命令分组&lt;/h3&gt;
&lt;p&gt;用花括号给命令行分组{}，用来在命令里嵌套命令，或者对同一个地址应用多个命令。to nest one address inside
another or to apply multiple commands at the same address.&lt;/p&gt;
&lt;h3 id=&#34;sed常用命令&#34;&gt;sed常用命令&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;替换s&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;syntaxt: [address]s/pattern/replacement/flags&lt;/li&gt;
&lt;li&gt;As a metacharacter, the ampersand (&amp;amp;) represents the extent of
the pattern match, not the line that was matched.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除d&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;变形Transform y&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;syntax: [address] y/abc/xyz&lt;/li&gt;
&lt;li&gt;逐个字符替换，而不是逐个单词替换&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打印p&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输出pattern space的内容&lt;/li&gt;
&lt;li&gt;常用来debug&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打印行号= 跟在address后面的等号(=)会打印出匹配行的行号。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;读取文件内容r&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;syntax: [address]r file&lt;/li&gt;
&lt;li&gt;The read command reads the contents of file into the pattern
space after the addr essed line&lt;/li&gt;
&lt;li&gt;No subsequent command will affect the lines read from the file.
For instance, you can’t make any changes to the list of
companies that you’ve read into the file. However, commands that
address the original line will work.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;退出命令q&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;syntax: [line-address]q&lt;/li&gt;
&lt;li&gt;The quit command (q) causes sed to stop reading new input lines
(and stop sending them to the output)&lt;/li&gt;
&lt;li&gt;例子:
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- end list --&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 类似head -n 3
sed &#39;3q&#39; a.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;awk&#34;&gt;awk&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;awk是&amp;rdquo;输入驱动&amp;rdquo; input-driven. That is, nothing happens unless there are
lines of input on which to act. When you invoke the awk program, it
reads the script that you supply, checking the syntax of your
instructions. Then awk attempts to execute the instructions for each
line of input.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;假定“输入是结构化的”&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;begin-end-pattern&#34;&gt;BEGIN/END pattern&lt;/h3&gt;
&lt;p&gt;The &lt;strong&gt;BEGIN&lt;/strong&gt; pattern specifies actions that are performed before the
first line of input is read.&lt;/p&gt;
&lt;p&gt;If a program has only a BEGIN pattern, and no other statements, awk will
not process any input files.&lt;/p&gt;
&lt;p&gt;A BEGIN rule is executed once only, before the first input record is
read. Likewise, an END rule is executed once only, after all the input
is read.&lt;/p&gt;
&lt;h3 id=&#34;basic-programming-model&#34;&gt;Basic programming model&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;main input loop&lt;/strong&gt;: a routine that reads one line of input from a file
and makes it available for processing. Awk 默认提供，不需要手动实现。&lt;/p&gt;
&lt;p&gt;每一行都会执行。没有可读行时停止。&lt;/p&gt;
&lt;h3 id=&#34;模式匹配-pattern-matching&#34;&gt;模式匹配 pattern matching&lt;/h3&gt;
&lt;p&gt;与sed 类似，匹配到某种模式后才会执行命令。&lt;/p&gt;
&lt;p&gt;When awk reads an input line, it attempts to match each pattern-matching
rule in a script. Only the lines matching the particular pattern are the
object of an action.&lt;/p&gt;
&lt;p&gt;If no action is specified, the line that matches the pattern is printed
(executing the print statement is the default action)&lt;/p&gt;
&lt;h3 id=&#34;分隔符-fs-file-separator&#34;&gt;分隔符 FS file separator&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;默认FS: 空格&lt;/li&gt;
&lt;li&gt;单字符作分隔符&lt;/li&gt;
&lt;li&gt;多字符作分隔符: 被当做正则表达式&lt;/li&gt;
&lt;li&gt;一般在BEGIN section中定义FS。 Typically, the field and record separators
are defined in the BEGIN procedure because you want these values set
before the first input line is read.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;系统变量-system-variables&#34;&gt;系统变量 System Variables&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;FS: Field Seperator&lt;/li&gt;
&lt;li&gt;NF: 当前输入行的field count&lt;/li&gt;
&lt;li&gt;RS: record separator, 默认是换行符&lt;/li&gt;
&lt;li&gt;NR: 当前输入行的行号 the number of the current input record&lt;/li&gt;
&lt;li&gt;OFS: print 命令中，逗号会输出一个OFS。The output field separator (OFS) is
generated when a comma is used to separate the arguments in a print
statement.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;格式化输出-formatted-printing-printf&#34;&gt;格式化输出 Formatted Printing: &lt;strong&gt;printf&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;syntax: printf(format-expression[,arguments])&lt;/li&gt;
&lt;li&gt;format-expression: %-width.precision format-specifier。“-”表示左对齐&lt;/li&gt;
&lt;li&gt;The precision modifier, used for decimal or floating-point values,
controls the number of digits that appear to the right of the
decimal point. For string values, it controls the maximum number of
characters from the string that will be printed.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;向脚本中传递参数&#34;&gt;向脚本中传递参数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;awk &#39;script_content&#39; var=value datafile
awk -f scriptfile var=value datafile
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;字符串操作函数&#34;&gt;字符串操作函数&lt;/h3&gt;
&lt;p&gt;Awk Function
Description&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;gsub(r,s,t)&lt;/td&gt;
&lt;td&gt;Globally substitutes s for each match of the regular expression r in the string t. Returns the number of substitutions. If t is not supplied,defaults to $0.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;index(s,t)&lt;/td&gt;
&lt;td&gt;Returns position of substring t in string s or zero if not present.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;length(s)&lt;/td&gt;
&lt;td&gt;Returns length of string s or length of $0 if no string is supplied.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;match(s,r)&lt;/td&gt;
&lt;td&gt;Returns either the position in s wher e the regular expression r begins, or 0 if no occurrences are found. Sets the values of RSTART and RLENGTH.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;split(s,a,sep)&lt;/td&gt;
&lt;td&gt;Parses string s into elements of array a using field separator sep;retur ns number of elements. If sep is not supplied, FS is used. Array splitting works the same way as field splitting.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sprintf(“fmt”,expr)&lt;/td&gt;
&lt;td&gt;Uses pr intf for mat specification for expr.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sub(r,s,t)&lt;/td&gt;
&lt;td&gt;Substitutes s for first match of the regular expression r in the string t.Retur ns 1 if successful; 0 otherwise. If t is not supplied, defaults to$0.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;substr(s,p,n)&lt;/td&gt;
&lt;td&gt;Returns substring of string s at beginning position p up to amaximum length of n. If n is not supplied, the rest of the string from p is used.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tolower(s)&lt;/td&gt;
&lt;td&gt;Translates all uppercase characters in string s to lowercase and returns the new string.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;toupper(s)&lt;/td&gt;
&lt;td&gt;Translates all lowercase characters in string s to uppercase and returns the new string&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;使用-语法调用awk脚本&#34;&gt;使用#!语法调用awk脚本&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在脚本开头加上 #!/bin/awk -f&lt;/li&gt;
&lt;li&gt;用法: $ awkscript datafile&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>《Maven实战》摘抄</title><link>https://blog.yuantops.com/tech/maven-in-action-notes/</link><pubDate>Tue, 28 Nov 2017 19:16:30 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/maven-in-action-notes/</guid><description>
&lt;h2 id=&#34;关键词-a-id-sec-1-1-name-sec-1-1-a&#34;&gt;关键词&lt;a id=&#34;sec-1-1&#34; name=&#34;sec-1-1&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;“约定优于配置” Convention Over Configuration&lt;/li&gt;
&lt;li&gt;生命周期管理&lt;/li&gt;
&lt;li&gt;依赖管理：GAV坐标+scope&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;术语翻译-a-id-sec-1-2-name-sec-1-2-a&#34;&gt;术语翻译&lt;a id=&#34;sec-1-2&#34; name=&#34;sec-1-2&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;2&#34; cellpadding=&#34;6&#34; &gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th &gt;英文&lt;/th&gt;
&lt;th &gt;中文&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td &gt;artifact&lt;/td&gt;
&lt;td &gt;构件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td &gt;build&lt;/td&gt;
&lt;td &gt;构建&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td &gt;project&lt;/td&gt;
&lt;td &gt;项目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td &gt;group&lt;/td&gt;
&lt;td &gt;组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td &gt;module&lt;/td&gt;
&lt;td &gt;模块&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td &gt;archetype&lt;/td&gt;
&lt;td &gt;骨架&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td &gt;dependency mediation&lt;/td&gt;
&lt;td &gt;依赖调解&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td &gt;repository&lt;/td&gt;
&lt;td &gt;仓库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td &gt;phase&lt;/td&gt;
&lt;td &gt;阶段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td &gt;aggregation&lt;/td&gt;
&lt;td &gt;聚合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td &gt;reactor&lt;/td&gt;
&lt;td &gt;反应堆&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td &gt;property&lt;/td&gt;
&lt;td &gt;属性&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;关于主代码和测试代码位置-a-id-sec-1-3-name-sec-1-3-a&#34;&gt;关于主代码和测试代码位置&lt;a id=&#34;sec-1-3&#34; name=&#34;sec-1-3&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;在绝大多数情况下，应该把项目主代码放到src/main/java 目录下(遵循Maven的约定)，而无需额外的配置，Maven会自动搜寻该目录找到项目主代码。其次，该Java类的包名是com.juvenxu.mvnbook.helloword，这与之前在POM中定义的groupId和artifactId相吻合。一般来说，项目中Java类的包都应该基于项目的groupId和artifactId，这样更清晰，更加符合逻辑，也方便搜索构建或者Java类。
为了使项目结构保持清晰，主代码与测试代码应该分别位于独立的目录中。Maven项目中默认的主代码目录是src/main/java, 对应的，Maven项目中默认的测试代码目录是src/test/java。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关于pom配置中的scope-a-id-sec-1-4-name-sec-1-4-a&#34;&gt;关于POM配置中的scope&lt;a id=&#34;sec-1-4&#34; name=&#34;sec-1-4&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Maven 在编译项目主代码的时候需要使用一套classpath。其次，Maven在编译和执行测试时会使用另外一套classpath。上例中的JUnit就是一个很好的例子，该文件也以依赖的方式引入测试使用的classpath中，不同的是这里的依赖范围是test。最后，实际运行Maven项目的时候，又会使用一套classpath。
依赖范围就是用来控制依赖与这三种classpath(编译classpath, 测试classpath, 运行classpath)的关系。
scope为依赖范围，若依赖范围为test则表示该依赖只对测试有效(该依赖只会被加入到测试代码的classpath中)。换句话说，测试代码中的import JUnit代码是没有问题的，但是如果在主代码中用import JUnit代码，就会造成编译错误。如果不声明依赖范围，那么默认值就是compile，表示该依赖对主代码和测试代码都有效。
&lt;/code&gt;&lt;/pre&gt;
&lt;table border=&#34;2&#34; cellspacing=&#34;0&#34; cellpadding=&#34;6&#34; rules=&#34;groups&#34; frame=&#34;hsides&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope=&#34;col&#34; &gt;scope&lt;/th&gt;
&lt;th scope=&#34;col&#34; &gt;编译classpath有效&lt;/th&gt;
&lt;th scope=&#34;col&#34; &gt;测试classpath有效&lt;/th&gt;
&lt;th scope=&#34;col&#34; &gt;运行时classpath有效&lt;/th&gt;
&lt;th scope=&#34;col&#34; &gt;例子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td &gt;compile&lt;/td&gt;
&lt;td &gt;Y&lt;/td&gt;
&lt;td &gt;Y&lt;/td&gt;
&lt;td &gt;Y&lt;/td&gt;
&lt;td &gt;spring-core&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td &gt;test&lt;/td&gt;
&lt;td &gt;-&lt;/td&gt;
&lt;td &gt;Y&lt;/td&gt;
&lt;td &gt;-&lt;/td&gt;
&lt;td &gt;JUnit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td &gt;provided&lt;/td&gt;
&lt;td &gt;Y&lt;/td&gt;
&lt;td &gt;Y&lt;/td&gt;
&lt;td &gt;-&lt;/td&gt;
&lt;td &gt;servlet-api&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td &gt;runtime&lt;/td&gt;
&lt;td &gt;-&lt;/td&gt;
&lt;td &gt;Y&lt;/td&gt;
&lt;td &gt;Y&lt;/td&gt;
&lt;td &gt;JDBC驱动实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td &gt;system&lt;/td&gt;
&lt;td &gt;Y&lt;/td&gt;
&lt;td &gt;Y&lt;/td&gt;
&lt;td &gt;-&lt;/td&gt;
&lt;td &gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;关于打包生成可直接运行的jar-a-id-sec-1-5-name-sec-1-5-a&#34;&gt;关于打包生成可直接运行的jar&lt;a id=&#34;sec-1-5&#34; name=&#34;sec-1-5&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;默认打包生成的jar是不能够直接运行的，因为带有main方法的类信息不会添加到manifest中(打开jar文件中的META-INF/MANIFEST.MF文件，将无法看到Main-Class一行)。为了生成可执行的jar文件，需要借助maven-shade-plugin.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关于maven的坐标-a-id-sec-1-6-name-sec-1-6-a&#34;&gt;关于Maven的坐标&lt;a id=&#34;sec-1-6&#34; name=&#34;sec-1-6&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Maven 坐标为各种构件引入了秩序，任何一个构件都必须明确定义自己的坐标，而一组Maven坐标是通过一些元素定义的，它们是groupId, artifactId，version, packaging, classifier。
上述5个元素中，groupId, artifactId, version是必须定义的，packaging是可选的(默认为Jar)，而classifier是不能直接定义的。
groupId: 定义当前Maven项目隶属的实际项目。首先，Maven项目和实际项目不一定是一对一的关系。比如SpringFramework这一实际项目，其对应的Maven项目会有很多，如spring-core, spring-context等。这是由于Maven中模块的概念，因此，一个实际项目往往会被划分成很多模块。其次，groupId不应该对应项目隶属的组织或公司。原因很简单，一个组织下会有很多实际项目，如果groupId只定义到组织级别，而后面我们将看到，artifactId只能定义Maven项目(模块)，那么实际项目这个层将难以定义。最后，groupId的表示方式与Java包名的表示方式类似，通常与域名反向一一对应。
artifactId:该元素定义实际项目中的一个Maven项目(模块)，推荐的做法是使用实际项目名称作为artifactId的前缀。比如上例中的artifactId是nexus-indexer，使用了实际项目名nexus作为前缀，这样做的好处是方便寻找实际构件。
classifier:该元素用来帮助定义构建输出的一些附属附件。附属构件与主构件对应，。。。.javadoc和sources就是这两个附属构件的classifier。这样，附属构件也就拥有了自己唯一的坐标。。。。注意，不能直接定义项目的classifier，因为附属构件不是项目默认生成的，而是由附加的插件帮助生成的。
一般来说，一个项目的子模块都应该使用同样的groupId,如果它们一起开发和发布，还应该使用同样的version。此外，它们的artifactId还应该使用一致的前缀，以方便和其他项目区分。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关于maven构件的文件名-a-id-sec-1-7-name-sec-1-7-a&#34;&gt;关于Maven构件的文件名&lt;a id=&#34;sec-1-7&#34; name=&#34;sec-1-7&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;项目构件的文件名是与坐标相对应的，一般的规则为artifactId-version[-classifier].packaging, [-classifier]表示可选。
这里还要强调的一点是，packaging并非一定与构件扩展名对应，比如packaging为maven-plugin的构件构件扩展名为jar。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关于maven仓库-a-id-sec-1-8-name-sec-1-8-a&#34;&gt;关于Maven仓库&lt;a id=&#34;sec-1-8&#34; name=&#34;sec-1-8&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;得益于坐标机制，任何Maven项目使用任何一个构件的方式都是完全相同的。在此基础上，Maven可以在某个位置统一存储所有Maven项目共享的构件，这个统一的位置就是仓库。实际的Maven项目将不再各自存储其依赖文件，它们只需要声明这些依赖的坐标，在需要的时候（例如，编译项目的时候需要将依赖加入到classpath中），Maven会自动根据坐标找到仓库中的构件，并使用它们。
仓库布局：仓库路径与坐标的大致对应关系为groupId/artifactid/version/artifactId-verison.packaging
对于Maven来说，仓库只分两类：本地仓库和远程仓库。当Maven根据坐标寻找构件的时候，它首选会查看本地仓库，如果本地仓库存在此构件，则直接使用；如果本地仓库不存在此构件，或者需要查看是否有更新的构件版本，Maven仓库就会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。如果本地仓库和远程仓库都没有需要的构件，Maven就会报错。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关于快照版本-a-id-sec-1-9-name-sec-1-9-a&#34;&gt;关于快照版本&lt;a id=&#34;sec-1-9&#34; name=&#34;sec-1-9&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;在Maven的世界中，任何一个项目或者构件都必须有自己的版本。版本的的值可能是1.0.0,1.3-alpha-4,2.0,2.1-SNAPSHOT或者2.1-20091212.221212-12。其中，2.0,2.1-SNAPSHOT或者2.1-20091212.221212-12是不稳定的快照版本。
快照版本只应该在组织内部的项目或模块间依赖使用，因为这时，组织对于这些快照版本的依赖具有完全的理解以及控制权。项目不应该依赖于任何组织外部的快照版本依赖，由于快照版本的不稳定性，这样的依赖会造成现在的危险。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关于生命周期与插件绑定-a-id-sec-1-10-name-sec-1-10-a&#34;&gt;关于生命周期与插件绑定&lt;a id=&#34;sec-1-10&#34; name=&#34;sec-1-10&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Maven 拥有三套相互独立的生命周期，它们分别是clean, default和site。clean生命周期的目的是清理项目，default生命周期的目的是构建项目，而site生命周期的目的是建立项目站点。
每个生命周期包含一些阶段(phase),这些阶段是有顺序，并且后面的阶段依赖于前面的阶段，用户和Maven最直接的交互方式就是调用这些生命周期阶段。
Maven的生命周期与插件相互绑定，用以完成实际的构建任务。具体而言，是生命周期的阶段与插件的目标相互绑定，以完成某个具体的构建任务。
Maven在核心为一些主要的生命周期阶段绑定了很多插件的目标，当用户通过命令行调用生命周期阶段的时候，对应的插件目标就会执行相应的任务。
如果多个目标被绑定到同一个阶段的时候，这些插件声明的先后顺序决定了目标的执行顺序。
插件解析机制
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关于聚合-多模块-a-id-sec-1-11-name-sec-1-11-a&#34;&gt;关于聚合(多模块)&lt;a id=&#34;sec-1-11&#34; name=&#34;sec-1-11&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;为了方便用户构建项目，通常将聚合模块放在项目目录的最顶层，其他模块则作为聚合模块的子目录存在，这样当用户得到源码的时候，第一眼发现的就是聚合模块的POM，不用从多个模块中去寻找聚合模块来构建整个项目。
Maven会首先解析聚合模块的POM、分析要构建的模块、并计算出一个反应堆构建顺序(Reactor Build Order)，然后根据这个顺序依次构建各个模块。反应堆是所有模块组成的一个构建结构。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关于继承与聚合的关系-a-id-sec-1-12-name-sec-1-12-a&#34;&gt;关于继承与聚合的关系&lt;a id=&#34;sec-1-12&#34; name=&#34;sec-1-12&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;多模块项目中的聚合与继承其实是两个概念，其目的是完全不同的。前者主要是为了方便快速构建项目，后者主要是为了消除重复配置。
对于聚合模块来说，它知道有哪些被聚合的模块，但那些被聚合的模块不知道这个聚合模块的存在。
对于继承关系的父POM来说，它不知道有哪些子模块继承于它，但那些子模块都必须知道自己的父POM是什么。
在现有的实际项目中，读者往往发现一个POM既是聚合POM，又是父POM，这么做主要是为了方便。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关于反应堆的构建顺序-a-id-sec-1-13-name-sec-1-13-a&#34;&gt;关于反应堆的构建顺序&lt;a id=&#34;sec-1-13&#34; name=&#34;sec-1-13&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;在一个多模块的Maven项目中，反应堆(Reactor)是指所有模块组成的一个构建结构。对于单模块的项目，反应堆就是该模块本身，但对于多模块项目来说，反应堆就包含了各模块之间继承与依赖的关系，从而能够自动计算出合理的模块构建顺序。
模块间的依赖关系会将反应堆构成一个有向非循环图(DAG)，各个模块是该图的节点，依赖关系构成了有向边。这个图不允许出现循环，因此，当出现模块A依赖于B，而B又依赖于A的情况出现时，Maven就会报错。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关于选择性构建单个多个模块-a-id-sec-1-14-name-sec-1-14-a&#34;&gt;关于选择性构建单个多个模块&lt;a id=&#34;sec-1-14&#34; name=&#34;sec-1-14&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;-am, --also-make 同时构建所列模块的依赖模块
-amd, --also-make-dependencies 同时构建依赖于所列模块的模块
-pl, --projects &amp;lt;args&amp;gt; 构建指定的模块，模块间用逗号隔开
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关于maven灵活构建-属性-a-id-sec-1-15-name-sec-1-15-a&#34;&gt;关于Maven灵活构建-&amp;gt;属性&lt;a id=&#34;sec-1-15&#34; name=&#34;sec-1-15&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Maven支持的6类属性分别为：
1. 内置属性：主要有两个内置属性--${basedir}表示项目根目录，即包含pom.xml文件的目录；${version}表示项目版本
2. POM属性：用户可以使用该类属性引用POM文件中对应元素的值。例如，${project.artifactId}就对应了&amp;lt;project&amp;gt;&amp;lt;artifactId&amp;gt;元素的值。
3. 自定义属性：用户可以在POM的&amp;lt;properties&amp;gt;元素下自定义的Maven属性。
4. Settings属性：与POM属性同理，用户使用以setting. 开头的属性引用settings.xml 文件中XML元素的值，如常用的${settings.localRepository}指向用户本地仓库的地址。
5. Java系统属性：所有Java系统属性都可以使用Maven属性引用。例如${user.home}指向了用户目录。用户可以使用mvn help:system 查看所有的Java系统属性。
6. 环境变量属性：所有环境变量都可以使用以env. 开头的Maven属性引用。例如${env.JAVA_HOME}指代了JAVA_HOME环境变量的值。用户可以使用mvn help:system 查看所有的环境变量
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关于maven灵活构建-资源过滤-a-id-sec-1-16-name-sec-1-16-a&#34;&gt;关于Maven灵活构建-&amp;gt;资源过滤&lt;a id=&#34;sec-1-16&#34; name=&#34;sec-1-16&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Maven属性默认只有在POM中才会被解析。也就是说，${db.username}放到POM中会变成test，但是如果放到src/main/resources/目录下的文件中，构建的时候它仍然还是${db.username}。
资源文件的处理其实是maven-resource-plugin做的事情。它默认的行为只是将项目主资源文件复制到主代码编译输出目录中，将测试资源文件复制到测试代码编译输出目录中。不过只要通过一些简单的POM配置，该插件就能够解析资源文件中的Maven属性，即开启资源过滤。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关于maven灵活构建-profile-a-id-sec-1-17-name-sec-1-17-a&#34;&gt;关于Maven灵活构建-&amp;gt;Profile&lt;a id=&#34;sec-1-17&#34; name=&#34;sec-1-17&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;为了能让构建在各个环境下方便地移植，Maven引入了profile的概念。profile能够在构建的时候修改POM的一个子集，或者添加额外的配置元素。用户可以通过使用很多方式激活profile，以实现构建在不同环境下的移植。
Maven 支持很多种激活Profile的方式。
1. 命令行激活
2. settings文件激活
3. 系统属性激活
4. 操作系统环境激活
5. 文件存在与否激活
6. 默认激活
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>MyBatis generator生成Dao和Mapper小记</title><link>https://blog.yuantops.com/tech/mybatis-mbg-cmd/</link><pubDate>Tue, 17 Oct 2017 10:30:53 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/mybatis-mbg-cmd/</guid><description>
&lt;h2 id=&#34;需下载文件-a-id-sec-1-1-name-sec-1-1-a&#34;&gt;需下载文件&lt;a id=&#34;sec-1-1&#34; name=&#34;sec-1-1&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Mybatis Generator jar包&lt;/p&gt;
&lt;p&gt;下载地址 &lt;a href=&#34;https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core&#34;&gt;https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JDBC 驱动jar 包&lt;/p&gt;
&lt;p&gt;对MySQL数据库而言，下载MySQL connector。下载地址 &lt;a href=&#34;https://mvnrepository.com/artifact/mysql/mysql-connector-java&#34;&gt;https://mvnrepository.com/artifact/mysql/mysql-connector-java&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;配置config-xml-a-id-sec-1-2-name-sec-1-2-a&#34;&gt;配置config.xml&lt;a id=&#34;sec-1-2&#34; name=&#34;sec-1-2&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;config.xml 文件指定自动生成代码时的一些配置项：数据库的url, 用户名密码，生成类名、导出地址等。&lt;/p&gt;
&lt;p&gt;数据库url, 用户名，密码是最重要的配置。&lt;/p&gt;
&lt;p&gt;下面是示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE generatorConfiguration
PUBLIC &amp;quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&amp;quot;
&amp;quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&amp;quot;&amp;gt;
&amp;lt;generatorConfiguration&amp;gt;
&amp;lt;!--数据库驱动, 注意jar包版本号与实际下载的版本号一致--&amp;gt;
&amp;lt;classPathEntry location=&amp;quot;mysql-connector-java-3.1.13.jar&amp;quot;/&amp;gt;
&amp;lt;context id=&amp;quot;DB2Tables&amp;quot; targetRuntime=&amp;quot;MyBatis3&amp;quot;&amp;gt;
&amp;lt;commentGenerator&amp;gt;
&amp;lt;property name=&amp;quot;suppressDate&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
&amp;lt;property name=&amp;quot;suppressAllComments&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
&amp;lt;/commentGenerator&amp;gt;
&amp;lt;!--数据库链接地址账号密码, 更新此处--&amp;gt;
&amp;lt;jdbcConnection driverClass=&amp;quot;com.mysql.jdbc.Driver&amp;quot; connectionURL=&amp;quot;jdbc:mysql://xx.xxx.xxx.xx:36360/?characterEncoding=UTF-8&amp;quot; userId=&amp;quot;xxx&amp;quot; password=&amp;quot;xxx&amp;quot;&amp;gt;
&amp;lt;/jdbcConnection&amp;gt;
&amp;lt;javaTypeResolver&amp;gt;
&amp;lt;property name=&amp;quot;forceBigDecimals&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
&amp;lt;/javaTypeResolver&amp;gt;
&amp;lt;!--生成Model类存放位置--&amp;gt;
&amp;lt;javaModelGenerator targetPackage=&amp;quot;domain&amp;quot; targetProject=&amp;quot;src&amp;quot;&amp;gt;
&amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
&amp;lt;property name=&amp;quot;trimStrings&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
&amp;lt;/javaModelGenerator&amp;gt;
&amp;lt;!--生成映射文件存放位置--&amp;gt;
&amp;lt;sqlMapGenerator targetPackage=&amp;quot;dao&amp;quot; targetProject=&amp;quot;src&amp;quot;&amp;gt;
&amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
&amp;lt;/sqlMapGenerator&amp;gt;
&amp;lt;!--生成Dao类存放位置--&amp;gt;
&amp;lt;javaClientGenerator type=&amp;quot;XMLMAPPER&amp;quot; targetPackage=&amp;quot;mapper&amp;quot; targetProject=&amp;quot;src&amp;quot;&amp;gt;
&amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
&amp;lt;/javaClientGenerator&amp;gt;
&amp;lt;!--生成对应表及类名--&amp;gt;
&amp;lt;table tableName=&amp;quot;%&amp;quot; enableCountByExample=&amp;quot;true&amp;quot; enableUpdateByExample=&amp;quot;true&amp;quot; enableDeleteByExample=&amp;quot;true&amp;quot; enableSelectByExample=&amp;quot;true&amp;quot; selectByExampleQueryId=&amp;quot;true&amp;quot;&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;/context&amp;gt;
&amp;lt;/generatorConfiguration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;运行命令-a-id-sec-1-3-name-sec-1-3-a&#34;&gt;运行命令&lt;a id=&#34;sec-1-3&#34; name=&#34;sec-1-3&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;将上面的文件放到一个目录，结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tree
.
├── config.xml
├── mybatis-generator-core-1.3.0.jar
└── mysql-connector-java-3.1.13.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行命令，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -jar mybatis-generator-core-1.3.0.jar -configfile config.xml -overwrite
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自动生成的&lt;code&gt;src&lt;/code&gt;目录包含生成的代码。&lt;/p&gt;</description></item><item><title>整理Java有限状态机</title><link>https://blog.yuantops.com/tech/fsm_and_java_implementation/</link><pubDate>Thu, 12 Oct 2017 14:30:53 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/fsm_and_java_implementation/</guid><description>
&lt;h2 id=&#34;有限状态机fsm及它的构成要素-a-id-sec-1-1-name-sec-1-1-a&#34;&gt;有限状态机FSM及它的构成要素&lt;a id=&#34;sec-1-1&#34; name=&#34;sec-1-1&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition.&lt;/p&gt;
&lt;p&gt;有限状态机由状态集合, 初始状态, 状态转移条件定义。&lt;/p&gt;
&lt;h2 id=&#34;java实现-a-id-sec-1-2-name-sec-1-2-a&#34;&gt;Java实现&lt;a id=&#34;sec-1-2&#34; name=&#34;sec-1-2&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;根据FSM定义，可以抽象出Java的3种数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态(State)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;事件(Event)&lt;/p&gt;
&lt;p&gt;事件触发状态转移，是状态机的输入。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上下文(Context)&lt;/p&gt;
&lt;p&gt;上下文，可以包含各种Condition。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子：当前状态A，此时输入事件E，如果满足条件C，会导致状态A转换到状态B。这种情况下，A,B是State，E是Event，C是Context下的Condition。&lt;/p&gt;
&lt;h2 id=&#34;具体代码-a-id-sec-1-3-name-sec-1-3-a&#34;&gt;具体代码&lt;a id=&#34;sec-1-3&#34; name=&#34;sec-1-3&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;状态机运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public State run() {
for (State s = initState; s != null; s = s.next(context)) {
// do something here
}
return state;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;State, Event用Enum, 且State一定包含next() method&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public enum State {
INIT(0, &amp;quot;未初始化&amp;quot;) {
@Override
public State next(Context context) {
switch (context.getEvent()) {
case Event1:
return context.condition1() ? STATE_1 : STATE_2;
default:
return null;
}
}
},
STATE_1(1, &amp;quot;状态1&amp;quot;) {
@Override
public State next(Context context) {
context.setState(STATE_1);
switch (context.getEvent()) {
case Event1:
return context.condition2() ? STATE_3 : null;
default:
return null;
}
}
};
private Byte code;
private String desc;
State(int code, String desc) {
this.code = (byte) code;
this.desc = desc;
}
public abstract State next(Context context);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Context是一系列Condition组合得到的interface&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Context {
void setState(State state);
/**
* 得到Event input
* @return
*/
EventEnum getEvent();
/**
* 是否满足条件1
* @return
*/
Boolean condition1();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;组合得到FSM的定义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class FSM implements Context {
private EventEnum event;
private State state;
public FSM(State initState) {
this.state = initState;
}
public State run() {
for (State s = initState; s != null; s = s.next(this)) {
}
return state;
}
@Override
public EventEnum getEvent() {
return event;
}
//implements conditions
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>JMX学习笔记</title><link>https://blog.yuantops.com/tech/jmx-overview/</link><pubDate>Sat, 22 Jul 2017 18:26:25 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/jmx-overview/</guid><description>
&lt;p&gt;JMX，全称&lt;code&gt;Java Management Extensions&lt;/code&gt;，借用贾宝玉的一句话描述它：「这个妹妹，我曾见过的。」&lt;/p&gt;
&lt;p&gt;见过却不熟悉，它在我心中是Java规范中比较冷门的一个角落。&lt;/p&gt;
&lt;p&gt;几次看到Java的招聘JD要求对JMX的理解，所以，在Oracle官网翻到教程，跟着学习学习。&lt;/p&gt;
&lt;h2 id=&#34;oracle教程地址&#34;&gt;Oracle教程地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/jmx/TOC.html&#34;&gt;Java Management Extensions(JMX): Table of Contents&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这份文档讲的内容很基础，介绍了JMX的整体架构、用处、基础组件，以及给出了带代码的简单演示。&lt;/p&gt;
&lt;h2 id=&#34;jmx用来做什么&#34;&gt;JMX用来做什么？&lt;/h2&gt;
&lt;p&gt;JMX是Java 标准规范的一部分，可以用来 &lt;strong&gt;监控&lt;/strong&gt; 和 &lt;strong&gt;管理&lt;/strong&gt; JVM中运行时的资源。除了监控运行时占用的CPU、内核、线程资源，JMX还可以让你直接invoke 方法、修改对象属性（有点暴力了吧。。）。&lt;br /&gt;
- JDK中自带的&lt;code&gt;jconsole&lt;/code&gt;工具，利用的就是JMX。&lt;/p&gt;
&lt;p&gt;JMX可以将管理接口暴露成HTTP调用，这样，通过ip和端口号可以远程监控、管理服务器上的JVM。&lt;br /&gt;
- 远程调试需要打开服务器上打开某个端口，利用的也是JMX。&lt;br /&gt;
- Tomcat有个HTTP 的管理页面，用的也是JMX。&lt;/p&gt;
&lt;h2 id=&#34;jmx怎么用&#34;&gt;JMX怎么用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;监控JVM&lt;br /&gt;
JVM自带支持JMX，开箱即用(&lt;code&gt;out-of-box&lt;/code&gt;)。意味着，不需要额外操作就可以用&lt;code&gt;jconsole&lt;/code&gt;之类的命令监控JVM。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;监控Applicaiton&lt;br /&gt;
Application的实现得满足JMX标准。JMX标准是什么，见下文。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;jmx标准&#34;&gt;JMX标准&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;MBeans&lt;br /&gt;
JMX将它管理的对象称为&lt;code&gt;MBean&lt;/code&gt;。换言之，要使用JMX，就得把要管理的资源封装成MBeans。&lt;/p&gt;
&lt;p&gt;JMX定义了几类&lt;code&gt;MBeans&lt;/code&gt;，就标准MBeans(&lt;code&gt;Standard MBeans&lt;/code&gt;)而言，它是这么定义的：后缀为&lt;code&gt;MBean&lt;/code&gt;的interface(例如&lt;code&gt;HelloMBean&lt;/code&gt;), 以及除去&lt;code&gt;MBean&lt;/code&gt;后缀的实现MBean的实现类(这里就是&lt;code&gt;Hello&lt;/code&gt;)。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JMX Agent&lt;br /&gt;
JMX Agent又称为JMX Server，用来管理MBeans。&lt;/p&gt;
&lt;p&gt;关键的代码类似：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
ObjectName name = new ObjectName(&amp;quot;com.example:type=Hello&amp;quot;);
Hello mbean = new Hello();
mbs.registerMBean(mbean, name);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JMX Connector&lt;br /&gt;
用&lt;code&gt;JVM connector&lt;/code&gt;，MBean可以暴露给远程客户端，然后远程客户端就可以管理它了。&lt;/p&gt;
&lt;p&gt;常用的Connector包括：HTTP，RMI。与之对应的管理client: web浏览器，JMX Client。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;jmx的通知机制&#34;&gt;JMX的通知机制&lt;/h2&gt;
&lt;p&gt;JMX允许MBeans发送通知。&lt;/p&gt;
&lt;p&gt;如果MBeans实现了发送Notification的逻辑，就可以用&lt;code&gt;jconsole&lt;/code&gt;一类的工具收到通知。&lt;/p&gt;</description></item><item><title>申请Google Voice号码以及帐号充值小记</title><link>https://blog.yuantops.com/tech/apply-gv-no-and-purchase-credit/</link><pubDate>Fri, 21 Jul 2017 22:30:53 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/apply-gv-no-and-purchase-credit/</guid><description>
&lt;p&gt;现在，各种网站窥探用户隐私时越来越理直气壮：注册帐号，非得验证手机号不可。&lt;br /&gt;
（当然，他们往往打着&lt;a href=&#34;http://news.sina.com.cn/c/2017-05-03/doc-ifyetxec7370675.shtml&#34;&gt;《网络安全法》实施&lt;/a&gt;的旗号。）&lt;/p&gt;
&lt;p&gt;在知乎上看完网友写的&lt;a href=&#34;https://zhuanlan.zhihu.com/p/27807882&#34;&gt;在国内拥有一个美国电话号码的必要性&lt;/a&gt;，我立刻决定，自己也要来一个美国号码。&lt;/p&gt;
&lt;p&gt;下面是我艰辛的折腾记录。&lt;/p&gt;
&lt;h2 id=&#34;google-voice是个不错的选择&#34;&gt;Google Voice是个不错的选择&lt;/h2&gt;
&lt;p&gt;用户可以在Google Voice上申请虚拟美国电话号码，可以将短信转发到Google Voice的App (iOS上可以用Hangouts)。同时，资费良心，打给国内每分钟也才1美分。&lt;/p&gt;
&lt;p&gt;最最重要的，网上申请GV 号码的教程简直汗牛充栋，有了前人栽树，有什么理由不选它乘凉呢？&lt;/p&gt;
&lt;h2 id=&#34;失败-diy-textnow-自己申请&#34;&gt;[失败] DIY: TextNow + 自己申请&lt;/h2&gt;
&lt;p&gt;于是，怀着工科生的自信，我开始按&lt;a href=&#34;https://kn007.net/topics/free-application-for-google-voice-phone-number/&#34;&gt;这份教程&lt;/a&gt;的步骤一步步操作。&lt;/p&gt;
&lt;p&gt;我发现，第一个问题就难倒我：我的TextNow死也注册不成功。全程美国IP，但就是点到&amp;rdquo;submit&amp;rdquo; 就报错。&lt;/p&gt;
&lt;p&gt;其间尝试过TextNow 的手机app 注册，发现手机版好像不支持在线接听电话。&lt;/p&gt;
&lt;p&gt;总之，我被弄得没脾气。然后，我把目光投向了万能的淘宝……&lt;/p&gt;
&lt;h2 id=&#34;成功-淘宝搞定google-voice帐号&#34;&gt;[成功] 淘宝搞定Google Voice帐号&lt;/h2&gt;
&lt;p&gt;淘宝果然没有让人失望。输入&lt;code&gt;Google Voice&lt;/code&gt;关键字，宝贝不要太多。随便选了一家，拍下，然后按客服的指引操作，顺利搞定。&lt;/p&gt;
&lt;p&gt;淘宝卖家的做法还和我想的不太一样(原本我以为他们是现场申请的)。他们囤着很多Google 小号，每个小号申请一个Google Voice号码。你下单，他会把GV号码过户到你的Google帐号。过户全程需要美国IP，需要登录新旧两个Google 帐号，所以要么你把自己的帐号密码给卖家操作，要么卖家把他的小号给你操作。我自己操作的。&lt;/p&gt;
&lt;p&gt;你问工科生的自尊心么？呵呵，当然扔掉啦！&lt;/p&gt;
&lt;h2 id=&#34;下载hangouts&#34;&gt;下载Hangouts&lt;/h2&gt;
&lt;p&gt;iOS App Store中国区 &lt;strong&gt;居然&lt;/strong&gt; 可以下载Hangouts。挂上梯子，点开Hangouts，填刚刚申请到手的号码，此时发送的验证码在Google Voice的网页界面看到。&lt;/p&gt;
&lt;p&gt;到此为止，基本就搞定。&lt;/p&gt;
&lt;h2 id=&#34;给google-voice充钱&#34;&gt;给Google Voice充钱&lt;/h2&gt;
&lt;p&gt;充钱是额外选项，完全可以跳过。充了钱可以打电话，还是充点钱吧。&lt;/p&gt;
&lt;p&gt;我用建行的visa卡充的。开始死活不成功，把信用卡的bill address改成*美国地址*后顺利成功。这真是坑，莫名其妙的问题，误打误撞解了。&lt;/p&gt;
&lt;p&gt;讲真，看到付款邮件的那一刻，眼角有泪划过。&lt;/p&gt;</description></item><item><title>Emacs阅读C/C&#43;&#43;代码——生成TAGS文件</title><link>https://blog.yuantops.com/tech/emacs-create-etags/</link><pubDate>Wed, 19 Jul 2017 21:35:16 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/emacs-create-etags/</guid><description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;生成TAGS文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ find . -iname &amp;quot;*.[chCHS]&amp;quot; | etags -
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Emacs 导入TAGS文件&lt;br /&gt;
在emacs中，&lt;code&gt;M-x visit-tags-table&lt;/code&gt;，选择刚刚生成的TAG文件。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跳转到光标所在词对应的标签：&lt;code&gt;M-.&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;回退到上个位置：&lt;code&gt;M-*&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>mkfs 报invalid block count错误</title><link>https://blog.yuantops.com/tech/mkfs-t-not-supported/</link><pubDate>Tue, 27 Jun 2017 10:34:04 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/mkfs-t-not-supported/</guid><description>
&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;p&gt;在rh 5u7 上用mkfs 创建文件系统，命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkfs -q -t ext3 -L disk0 /dev/sdb1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;居然报错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;……invalid blocks count……
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;排查&#34;&gt;排查&lt;/h2&gt;
&lt;p&gt;仔细阅读&lt;code&gt;man mkfs&lt;/code&gt;使用文档，是这样写的，没发现哪里用得不对。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkfs [-V] [-t fstype] [fs-options] filesys [blocks]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Google，发现是&lt;a href=&#34;https://unix.stackexchange.com/questions/39998/creating-an-ext4-partition-fails-with-invalid-blocks-count&#34;&gt;mkfs 解析参数发生了错误&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;原因很简单，&lt;code&gt;mkfs&lt;/code&gt; 其实是&lt;code&gt;mkfs.type&lt;/code&gt; 的快捷方式。5u 的mkfs 版本过低，不支持&lt;code&gt;-t&lt;/code&gt;参数，所以阴差阳错把最后的参数&lt;code&gt;/dev/sdb1&lt;/code&gt; 当作了&lt;code&gt;[blocks]&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;解法&#34;&gt;解法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;安装&lt;code&gt;e4fsprogs&lt;/code&gt;，这是操作ext4 的工具包。官方文档&lt;a href=&#34;https://rhn.redhat.com/errata/RHEA-2009-0217.html&#34;&gt;在此&lt;/a&gt;。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;改用&lt;code&gt;mkfs.ext4&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkfs.ext4 -q -t ext3 -L disk0 /dev/sdb1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>JVM 和Java GC 笔记</title><link>https://blog.yuantops.com/tech/jvm-gc-note-1/</link><pubDate>Wed, 21 Jun 2017 23:32:37 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/jvm-gc-note-1/</guid><description>
&lt;h2 id=&#34;学习材料&#34;&gt;学习材料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;讲义地址： &lt;a href=&#34;http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html&#34;&gt;http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Youtube 视频地址： &lt;a href=&#34;https://www.youtube.com/watch?v=DoJr5QQYsl8&#34;&gt;Video The JVM and Java Garbage Collection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;java-jvm概述&#34;&gt;Java &amp;amp; JVM概述&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Garbage Collection is automatic.&lt;/li&gt;
&lt;li&gt;Java source code is compiled into byte code.&lt;/li&gt;
&lt;li&gt;Byte code is stored in .class files&lt;/li&gt;
&lt;li&gt;.class files are loaded into a Java Virtual Machine(JVM) and executed.&lt;/li&gt;
&lt;li&gt;A seperated JVM is created for each Java application. (备注：！每个Java程序都对应着一个单独的JVM)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;gc-的职责&#34;&gt;GC 的职责&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;为新对象分配memory&lt;/li&gt;
&lt;li&gt;确保被引用的对象留在memory Ensuring that any referenced objects(live objects) remain in memory&lt;/li&gt;
&lt;li&gt;回收死掉的对象占用的memory Recovering memory used by objects that no longer reachable(dead objects)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;gc的stages&#34;&gt;GC的stages&lt;/h2&gt;
&lt;p&gt;step 1. marking(标记将被删除的对象)&lt;br /&gt;
step 2. Normal Deletion/sweeping(删除标记的对象)&lt;br /&gt;
step 3. Deletion with Compacting (整理内存，把碎片归拢)&lt;/p&gt;
&lt;h2 id=&#34;generational-collection&#34;&gt;Generational Collection&lt;/h2&gt;
&lt;p&gt;出发点：Java中绝大多数对象的生存周期很短。
因此按generation 来运行GC, 可以将memory 分为三部分：&lt;/p&gt;
&lt;h3 id=&#34;young-generation-for-young-objs&#34;&gt;Young Generation(for young objs)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Eden&lt;/li&gt;
&lt;li&gt;A &amp;ldquo;from&amp;rdquo; survivor space (S0)&lt;/li&gt;
&lt;li&gt;A &amp;ldquo;to&amp;rdquo; survivor space (S1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tenured-old-generation&#34;&gt;Tenured (old) Generation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;for old objs&lt;/li&gt;
&lt;li&gt;超过了Minor GC age theshold的obj, 被挪到这里&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;premanent-generation&#34;&gt;Premanent Generation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;for meta data, classes, and so on&lt;/li&gt;
&lt;li&gt;Contains metadata required by the JVM&lt;/li&gt;
&lt;li&gt;Class objs and methods&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;minor-gc&#34;&gt;Minor GC&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;发生在Young Generation，频繁发生&lt;/li&gt;
&lt;li&gt;fast，efficient。因为young gen space 通常很小，而且包含很多短命的obj&lt;/li&gt;
&lt;li&gt;熬过几次minor gc的obj，将被 &lt;strong&gt;promote&lt;/strong&gt; 到old generation space&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;major-gc&#34;&gt;Major GC&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;发生在old Generation的GC&lt;/li&gt;
&lt;li&gt;old generation space 比yong gen 大，被占用的space 缓慢增长&lt;/li&gt;
&lt;li&gt;infrequently, 而且花费的时间远多于 minor gc&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;aging-obj-in-yong-gen&#34;&gt;Aging Obj in Yong Gen&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;新Obj 被分配到eden space&lt;/li&gt;
&lt;li&gt;当eden space 满，触发minor GC: &amp;ldquo; &lt;strong&gt;Stop the world&lt;/strong&gt; &amp;ldquo; event (all the application threads stop)&lt;/li&gt;
&lt;li&gt;eden space满，则运行GC，把eden space 中活下来的obj + survivor space 中活下来的obj 移到另一个survivor space(反复来回倒), 并把这些obj 的age + 1&lt;/li&gt;
&lt;li&gt;如果obj的age 超过threshold(一般为15)， 将它挪到Old Gen&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;感受&#34;&gt;感受&lt;/h2&gt;
&lt;p&gt;除了官方的文档、视频，Oracle JDK还提供了demos 和samples, 自己可以实际操作，加深感受。&lt;/p&gt;</description></item><item><title>Free as in freedom</title><link>https://blog.yuantops.com/opinions/free-as-in-freedom/</link><pubDate>Sat, 10 Jun 2017 13:42:31 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/free-as-in-freedom/</guid><description>&lt;p&gt;记得很久以前，博客时代，流行过一种协议：RSS。它让人在不直接访问网站的情况下，也能第一时间得到内容更新。那时流行的还有最好用的RSS 阅读器：google reader。后来因为只花钱不赚钱，google关掉了google reader。再后来美国出现了facebook，中国出现了新浪微博、微信，大家转到社交平台上浏览帖子。而代表了互联网开放和分享的精神的RSS 协议，渐渐淡出了我们的视线，可以说死透了。&lt;/p&gt;
&lt;p&gt;突然回忆起RSS，是因为看到这两天的新闻&lt;a href=&#34;http://www.yicai.com/news/5298103.html&#34;&gt;网信办遏制低俗之风：“毒舌电影”等25个微信公号被永久封杀&lt;/a&gt; 。不止微信一家，百度、新浪微博上的娱乐博主都受波及。哭嚎遍野。令人觉得无比荒诞，又毛骨悚然。因为大家已经很配合地避开所有雷区，以为安安静静谈谈风月地赚钱很安全，但被现实无情打脸。&lt;/p&gt;
&lt;p&gt;暂且不论我国特殊的*国情*，单从生存哲学角度来看，这件事有非常清楚的警示意味：放弃自由，就不要怪别人将你宰杀。RSS 允许每个人通过一个订阅地址毫无阻碍地获取信息，是开放分享自由的代表，可惜不方便、不赚钱；封闭的微信、微博既有趣又方便，能交朋友还能赚钱，所以大家张开胸怀拥抱它。在选择微信、微博等封闭的圈子时，我们同时放弃了、被剥夺了一部分自由。&lt;/p&gt;
&lt;p&gt;对“微信、微博剥夺自由”这个论断，需要解释一番。这个批评并不单单针对它们两家，所有与它们一样、试图将用户生产的内容封闭在自己领地的社交媒体平台（例如facebook），都在论断涵盖的范围内。&lt;/p&gt;
&lt;p&gt;先来说说互联网时代的“自由”。为什么说RSS 是自由的？因为RSS 的设计，任何一个用户只要能接入互联网，他打开任何一个RSS 阅读器，就可以通过feed URL 看到别人发布的内容。URL 也是自由的。互联网上的信息通过一个个http开头的url被全世界所有人访问、被搜索引擎收录，编织成一张扁平的信息网络。这是技术带来的人类历史上从未有过的信息繁荣。每个人的身份是平等的，信息的流动是自由的。&lt;/p&gt;
&lt;p&gt;再来说说微信、微博、facebook 等平台的“不自由”。在微信公众号发文章，生成的URL 以mp.weixin.qq.com/ 开头——URL 是微信所独有的，虽然可以用别的浏览器打开，它的样式并不符合通用的html 标准。微信可以控制它的过期时间、能否在非微信浏览器中打开，以及随时删除。在这一点上要比facebook稍微好一点，facebook的帖子如果你没有登录，绝大部分是看不了的。微博也差不多。我们很方便地在手机上阅读微信公众号的帖子，但忽视了这样一个事实，一旦你将文章发表在微信公众号里，意味着你将无法被google百度等搜索引擎收录，也代表着互联网上其他地方的人不能自由地访问你的文章。换言之，微信、微博、facebook形成了一坐信息孤岛。&lt;/p&gt;
&lt;p&gt;为了留住用户，吸引流量，微信、微博、facebook选择为自己的内容建起屏障，从商业上考虑，这种行为可以理解，但对用户来说，这并不是什么好事。国内，微信坐拥腾讯这个靠山，已经渐渐占据我们大部分的上网时间，形成事实上的垄断。令人担心的是，依托微信生态正形成事实上的局域网。&lt;/p&gt;
&lt;p&gt;很多人在微信公众号刚刚崭露头角的时候就大声呼吁要对此保持警惕，很多人以为是杞人忧天或者矫情。直到最近的一次网络清理。很多人说这明明是网信办的锅，不能怪罪到腾讯或者百度或者新浪，但仔细想想，也不尽然。如果那些内容制造者没有将身家押宝在这几大平台上，假设他们靠自己的网站活着，那么网信办工信部对他们的封杀就会困难得多。回想遥远的博客时代，牛博网还流行的时候，要定点封杀某些博主没法做到，结局是整个牛博网都被封锁了，它的代价不可谓不大：技术上的，声誉上的。时间发展到2017年，微信微博百度头条，这几大流量巨头已成为垄断事实，想要封杀一些人或者封杀一个主题，甚至只要下一个命令，平台的运营人员动动鼠标就可以删除得干干净净。&lt;/p&gt;
&lt;p&gt;这真是一件可悲的事。技术的发展，形成更多管制上的便利。&lt;/p&gt;
&lt;p&gt;也许当我们将逐渐习惯这一切，好像事情从诞生的第一天起就应该是这样子。并不是这样子的。自由软件协会的创始人Richard Stallman 他的一生都在给自由软件(Free Software)布道，孤军奋战，活成大家眼中的怪人。有一本他的传记，书名叫*Free as in freedom*。自由软件虽然和现实的商业利益在某些方面冲突，但它的价值在于保证了人不被软件不会程序阻碍自由。起码我们每个人都应该有一些格外的警惕，毕竟，自由是非常重要的追求。&lt;/p&gt;</description></item><item><title>放弃Jekyll，拥抱Hugo</title><link>https://blog.yuantops.com/tech/transfer-from-jekyll-to-hugo/</link><pubDate>Sat, 06 May 2017 14:03:44 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/transfer-from-jekyll-to-hugo/</guid><description>&lt;p&gt;大约半年前，我更换了自己的工作电脑。装完系统后，开始装各种常用程序。&lt;/p&gt;
&lt;p&gt;一切都是那么美好，直到我开始尝试装Jekyll。各种依赖下不下来，或者版本对不上。前者要问候GFW，后者就是Ruby自己的锅了。我，一个Ruby盲，多次被毫不留情的依赖版本问题整崩溃。哪怕一次次长夜痛哭，最终也没有成功。&lt;/p&gt;
&lt;p&gt;直到有一天，我看到小巧精炼的&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Hugo 是用Golang 写的静态网站生成器，只有一个二进制命令，开箱即用。而且，一个命令既可以生成静态文件，又可以直接开http server。所以，那些乱七八糟的gem 包， screw you!&lt;/p&gt;
&lt;p&gt;在将Jekyll迁移到Hugo的过程中，需要重新梳理一下文章的组织结构。不过这些都是小case。&lt;/p&gt;
&lt;p&gt;我的博客托管在Github Pages。Github本身支持Jekyll引擎，以前直接把markdown文件 push上去就可以，Github会自动帮忙渲染源文件。但Github不支持Hugo的文件布局，所以博客内容要先在本地生成html，再push到github。&lt;/p&gt;
&lt;p&gt;我的Github项目地址在&lt;a href=&#34;https://github.com/yuantops/blog/&#34;&gt;这里&lt;/a&gt;。&lt;code&gt;hugo&lt;/code&gt;分支存放源文件，&lt;code&gt;gh-pages&lt;/code&gt;存放编译好的html。&lt;/p&gt;
&lt;p&gt;最后，再次赞美go， 赞美Hugo!&lt;/p&gt;</description></item><item><title>About Page</title><link>https://blog.yuantops.com/about/</link><pubDate>Fri, 05 May 2017 14:27:36 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/about/</guid><description>
&lt;h2 id=&#34;关于博客&#34;&gt;关于博客&lt;/h2&gt;
&lt;p&gt;这里是 &lt;a href=&#34;https://github.com/yuantops&#34;&gt;@yuantops&lt;/a&gt; 的个人网志。&lt;/p&gt;
&lt;p&gt;记录值得沉淀的技术经验，还有我的思考感悟。&lt;/p&gt;
&lt;p&gt;欢迎用&lt;a href=&#34;https://blog.yuantops.com/index.xml&#34;&gt;RSS订阅&lt;/a&gt; (什么&lt;a href=&#34;https://zh.wikipedia.org/wiki/RSS&#34;&gt;是RSS订阅?&lt;/a&gt;)。&lt;/p&gt;
&lt;h2 id=&#34;关于我&#34;&gt;关于我&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2016年毕业，现在深圳工作。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;代码工程师。编程语言为Java，Golang。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Emacs 轻度用户，Google 轻度粉丝。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Hate GFW intensely.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;联系我&#34;&gt;联系我&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;邮箱 yuan.tops#gmail.com&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yuantops&#34;&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Archive Page</title><link>https://blog.yuantops.com/archives/</link><pubDate>Fri, 05 May 2017 14:27:36 +0800</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/archives/</guid><description/></item><item><title>写一套简易的视频点播系统——API Server</title><link>https://blog.yuantops.com/tech/write-your-own-vod-system-api/</link><pubDate>Wed, 20 Apr 2016 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/write-your-own-vod-system-api/</guid><description>
&lt;div id=&#34;table-of-contents&#34;&gt;
&lt;h2&gt;目录&lt;/h2&gt;
&lt;div id=&#34;text-table-of-contents&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#sec-1-1&#34;&gt;1. 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sec-1-2&#34;&gt;2. 工程代码结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sec-1-3&#34;&gt;3. 数据加载流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;前言-a-id-sec-1-1-name-sec-1-1-a&#34;&gt;前言&lt;a id=&#34;sec-1-1&#34; name=&#34;sec-1-1&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;作为一个视频点播系统的后台，应该为客户端(见 &lt;a href=&#34;http://blog.yuantops.com/tech/write-your-own-vod-system-android&#34;&gt;《写一套简易的视频点播系统&amp;#x2013;Android视频播放器》)&lt;/a&gt; 提供合理良好的API接口。同样，这里我们完成了最简单最基本的功能: 基于Spring MVC结构，当有http请求到来时，从MySQL数据库获取数据，返回json格式的数据。&lt;/p&gt;
&lt;h2 id=&#34;工程代码结构-a-id-sec-1-2-name-sec-1-2-a&#34;&gt;工程代码结构&lt;a id=&#34;sec-1-2&#34; name=&#34;sec-1-2&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;如下所示(省略了一些文件):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── main/
│   ├── java/
│   │   └── com/
│   │   └── yuantops/
│   │   ├── exception/ //Exception包
│   │   ├── tv/
│   │   │   ├── bean/ //Video对象，对应数据库中数据模型
│   │   │   ├── controller/ //Spring MVC中的C
│   │   │   ├── dao/ //数据库增删改查
│   │   │   ├── impl/ //service接口实现
│   │   │   └── service/ //service接口
│   │   └── utils/ //工具类
│   ├── resources/
│   │   ├── application-root-context.xml //Spring MVC启动加载的初始化上下文
│   │   ├── com/
│   │   │   └── yuantops/
│   │   │   └── tv/
│   │   │   ├── dao/ //对应dao java文件的xml文件，属于MyBatis配置
│   │   │   └── settings/ //MyBatis的配置信息
│   │   ├── config/ //编码、jdbc等配置文件
│   │   ├── front-servlet-context.xml //有HttpRequest时加载的上下文的配置
│   │   ├── log4j.xml //log4j的配置
│   │   └── properties/ //properties文件
│   │   └── jdbc.properties
│   └── webapp/
│   ├── WEB-INF/
│   │   ├── front_page/ //Spring MVC中的V
│   │   └── web.xml //整个web app的配置文件
│   └── index.jsp
└── test/ //测试文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数据加载流程-a-id-sec-1-3-name-sec-1-3-a&#34;&gt;数据加载流程&lt;a id=&#34;sec-1-3&#34; name=&#34;sec-1-3&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;和所有基于Servlet的Web Application一样，app的入口在web.xml，会加载application-root-context.xml和front-servlet-context.xml两个context。在这两个context中，会分别load一些config/目录下的配置文件。&lt;/p&gt;
&lt;p&gt;项目除了Spring MVC框架，还用了log4j(日志记录)，MyBatis(数据库连接)两个开源插件。&lt;/p&gt;</description></item><item><title>写一套简易的视频点播系统——Android视频播放器</title><link>https://blog.yuantops.com/tech/write-your-own-vod-system-android/</link><pubDate>Tue, 19 Apr 2016 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/write-your-own-vod-system-android/</guid><description>
&lt;p&gt;作为一个视频点播系统的客户端，播放视频是最基本的功能。本着最精简最偷懒的原则，这个客户端实现的功能包括:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;列表显示服务器上的直播视频、点播视频&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;点击列表条目，播放视频&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;工程代码结构-a-id-sec-1-1-name-sec-1-1-a&#34;&gt;工程代码结构&lt;a id=&#34;sec-1-1&#34; name=&#34;sec-1-1&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;客户端用Android Studio开发，整个项目的结构按gradle风格组织，代码路径是TopsTVPlayer/app/src/main/java。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
└── com
└── yuantops
└── tvplayer
├── adapter 加载list的Adapter
├── player 播放器组件
├── ui Fragment和Activity显示界面
└── util 工具类
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在player/包下，为直播视频和点播视频分别建立了一个类，因为Android原生的MediaPlayer组件对RTSP协议的直播流支持不全面，所以用原生的MediaPlayer播放点播视频(http)，用Vitamio提供的MediaPlayer播放直播视频(rtsp)。&lt;/p&gt;
&lt;h2 id=&#34;数据加载流程-a-id-sec-1-2-name-sec-1-2-a&#34;&gt;数据加载流程&lt;a id=&#34;sec-1-2&#34; name=&#34;sec-1-2&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;所有与网络的数据交流方法都封装在util/VolleySingleton.java文件中，使用了Volley这个优秀的开源http包。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;app启动时，首先加载WebAPIServerActivity.java界面，填写web服务器(提供api接口的服务器，不是多媒体服务器)的Base URL。点击确认按钮，会跳转到MainActivity。&lt;/li&gt;
&lt;li&gt;MainActivity包含两个Fragment。在Fragment被加载时，会调用VolleySingleton.java里的方法从web服务器上获取json格式的视频列表数据。数据下载完成后，会以list的形式显示出来。&lt;/li&gt;
&lt;li&gt;点击listView中的item，会跳转到VideoPlayActivity，初始化对应的直播/点播MediaPlayer。MediaPlayer组件根据视频的URL，从视频服务器获取数据，开始播放。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;引用的库-a-id-sec-1-3-name-sec-1-3-a&#34;&gt;引用的库&lt;a id=&#34;sec-1-3&#34; name=&#34;sec-1-3&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://actionbarsherlock.com/&#34;&gt;ActionbarSherlock&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vitamio.org/en/&#34;&gt;Vitamio SDK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mcxiaoke/android-volley&#34;&gt;Android Volley&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>写一套简易的视频点播系统</title><link>https://blog.yuantops.com/tech/write-your-own-vod-system/</link><pubDate>Sat, 09 Apr 2016 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/write-your-own-vod-system/</guid><description>&lt;p&gt;最初实习时，断断续续写Android代码，实现过用Helix架设流媒体服务器、手机播放流媒体视频的功能。后来一份实习，接触到Spring＋MyBatis框架，见识了它们在处理http请求和数据库连接上的便捷。这几天有些时间，想到可以将它们两者糅合到一起，实现一个完整的视频点播系统，既包括服务器(流媒体服务器，数据库，http服务器)，又包括客户端(Android)。虽然简陋，但工作起来毫无问题。&lt;/p&gt;
&lt;p&gt;整个工程运行起来的效果:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打开手机App，填写http服务器提供的api root URL，出现两个列表: 点播视频列表和直播列表。点击列表条目，开始播放视频。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过手动添加视频文件、修改数据库记录，可以更新视频列表。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样一个小系统，代码部分包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;http服务器: 暴露api给访问者，返回json数据。使用了Spring＋MyBatis框架，用Apache Tomcat做Web服务的容器。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Android客户端: 访问http服务器获取数据，并播放流媒体服务器推送的流媒体。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了写代码，还有一部分配置操作，主要是流媒体服务器Helix。&lt;/p&gt;
&lt;p&gt;写代码和配置服务器软件的工作量，加起来与计算机专业本科的课程设计工作量相当。这些工作将由三篇文章分别介绍。&lt;/p&gt;</description></item><item><title>权力与自由——重读《笑傲江湖》</title><link>https://blog.yuantops.com/opinions/power-and-freedom/</link><pubDate>Sun, 07 Feb 2016 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/power-and-freedom/</guid><description>
&lt;p&gt;《笑傲江湖》是非常著名的金庸小说，里面有极多典型形象：岳不群、令狐冲、风清扬等人物，独孤九剑、葵花宝典、辟邪剑法等武功以及“五岳剑派，同气连枝”、“无招胜有招”、“欲练此功，挥刀自宫”等带有哲学意味的话语都流传甚广。每隔一段时间把金庸小说过一遍，俨然已经成为习惯。这个寒假重读《笑傲》，除夕这天刚好读完。或许因为阅历增多，居然看出点新东西。&lt;/p&gt;
&lt;h3 id=&#34;影射时局&#34;&gt;影射时局&lt;/h3&gt;
&lt;p&gt;在《笑傲》的后记中金庸写道，“我写武侠小说是想写人性”，“这部小说通过书中一些人物，企图刻划中国三千多年来政治生活中的若干普遍现象”。金老已经清楚表明，书中人物事件皆有影射，意在描述政治斗争的普遍情况。以前这番自陈心迹，给了我们一盏明灯，将书中种种人物、情节照得格外明白：&lt;/p&gt;
&lt;p&gt;日月神教任我行已经将东方不败选为继承人，还传他《葵花宝典》。但东方不败仍反叛，将任我行关入西湖底。（林副统帅故事）&lt;/p&gt;
&lt;p&gt;日月神教教主东方不败，躲在黑木崖顶绣花，纵容身边人倒行逆施（四人帮）。自封“文成武德，仁义英明”教主（“伟大领袖×××”）；设立“教主宝训”，教众日夜背诵，“一天不读教主宝训，就吃不下饭，睡不着觉。读了教主宝训，练武有长进，打仗有气力”（红宝书）；以各种莫须有罪名屠戮教中元老（彭德怀，刘少奇……）。属下之人无不阿谀奉承，诚惶诚恐。&lt;/p&gt;
&lt;p&gt;任我行甫出江湖，对“文成武德”一套嗤之以鼻；等到重登教主宝座，看到众人下跪竟也觉得颇合理，听到众人满口奉承竟是无比受用，还加等自称“圣教主”。难怪令狐冲见了叹道，“坐在这位子上的，是任我行还是东方不败，却有甚么分别？”权力腐蚀人，一至于斯。&lt;/p&gt;
&lt;p&gt;《笑傲》在《明报》连载时，大陆政坛正斗得翻天覆地。金庸关心时局，更加之每日操刀社论，在作品里不免透露出个人倾向。他作为局外人，一眼看出腥风血雨的政坛背后是追求个人绝对权力的野心家，并且毫不留情地予以讽刺。《笑傲》在影射政治，评论往往止步于此。但如果仅仅是影射时局，未免将这部作品的格调看得低了，所以金庸自己也要说，他意图刻划政治中的“普遍现象”。&lt;/p&gt;
&lt;h3 id=&#34;权力斗争的三种出路&#34;&gt;权力斗争的三种出路&lt;/h3&gt;
&lt;p&gt;政治中的“普遍现象”是什么？无非是权力将一群人弄得死去活来。&lt;/p&gt;
&lt;p&gt;在《笑傲》中，金庸花了大力气写争夺权力的众生相，甚至可以说权力是全书的隐形主轴。避邪剑谱、葵花宝典之所以人人眼红，无非是练成绝学之后就有实力问鼎江湖权力的顶尖位置，荣誉、财富也将随之而来。岳不群处心积虑，隐忍十多年，最后不惜自宫也要练辟邪剑法；左冷禅偷学剑法，不外乎是为了最后吞并其余四派，当五岳盟主。野心家和阴谋家，在争权夺利时必须壮大自己，现实中靠金钱，小说里还可以用武功秘籍。&lt;/p&gt;
&lt;p&gt;争权夺利的野心家们，背后各有组织，连累许多人。日月神教和五岳剑派百年恩怨，无数流血牺牲。再加上魔教内部两次教主地位争夺，更腥风血雨。这些动乱，将很多怀有抱负的英雄裹挟进来做了炮灰。刘正风金盆洗手不得；梅庄四友逃避西湖也不行：金庸自己解释道，“他们都无法做到，卒以身殉，因为权力斗争不允许”。权力斗争无非三种出路：被卷进去做肉酱，做胜利者，保持超然。刘正风和梅庄四友，是第一种出路。&lt;/p&gt;
&lt;p&gt;但书中毕竟展现了其它情形：&lt;/p&gt;
&lt;p&gt;第二种出路，夺权成功的东方不败（以及复辟成功的任我行）。可是，东方不败作为书中权力最大的人，居然亲口对任盈盈说，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“一个人生而为女子，已比臭男子幸运百倍，何况你这般千娇百媚，青春年少。我若得能和你易地而处，别说是日月神教的教主，就算是皇帝老子，我也不做。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;到了权力顶峰，他已经丧失享受的能力，甚至羡慕起手下败将之女。为了赢得斗争，他付出了代价。金庸故意将他写得离奇可笑。任我行复仇成功，再次做教主，筹划歼灭五岳、吞并少林武当，可惜霸业未成就暴毙，宏图大业化作尘土。再显赫，再威武，再倒行逆施，终不免覆灭，这是古往今来政治的定理。&lt;/p&gt;
&lt;p&gt;第三种出路，超然隐士风清扬。风清扬厉害至极，剑法超凡，得以不卷入其中。金庸称其为“心灰意懒、惭愧懊丧而退隐”。这种情况只能算是少数。&lt;/p&gt;
&lt;p&gt;第一种情形最为普遍，“一将成名万骨枯”，是普通人难以抗衡的。刘正风和梅庄四友，他们毕竟有足够强的个人意志和足够清晰的眼光，纵然最后失败，也是非常不容易的。&lt;/p&gt;
&lt;h3 id=&#34;权力与自由&#34;&gt;权力与自由&lt;/h3&gt;
&lt;p&gt;在阴谋与斗争中，《笑傲》还讨论了个人的自由。（若不是后记中提到，我也许就忽略了）。这个角度非常有意思，值得讨论一番。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“生命诚可贵，爱情价更高。若为自由故，二者皆可抛。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;诗句歌颂自由，将它视作最宝贵的事物。正因为自由不易获得，所以才如此令人向往，这首诗才如此脍炙人口。《笑傲》里追求自由的人，居然十分稀少，十分独特。&lt;/p&gt;
&lt;p&gt;刘正风和曲洋，一正一邪，是书中最先出场的自由殉难者。其后还有梅庄四友。他们因自己的艺术追求，主动想从江湖仇杀中抽身，不能如愿，丢掉了自己性命。前面已经说过，他们是政治斗争的牺牲品。他们追求自由，却得不到自由。&lt;/p&gt;
&lt;p&gt;如果不身处政治斗争，是否自由呢？风清扬大侠，似乎是自由的，似乎又不自由。相比追寻艺术理想而殉身的刘正风、梅庄四友，他能依自身的独立意志行动，当然是自由。但他又如此消极，简直像只把头脑埋在沙里的鸵鸟逃避过去。他的身体自由，心却不自由。&lt;/p&gt;
&lt;p&gt;只有令狐冲是另类，金庸评论道“令狐冲不是大侠，是陶潜那样追求自由和个性解放的隐士”。天生的隐士，不热衷权力。任我行三番两次要他入教，许给他活命的练功心法、副教主的地位、宝贝女儿，他都不感冒。别人不能从武力上强迫他，他又不爱权力，身体和心似乎都自由了。&lt;/p&gt;
&lt;p&gt;但是，还有爱情。他暗恋小师妹，任盈盈热烈的追求使他心怀感激，直到最后小师妹死了，他才将心转移到任盈盈身上。一个皆大欢喜的结局。但金庸指出，任盈盈对令狐冲“主动”的爱，令“令狐冲的自由却又被锁住了”。这个评语何其犀利。任盈盈贵为魔教圣姑，热情无私的付出是一份巨大的人情，令狐冲不得不领。怀着报恩的心态，他才率人攻打少林寺，上黑木崖帮忙。这份恩情锁住了他，哪怕最后恩情变成爱情。金庸真是太犀利了，这眼光让人不服气不行。&lt;/p&gt;
&lt;p&gt;写到这里，看到被爱情所困的令狐冲，不由得想起毛姆在《月亮和六便士》里刻画的斯特里克兰德——在太平洋小岛上作画，与整个世界决裂，绝不被爱情友谊禁锢的天才画家。斯特里克兰德那样的隐士，又是何等彻底决绝。令狐冲不那么极端，当然也因此可爱得多了。&lt;/p&gt;
&lt;h3 id=&#34;几个小花絮&#34;&gt;几个小花絮&lt;/h3&gt;
&lt;p&gt;最后，这次重读，对几个老生常谈的问题找出了新证据。&lt;/p&gt;
&lt;h3 id=&#34;笑傲江湖-的朝代&#34;&gt;#《笑傲江湖》的朝代&lt;/h3&gt;
&lt;p&gt;金庸本人在后记说道，“本书没有历史背景，这表示，类似的情景可以发生在任何朝代”。话虽如此，书中仍然有一些朝代信息，可以供我们作有根据的推理。在“十四 论杯”一章中，祖千秋有这么一段：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;饮这绍兴状元红须用古瓷杯，最好是北宋瓷杯，南宋瓷杯勉强可用，但已有衰败气象，至于元瓷，则不免粗俗了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见得，笑傲江湖的年代不会早于宋、元。&lt;/p&gt;
&lt;p&gt;另外，在“三十五 复仇”一章，岳灵珊与林平之对话，有一段她说道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“英雄豪杰，少年时做过和尚，也不是没有。明朝开过皇帝太祖朱元璋，小时候便曾在黄觉寺出家为僧。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见得，也不会早于明朝。岳灵珊对朱元璋如此不敬，敢直呼其名，让人又不敢相信她是明朝子民。&lt;/p&gt;
&lt;p&gt;还有，在“二十二 脱困”一章，令狐冲抢了一位武官的衣服印信，要冒充他。这一段写道:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;他在怀中一搜，掏了一只大信封出来，上面盖有“兵部尚书大堂正印”的朱红大印，写着“告身”两个大字。打开信封，抽了一张厚纸出来，却是兵部尚书的一张委任令，写明委任河北沧州游击吴天德升任福建泉州府参将，克日上任。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;兵部是明清两代官制。此处印证了笑傲江湖的年代在明清二者之一是合理的。&lt;/p&gt;
&lt;p&gt;在“三十七 迫娶”一章中，令狐冲被仪琳的母亲、不戒和尚的老婆治住。书中是这么写的：&lt;br /&gt;
&amp;gt; 便在此时，头上一紧，头发已给抓住，跟着双足离地，随即天旋地转，身子在半空中迅速转动，原来那婆婆抓着他头发，将他甩得身子平飞，急转圈子，越来越快。&lt;/p&gt;
&lt;p&gt;清朝满人统治，汉人剃发留辫。如果是清朝，那么此处抓住的应该是“辫子”，而非“头发”。再者，清朝的民族矛盾严重，反清复明是江湖儿女的普遍想法。如果是在清朝，书中各方豪杰绝计不会闭口不提此节。&lt;/p&gt;
&lt;p&gt;总之，可以下如下结论：笑傲江湖的年代不早于明朝，这是百分百确定的。至于是明朝还是清朝，更可能是明朝。&lt;/p&gt;
&lt;h3 id=&#34;2-黑木崖的地址&#34;&gt;#2. 黑木崖的地址&lt;/h3&gt;
&lt;p&gt;书中说，“离平定州西北四十余里，山石殷红如血，一片长滩，水流湍急，那便是有名的猩猩滩。更向北行，两边石壁如墙，中间仅有一道宽约五尺的石道。”&lt;/p&gt;
&lt;p&gt;这是金庸设定的地点。有人翻出历史地理书，发现位置其实对不上。只能说金庸写书有纰漏。&lt;/p&gt;</description></item><item><title>2016年来了</title><link>https://blog.yuantops.com/life/yearly-summary-2015/</link><pubDate>Thu, 14 Jan 2016 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/life/yearly-summary-2015/</guid><description>
&lt;p&gt;2015年对我挺重要，这一年我做了这些事：&lt;/p&gt;
&lt;h3 id=&#34;去了国内几个城市&#34;&gt;去了国内几个城市&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;元旦 东北 沈阳，哈尔滨&lt;/strong&gt;&lt;br /&gt;
冷，非常冷，刷新了我感知的冷法。对我国辽阔疆域的气候有了冻成傻逼的认识。见到了松花江，冰面结实居然能跑汽车。索菲亚教堂好看，俄式风情很洋气。听到地道的东北口音，东北大妈说“哎呀我滴妈呀”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三月初 郑州&lt;/strong&gt;&lt;br /&gt;
回校途中在郑州停留。在火车站附近一个早点摊吃到味道极佳的胡辣汤。河南博物院青铜器仿佛不要钱一样，到处都是，各种鼎看饱了。见到距今八千年的骨笛，据说出土时仍能吹响，令人神往。各种妇好墓出土的文物。可惜因为馆里排练节目，没能欣赏到编钟演奏，一大遗憾。&lt;/p&gt;
&lt;p&gt;溜达到城隍庙，南方人第一次见识到有人唱戏的庙会。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五月底六月初 西安&lt;/strong&gt;&lt;br /&gt;
主要为听李志演唱会，顺带逛古都。西安真是古老与现代结合的城市，城墙保存得很好，旅游资源开发得很成熟。吃的各种面，各种馍，各种凉皮。说话一股黄土味。黄山险。&lt;/p&gt;
&lt;p&gt;碑林见到柳公权的《玄秘塔碑》，非常满足。而且还见到昭陵六骏，当真体态潇洒，神采非凡。&lt;/p&gt;
&lt;p&gt;陕西博物院非常精良，陈设精彩，唐风令人陶醉。&lt;/p&gt;
&lt;p&gt;兵马俑气势恢宏，叹为观止。古人太伟大。考古工作居然还在进行中，这是去了才知道的。&lt;/p&gt;
&lt;p&gt;华山险峻，名不虚传。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;七月初 广州&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;广州就是吃的天堂。各种粉，糖水，叉烧，点心……完全俘获了我的舌头，我的胃，我的心。仿佛走进了港剧，雷吼啊，噔噔噔，噔噔噔，周围的人说听不懂的话。生活气息好，节奏悠闲。&lt;/p&gt;
&lt;p&gt;吃到当地一种特色水果，鸡心果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;七月八月 杭州&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实习在西溪，远离城区。对杭州印象非常好，因为长这么大过马路时第一次被车让，受宠若惊。&lt;/p&gt;
&lt;p&gt;西湖太美了，自然风景和人文风景融在一起，走在附近就是享受。瞻仰了岳飞祠，看到跪在岳飞墓前的秦桧铁塑，痰迹斑斑。瞻仰了于谦墓。&lt;/p&gt;
&lt;p&gt;吃到无花果，姑娘(?读音如此)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;十月中旬 南京&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;南京开会，顺便一逛。南京桂花香，香到人醉晕晕的。夫子庙的文创，是我去过的国内景点里最用心最精致的。玄武湖磅礴霸气。南京博物馆也精彩，大篇幅介绍江南地区的历史，陈设角度有地方特色。江浙自古就是富庶之地，的确也值得骄傲。遇难同胞纪念馆很沉重，看过的人应该都更能体会和平的重量。逛了总统府。参观了中山陵。&lt;/p&gt;
&lt;p&gt;锅贴和鸭血粉丝汤好喝。南航的食堂，是我见过的高校食堂最浮夸的，好到令人发指。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;十二月底 黄山&lt;/strong&gt;&lt;br /&gt;
查济，一个老镇子，保存得很好的古老民居。里面的村民还原样过日子，感觉很好。&lt;/p&gt;
&lt;p&gt;黄山下雪，碰巧让我们赶上，真是人品爆发。雪后的黄山太美太秀丽，文字描述不过来。翻滚的云海，晶莹的雪景，我们都认为见过的自然景色里排第一。&lt;/p&gt;
&lt;p&gt;宏村，一个商业化的古镇。风景比查济好，但我更喜欢后者。&lt;/p&gt;
&lt;p&gt;黄山的臭鳜鱼一般，倒是黄山烧饼给我们留下了很深刻的印象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;十二月底 重庆 成都&lt;/strong&gt;&lt;br /&gt;
重庆，现代化的立体城市，给我的印象非常好。国内最洋气的城市，我们住的市中心高楼密度让我想起香港。半夜还有宵夜摊。太平民了。红油火锅极辣。&lt;/p&gt;
&lt;p&gt;在重庆吃到红毛丹，一种外表抄袭荔枝的长毛水果。&lt;/p&gt;
&lt;p&gt;成都的小吃很多，但城市不如重庆现代。见到熊猫基地的熊猫宝宝，心都被俘获，萌化了。但成都的生活节奏慢，非常适合养老。参观了武侯祠。&lt;/p&gt;
&lt;p&gt;成都吃了兔头。&lt;/p&gt;
&lt;h3 id=&#34;写了23篇博客&#34;&gt;写了23篇博客&lt;/h3&gt;
&lt;p&gt;其中原创8篇，以《&lt;a href=&#34;http://blog.yuantops.com/tech/config-ipv6-to-bypass-gfw-in-bupt&#34;&gt;北邮校园网通过配置IPv6使用Google服务&lt;/a&gt;》一篇的PV最高，看来GFW是天怒人怨，翻土啬是刚需。接下来要尽量提升原创的数量。&lt;/p&gt;
&lt;h3 id=&#34;完成两件重要的事&#34;&gt;完成两件重要的事&lt;/h3&gt;
&lt;p&gt;4月到6月憋小论文，想点子，仿真，写论文。06月16号投稿。07月20号收到论文录用通知。10月17号南京开会。拿到毕业论文的答辩资格。11月写毕业大论文，半个月左右搞定。顺利通过学院预评审，盲审没被抽中。坐等过年回来答辩，毕业。&lt;/p&gt;
&lt;p&gt;3月下旬拿到阿里云实习Offer。7月8月西溪实习。09月01号“拥抱变化”，士气惨淡。09月中旬拿到转正Offer。还拿了几个别的Offer，最后还是选择阿里，深圳的机会放弃了。因为实习所在的组氛围很好，带我的人我很佩服。10月30号和阿里签三方。人生的第一份工作，要离开北京，在新的城市开始新的生活。&lt;/p&gt;
&lt;h3 id=&#34;在豆瓣上将20本书标注为-读过&#34;&gt;在豆瓣上将20本书标注为“读过”&lt;/h3&gt;
&lt;p&gt;看书越来越困难，也许是社交网络上碎片信息看得太多，大脑处理长篇信息的能力在弱化。2015年学乖了，基本看完一本书就随手在豆瓣标一下（虽然可能还有漏掉的），居然有20本之多，颇出乎我的意料。&lt;/p&gt;
&lt;p&gt;另外一个变化，看书的主战场从纸质书变成了电子设备，Kindle都退居二线，手机上的多看阅读app成了绝对主力，睡前看一会儿。（多看app要是能和豆瓣合并就好了。）数字时代，电子阅读器就这样悄无声息地攻陷了传统的纸质书阵地，真是无可阻挡。我们能亲身体验到这次人类文明传承方式的伟大变革，也算荣幸。&lt;/p&gt;
&lt;p&gt;2015年最让我触动的网络文章是年轻记者鲸书的报道《&lt;a href=&#34;http://ent.sina.com.cn/y/w/2015-01-14/11454273129.shtml&#34;&gt;惊惶庞麦郎&lt;/a&gt;》。身居社会“上层”的人怎么看还在底层挣扎的小人物，这篇采访稿展示出一种鲜活的态度。文章掀起了非常激烈的讨论，评论泾渭分明地站成两队。我非常反感作者从鼻孔里哼出的嘲讽和毫不加掩饰的居高临下姿态，哪怕作者的写作功力很强，有让人羡慕的才气。这篇文章是我的一个反面教材，用来告诫自己不要成为用鼻孔看人的人，不要变得刻薄。&lt;/p&gt;
&lt;h3 id=&#34;捐款若干次&#34;&gt;捐款若干次&lt;/h3&gt;
&lt;p&gt;一般是在朋友圈、北邮人论坛看到的学弟学妹或者校友身患重病后的求助帖。&lt;/p&gt;
&lt;h3 id=&#34;献血一次&#34;&gt;献血一次&lt;/h3&gt;
&lt;p&gt;200ml。争取以后每年献一次。&lt;/p&gt;
&lt;h2 id=&#34;2016年目标&#34;&gt;2016年目标&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;入职了好好干，多和身边的高手学习，为了从P5升到P6努力。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;看书数量不能少于今年。这个有些困难，因为工作了会忙得多，一旦事情繁琐起来就看不进去书。但目标总是要定得高点才对。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;献血一次。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;多写博客，减少外文翻译，增加读书心得和技术总结的比重。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>百度，一家作恶的公司</title><link>https://blog.yuantops.com/opinions/baidu-is-committing-crime/</link><pubDate>Tue, 12 Jan 2016 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/baidu-is-committing-crime/</guid><description>
&lt;p&gt;百度是一家无节操，无底线的公司。我以前对它仅仅是反感，但最近这股情绪已经变成厌恶。&lt;/p&gt;
&lt;p&gt;世界上没有无缘无故的爱和恨。中国互联网行业三大巨头BAT，虽然都不是什么好鸟，但打头的百度吃相尤其难看。我初中才接触互联网，最先知道的网站就是百度。可惜现在回忆起来，关于它几乎是绵绵不绝的负面印象：&lt;/p&gt;
&lt;h3 id=&#34;封杀google&#34;&gt;“封杀Google”&lt;/h3&gt;
&lt;p&gt;Google是一家伟大的互联网公司。除了有世界第一的搜索引擎，它还有Gmail、Youtube、谷歌学术、谷歌地图、Android等一大票优秀产品。但很遗憾，正常情况下我们都用不了（除了阉割版的Android），因为Google退出了中国市场。&lt;/p&gt;
&lt;p&gt;Google搜索被封杀是在2002年。被封杀的原因，可以参考&lt;a href=&#34;http://www.williamlong.info/archives/377.html&#34;&gt;月光博客&lt;/a&gt;的文章。简而言之，百度技术上干不过Google，于是暗中使绊子散布谣言说Google存在各种“不良信息”，终于上达天听。后来的事我们就不必说了，反正Google滚蛋，百度开始称霸中国互联网搜索市场。&lt;/p&gt;
&lt;p&gt;封杀Google，给普通人、程序员、学生、研究人员造成了很大损失。借用月光博客的一句话说，“因为一个公司的私利、中国5600万网民不能方便的得用互联网查询资料，因为一个公司的阴谋，整个中国互联网的信息利用向后退了一大步。”费尽心思把Google挤出中国，这应该是百度作恶的开始，背负的原罪。&lt;/p&gt;
&lt;h3 id=&#34;竞价排名&#34;&gt;“竞价排名”&lt;/h3&gt;
&lt;p&gt;不得不佩服，用技术作恶，百度玩得非常溜，玩出了新花样。竞价排名，就是其中最令人钦佩、最灵光的一招。&lt;/p&gt;
&lt;p&gt;作为一个搜索引擎，保持搜索结果的中立性是应守的基本道德。好比我们向自己信赖的人提问，期待得到的是尽量客观真实、没有个人偏见的回答。百度不这样。百度的回答是受钱影响的。百度自家的百度百科如此介绍&lt;a href=&#34;http://baike.baidu.com/view/40571.htm&#34;&gt;竞价排名&lt;/a&gt;：&amp;rdquo;竞价排名的基本特点是按点击付费，推广信息出现在搜索结果中（一般是靠前的位置），如果没有被用户点击，则不收取推广费。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;还蛮真诚的。百度返回给用户的搜索结果哗哗哗几十页，只要给钱，企业的信息就能出现在前面，被用户点击。至于这些结果是不是准确，百度根本不在意。它眼里只有钱。&lt;/p&gt;
&lt;p&gt;百度坑过的人，连起手来大概可以绕地球好几圈。被假货骗了的人，顶多损失一点钱。信了假医院被害死的人，它们的生命找谁要？这笔血帐记在谁头上？莆田系民营医院里的冤魂不止一两条(&lt;a href=&#34;http://www.ce.cn/cysc/newmain/pplm/czrw/xw/201407/17/t20140717_3178429.shtml&#34;&gt;俞敏洪炮轰莆田系医院&lt;/a&gt;)，不少人是被百度的推广引过去的。毫无疑问，百度不仅仅是贪钱而已，它还是谋财害命者的帮凶。&lt;/p&gt;
&lt;p&gt;百度也不怕舆论骂它。央视曝光过它(&lt;a href=&#34;http://news.cctv.com/society/20081116/102027.shtml&#34;&gt;2008年新闻&lt;/a&gt;，&lt;a href=&#34;http://business.sohu.com/20110816/n316406329.shtml&#34;&gt;2011年新闻&lt;/a&gt;)，无数其它媒体骂过它，它不见收敛。更滑稽的是，连与它狼狈为奸、靠它流量坑蒙拐骗的莆田系2015年也宣布“&lt;a href=&#34;http://www.caijing.com.cn/150408-1/&#34;&gt;停止互联网上有偿网络推广&lt;/a&gt;”，因为嫌百度胃口太大。百度眼皮都不带动，根本无所谓。&lt;/p&gt;
&lt;p&gt;百度，靠卖假药假器材假医院的流量赚钱，视技术的尊严为无物，俨然社会毒瘤。&lt;/p&gt;
&lt;h3 id=&#34;将血友病帖吧卖给骗子&#34;&gt;“将血友病帖吧卖给骗子”&lt;/h3&gt;
&lt;p&gt;竞价排名好歹是躲在技术后面作恶，被人指责起来，百度还可以装模做样地说&amp;rdquo;搜索引擎或许不应该为网络信息真实性承担责任&amp;rdquo;(&lt;a href=&#34;http://tech.163.com/08/1117/06/4QUB2U6C000915BF.html&#34;&gt;李彦宏语&lt;/a&gt;)。但将病友贴吧出售给骗子医院、野鸡医院，无疑是赤裸裸的吃人血馒头，可由不得狡辩了。最近的血友病贴吧被卖事件，让我彻底看清楚百度的恶心吃相。&lt;/p&gt;
&lt;p&gt;百度作为一个卖广告的互联网公司，贴吧是它唯一拿得出手的产品。我国的人口多，各种疑难杂症患者也多，他们分散在全国各地，饱受折磨而得不到治疗。病友们自发聚集在帖吧，交流病情和治疗心得，很有抱团取暖的意味。血友病吧就是其中一个。平心而论，病友们是很不幸的。可恨的是，还有各色推销假药假疗法的骗子想从他们身上赚钱。更可恨的是，百度贴吧的管理团队用70万把血友病吧卖给了这些骗子，好让他们有地方精准地发广告坑人。事情的来龙去脉，霍炬的文章《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MjM5MTE4Nzk1NA==&amp;amp;mid=401941606&amp;amp;idx=1&amp;amp;sn=72a6309b2a9c500213de6d0ccd288aea&amp;amp;scene=1&amp;amp;srcid=0112KKv6mgQ1G0fKwty3YqPG#wechat_redirect&#34;&gt;霍炬：我是如何坚持10多年站在反百度第一线的&lt;/a&gt;》说得很详细，他的评论我也十分认同。&lt;/p&gt;
&lt;p&gt;百度缺这70万吗？估计它的良心只值这个价。和骗子一起混，把患病的人推向火坑，赚病友的钱，连一点廉耻都不要。这就是百度的价值观，企业盈利手段。想到这样的公司做中国互联网行业的领头羊，心底不由得一股恶寒。&lt;/p&gt;
&lt;p&gt;最后，今天看到一个段子，笑过之后觉得非常失望：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;十五年前，美国和中国，两个搜索引擎公司几乎同时起步，十五年后，一个在研究量子计算机的可行性，另一个在研究如何帮人卖假药。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这就是我们技术最牛的互联网企业，一个对社会基本没有贡献的企业，靠做恶赚钱的企业。技术最顶尖又怎样？我看不起它。愿Google早日回到中国，送这样无底线无节操无道德的企业去垃圾桶。&lt;/p&gt;</description></item><item><title>用Android 手机玩延时摄影</title><link>https://blog.yuantops.com/tech/timelapse-photography-diy-android/</link><pubDate>Fri, 11 Dec 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/timelapse-photography-diy-android/</guid><description>
&lt;p&gt;延时摄影是一种很精妙细微的展现形式，时间被压缩后有流动的美。每隔固定时间按一次快门，再将照片按某个帧率连续起来，就生成一段流畅的视频。摄影发烧友一般用单反拍照，用快门线控制拍照的周期。鉴于单反不是人人都有（譬如我就没有。。），这里分享一个经济实用的点子，用安卓和电脑来DIY延时摄影。&lt;/p&gt;
&lt;h2 id=&#34;思路&#34;&gt;思路&lt;/h2&gt;
&lt;p&gt;Android 系统开放了一些接口，Debug模式下电脑可以通过Android SDK提供的adb 命令调用它们，模拟启动相机、聚焦、拍照动作，并将照片保存到电脑硬盘。将这一连串操作用脚本记录下来，并设置linux定时任务，周期执行。最后，通过ffmpeg 或者其他视频编辑软件将照片变成视频/gif。&lt;/p&gt;
&lt;h2 id=&#34;器材&#34;&gt;器材&lt;/h2&gt;
&lt;p&gt;一部安卓手机 + 一台电脑(假设为Linux) + 一根USB线&lt;/p&gt;
&lt;h2 id=&#34;拍摄主题&#34;&gt;拍摄主题&lt;/h2&gt;
&lt;p&gt;玫瑰花绽放&lt;/p&gt;
&lt;h2 id=&#34;做法&#34;&gt;做法&lt;/h2&gt;
&lt;p&gt;我手头有一部大概一年前买的红米，测试了下拍照效果，虽然比不上正在用的5c但也相当凑和。笔记本刚刚重装了个系统(Arch)，在官网上下好了新鲜热乎的Android SDK。&lt;/p&gt;
&lt;p&gt;用USB线将手机连到笔记本，打开手机的Debug模式。另外，推荐将手机设置为Debug模式下屏幕常亮。用Android SDK的platform-tools目录下的adb命令检查是否顺利连接了手机。我在自己的机器上折腾红米的挂载还颇费了一点力气，具体操作可以google之，此处不赘述。&lt;/p&gt;
&lt;p&gt;用脚本调用adb命令，实现启动相机、聚焦、拍照、保存照片到电脑、删除手机上的照片等一连串操作。将照片从手机上删除是考虑到手机SD的容量有限。Shell脚本实现起来最简单。这里不得不赞叹adb的强大，不仅可以用&amp;rdquo;adb shell&amp;rdquo;像普通linux系统一样操作Android设备，还可以向设备发送按键动作、模拟触屏动作等。如何发送Keyevent，如何捕捉(capture)、记录(record)、发送屏幕触摸动作，可以Google之，此处不赘述。&lt;/p&gt;
&lt;p&gt;将脚本作为系统的定时任务执行。Linux下用crontab可以非常方便地实现。如何设置定时任务的时间间隔，需要做一点小数学题，用拍摄对象的总耗时与视频的帧率算出来，具体参考&lt;a href=&#34;http://content.photojojo.com/tutorials/ultimate-guide-to-time-lapse-photography/&#34;&gt;博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;做完前期的技术准备后，该拍摄主角登场了。我选择的拍摄主题是“鲜花绽放”，所谓一支浓艳露凝香，在我心中玫瑰是坠吼不过的了。在花店用3人民币买了一朵含苞待放的玫瑰花骨朵儿。给它粘个背景，插在一个透明酸奶罐子中，架好灯光（淘宝买的USB LED灯）。固定好手机，缚得牢牢的，不要让它晃动。&lt;/p&gt;
&lt;p&gt;静静地让程序跑，跑，跑。。。。（宿舍晚上会熄灯，这是比较麻烦的，暂时我还没想到解决办法。不过幸亏玫瑰花儿开得快，白天就很饱满了。）&lt;/p&gt;
&lt;p&gt;时间大概过去了五个小时。。。&lt;/p&gt;
&lt;p&gt;好了，花儿开好了。&lt;/p&gt;
&lt;p&gt;打开电脑上存放照片的目录，用ffmpeg或者别的视频编辑软件，将它们合成视频。（我这里为了方便合成的是gif。）&lt;/p&gt;
&lt;h2 id=&#34;github例子&#34;&gt;Github例子&lt;/h2&gt;
&lt;p&gt;我的Shell脚本见&lt;a href=&#34;https://github.com/yuantops/TimelapseAndroid&#34;&gt;这个项目&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;最后是gif效果图，考虑到博客容量我降低了图片尺寸和质量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;out3.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description></item><item><title>C语言堆与栈的区别</title><link>https://blog.yuantops.com/tech/c-heap-vs-stack-memory/</link><pubDate>Thu, 17 Sep 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/c-heap-vs-stack-memory/</guid><description>
&lt;p&gt;C语言中动态区域由Stack和Heap两部分组成。简单说来，Stack由编译器自动分配释放，存放函数的参数值、局部变量等值，底层的数据结构是LIFO的栈。Heap由程序员分配释放，如果一不小心忘记了释放申请的内存，可能引起内存泄漏。Heap基于的数据结构比较复杂。&lt;/p&gt;
&lt;h2 id=&#34;区别&#34;&gt;区别&lt;/h2&gt;
&lt;h3 id=&#34;申请方式&#34;&gt;申请方式&lt;/h3&gt;
&lt;p&gt;Stack由系统自动分配，存放局部变量等。
Heap由程序员调用malloc, realloc, calloc申请，并用free释放。&lt;/p&gt;
&lt;h3 id=&#34;申请效率&#34;&gt;申请效率&lt;/h3&gt;
&lt;p&gt;Stack由系统自动分配，速度快，程序员无法控制。&lt;br /&gt;
Heap由程序员申请、释放，容易产生碎片，效率低于Stack。&lt;/p&gt;
&lt;h3 id=&#34;空间大小&#34;&gt;空间大小&lt;/h3&gt;
&lt;p&gt;Stack在Linux内存区域中由高地值向低地址生长，大小固定，地址是连续的。当栈的剩余控件不足时，会提示Overflow。&lt;br /&gt;
Heap在内存区域中由低地址向高地址生长，是不连续的内存区域。堆的大小受制于系统有效的虚拟内存。&lt;/p&gt;
&lt;h3 id=&#34;分配方式&#34;&gt;分配方式&lt;/h3&gt;
&lt;p&gt;Stack是连续的。只要栈的空间大于所申请的空间，系统将为程序分配空间，否则会报Overflow。&lt;br /&gt;
Heap收到程序申请时，操作系统有一个记录空闲内存地址的链表，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲链表中删除，并将该节点的空间分配给程序。另外，如果找到的堆节点大小不一定正好等于申请的大小，系统会自动将多余的部分重新放入空闲链表中。反复的申请/释放，势必会生成大量的内存空间碎片，使程序效率降低。&lt;/p&gt;
&lt;h3 id=&#34;存储内容&#34;&gt;存储内容&lt;/h3&gt;
&lt;p&gt;Stack：当函数调用时，第一个进栈的是主函数中下一条语句的地址，然后是函数的各个参数，参数是从右往左入栈的，然后是函数中的局部变量。静态变量不入栈。&lt;br /&gt;
当本次函数调用结束后，局部变量先出栈，然后是参数，最后是栈顶指针所指向的、主函数中的下一条指令，程序由该点继续执行。&lt;br /&gt;
Heap：往往会在堆的头部用一个字节存放堆的大小，以利于free函数的释放。&lt;/p&gt;</description></item><item><title>Java堆内存与栈内存的区别</title><link>https://blog.yuantops.com/tech/java-heap-vs-stack-memory/</link><pubDate>Thu, 17 Sep 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/java-heap-vs-stack-memory/</guid><description>
&lt;p&gt;Java中提供&amp;rdquo;栈&amp;rdquo;这种数据结构的实现，java.util.Stack。但此处我们所讨论的不是数据结构，而是JVM内存中的堆与栈，Java Runtime中存放数据的地方。&lt;/p&gt;
&lt;h3 id=&#34;jvm中的堆&#34;&gt;JVM中的堆&lt;/h3&gt;
&lt;p&gt;Java Runtime使用Heap为Object分配内存。所有的对象，无论是何时何地创建的，都保存在Heap中。垃圾回收(Garbage Collection)在Heap上运行，释放不被引用的Object。Heap中生存的Object能在程序的任何地方被引用。&lt;/p&gt;
&lt;h3 id=&#34;jvm中的栈&#34;&gt;JVM中的栈&lt;/h3&gt;
&lt;p&gt;Stack memory是为执行的thread分配的，包含一些生存时间短的值和指向Heap中对象的引用。Stack Memory总是LIFO的。当调用一个Method时，Stack Memory会为它分配一块区域，用来存储本地的primitive value和对Object的引用。一旦这个method结束，这块区域将变得不可用，下一次Method调用时又可以使用它。&lt;/p&gt;
&lt;p&gt;相比Heap，Stack要小得多。&lt;/p&gt;
&lt;h3 id=&#34;区别&#34;&gt;区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;存储内容：栈存放局部变量以及引用，堆存放&lt;strong&gt;所有&lt;/strong&gt;对象。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;被谁占有：堆被整个程序共享，栈中的对象被所有线程可见；栈属于单个线程，存储的变量只在其所属的线程中可见。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;空间管理：Stack内存满足LIFO，但Heap就复杂多了。Heap被分为Young Generation, Old Generation, Permanent Generation，在它基础上会运行垃圾回收机制。&lt;/li&gt;
&lt;li&gt;生存时间：Stack Memory伴随调用它的Method存在、消失，而Heap Memory从程序的开始一直存活到终止。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;体积大小：Stack Memory体积远大于Heap Memory。由于Stack用LIFO调度，它的访问速度也快得多。可以用-Xms或者-Xmx定义Heap的初始大小，用-Xss定义Stack的初始大小。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;异常错误：当Stack满了，Java Runtime会抛出java.lang.StackOverFlowError。当Heap满了，会抛出java.lang.OutOfMemoryError: Java Heap Space Error。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>LaTeX安装以及生成pdf时字体找不到的处理办法</title><link>https://blog.yuantops.com/tech/latex-installation-and-basics/</link><pubDate>Tue, 08 Sep 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/latex-installation-and-basics/</guid><description>
&lt;h2 id=&#34;安装软件包&#34;&gt;安装软件包&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;$ sudo apt-get install texlive texlive-science&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;编译命令&#34;&gt;编译命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;tex编译: &lt;code&gt;$ latex hello.tex&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;输出为pdf: &lt;code&gt;$ dvipdf hello.dvi&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;输出为ps: &lt;code&gt;$ dvips hello.dvi&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如果生成pdf时报-font-helvetica-is-not-in-the-mapping-file-类似错误&#34;&gt;如果生成pdf时报&amp;rdquo;Font Helvetica is not in the mapping file&amp;rdquo; 类似错误&lt;/h2&gt;
&lt;p&gt;出现这种情况，原因可能有几种，最可能的是系统没有安装这个字体。具体解释见&lt;a href=&#34;http://www.wkiri.com/today/?p=60&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;处理办法：安装ghostscript命令，用它自带的命令，先将pdf转成ps，再以强制嵌入字体的方式将ps回转为pdf。详细的步骤见&lt;a href=&#34;http://www.grassbook.org/wp-content/uploads/neteler/highres_pdf.html&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;具体命令:&lt;br /&gt;
1. covert to postscript:&lt;br /&gt;
&lt;code&gt;$ pdftops origin.pdf origin.ps&lt;/code&gt;&lt;br /&gt;
2. reconvert to pdf, but enforce font embedding:&lt;br /&gt;
&lt;code&gt;$ ps2pdf14 -dPDFSETTINGS=/prepress -dEmbedAllFonts=true origin.ps new.pdf&lt;/code&gt;&lt;br /&gt;
3. verify format of new file:&lt;br /&gt;
&lt;code&gt;$ pdffonts new.pdf&lt;/code&gt;&lt;/p&gt;</description></item><item><title>一张彩票，一个人的美国梦</title><link>https://blog.yuantops.com/opinions/a-lottery-for-american-dream/</link><pubDate>Fri, 31 Jul 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/a-lottery-for-american-dream/</guid><description>&lt;p&gt;这是This American Life&lt;a href=&#34;http://www.thisamericanlife.org/radio-archives/episode/560/abdi-and-the-golden-ticket&#34;&gt;最近一期&lt;/a&gt;里讲述的故事，关于一个人因为一张彩票，到最终拿到美国绿卡的曲折故事。我听完后印象很深，因为故事里描述的另外一个国度的混乱、人们的追求与我所处的环境迥然不同，更因为这个故事加深了我对“美国梦”这个词的理解。&lt;/p&gt;
&lt;p&gt;故事要从一张彩票说起。&lt;/p&gt;
&lt;p&gt;美国政府每年都会在世界范围内发行一种特殊彩票：它网络申购，网络开奖，而且最特殊的在于它的奖品不是钱，而是移民美国的签证。中奖名单是随机生成的，被抽中的幸运儿只需再通过简单的背景审查即可获得签证&lt;a href=&#34;注释1&#34; title=&#34;The diversity immigrant visa program, also known as Green Card Lottery. 这个彩票项目每年发出至多55000份绿卡，提供给移民美国比率较低的地区的居民申请（中国，很明显的，不在其中）。
&#34;&gt;注释1&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Abdi是故事的主人翁。他是Somali难民，逃难居住在Kenya的一个城市。城市里骚乱不断，各种武装势力争斗层出不穷。他从小仰慕美国文化，听美国流行音乐，去影碟店租美国好莱坞电影，学英语。总之，他一个是生活在战乱中的，极度向往美国的少年。他和他的朋友在网吧的电脑上年复一年申请绿卡彩票，直到最近一次开奖。他打开电脑，输入自己的信息，点击提交，然后，发现中奖了。&lt;/p&gt;
&lt;p&gt;他的生活由此改变。一扇通往新世界的门，发着光的梦幻新世界的门，向他敞开了。他是多么幸运啊，多么让人羡慕。他成名了，身边的人都来恭喜他。当然，除了恭喜的声音，还有一些有趣的反响。Abdi说，有很多女性过来找他说话，赞美他，然后“不经意”地提到，他还需要一个妻子，一个陪伴他的人。&lt;/p&gt;
&lt;p&gt;拿到入场券还不够，还需要提交一些证明文件到美使馆。Abdi所在的城市骚乱又来，他作为外来难民出门很危险。他还是鼓起勇气，搭乘公交跑了几次警察局，请求一份无犯罪记录证明。警察局根本不鸟他，回复说按流程会在多少多少天后办完。可等到那时候期限早错过了。Abdi又努力了很久，其间辛苦一言难尽，终于在Deadline前一天凑齐了资料。那一夜，他兴奋整晚，无法入睡。&lt;/p&gt;
&lt;p&gt;可是，面试官发现他的一份资料签名有问题，拒绝通过申请。Abdi心情跌入谷底。面试官例行公事式地告诉他，他可以重新提交资料，然后再等待面试。&lt;/p&gt;
&lt;p&gt;故事如果到这里结束，就是一个悲剧故事：一个梦想移民美国的第三世界人民，得到了入场券，努力做了，到头来一无所获。这个故事不同，它迎来了喜剧结局：Deadline之后的某一天，Abdi打开电子邮箱，发现里面静静躺着一封来自美使馆的邮件，通知他重新提交的资料审核通过，他的Visa被核准了。&lt;/p&gt;
&lt;p&gt;几经周折，主人公终于达成夙愿，成了美国人。在节目的最后，Abdi已经身处美利坚的土地上，开始了新生活，幸福感简直要漫出来。恭喜他。&lt;/p&gt;
&lt;p&gt;这个节目增长见识之余，也让我产生之前从有过的几个感想。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;“天地不仁，以万物为刍狗”。生在战乱的地方，人生注定会更加艰难。中文互联网上有人调侃投胎是一门技术活，此言不虚，而且投在天朝和投在索马里这些地方相比，那是积德太多了。当然，对Abdi来说，投在美国是最得偿所愿。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;美国毕竟是世界上一等一的国家。号称的“民主灯塔”，也不是盖，你看世界上多少人削尖了脑袋想拿一张绿卡，就明白了。现在华人移民美国，大多是看中美国更好的生活品质，属于“饱暖思淫欲”型，去不了在国内也凑活。第三世界的兄弟们，去美国就是脱离苦海得出升天型。美国对这两类人都像磁石，所以很了不起。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;即使投胎占了下风，也不要放弃梦想。恶劣到像Abdi那样出生在如此糟糕的地方，他照样学英语，追求不停。中彩票固然是机遇，即使不中彩票，他的人生也决计与他身边游手好闲打砸抢烧的青年失业混混截然不同。环境影响一个人，在一坨屎一样的环境里奋斗，更需要坚毅。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Android SurfaceView双缓存机制与闪屏现象分析</title><link>https://blog.yuantops.com/tech/surfaceview-dual-cache/</link><pubDate>Sun, 26 Jul 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/surfaceview-dual-cache/</guid><description>&lt;p&gt;##理解SurfaceView&lt;br /&gt;
SurfaceView是View的子类，所以View有的特点它都有。但它有特殊之处：它引入了缓存机制，优化了内容刷新的过程，使UI Thread不至于崩溃。更新它的内容，我们要用到与之关联的SurfaceHolder。&lt;/p&gt;
&lt;p&gt;比较特殊的在于SurfaceView的“双缓存”(Double-buffer)机制。更新SurfaceView的常见流程是&amp;rdquo;lockCanvas-drawCanvas-unlockCanvasAndPost&amp;rdquo;, 如果你遇到SurfaceView闪烁的情况，像鬼片里电视机的那种闪法，那十之八九是栽倒在双缓存的坑里了。Google告诉了我这个问题的答案，希望你能用上。&lt;/p&gt;
&lt;p&gt;##双缓存(Double-buffer)与黑屏闪烁&lt;br /&gt;
以下内容来自&lt;a href=&#34;http://markmail.org/message/mxserqvi37hnajp5&#34;&gt;邮件列表的讨论&lt;/a&gt;，我对它们进行一点梳理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;每个SurfaceView 对象有两个独立的graphic buffer，官方SDK将它们称作&amp;rdquo;front buffer&amp;rdquo;和&amp;rdquo;back buffer&amp;rdquo;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常规的&amp;rdquo;double-buffer&amp;rdquo;会这么做：每一帧的数据都被绘制到back buffer，然后back buffer的内容被持续翻转(flip)到front buffer；屏幕一直显示front buffer。但Android SurfaceView的&amp;rdquo;double-buffer&amp;rdquo;却是这么做的：在buffer A里绘制内容，然后让屏幕显示buffer A; 下一个循环，在buffer B里绘制内容，然后让屏幕显示buffer B; 如此往复。于是，屏幕上显示的内容依次来自buffer A, B, A, B,&amp;hellip;.这样看来，两个buffer其实没有主从的分别，与其称之为&amp;rdquo;front buffer&amp;rdquo;&amp;ldquo;back buffer&amp;rdquo;，毋宁称之为&amp;rdquo;buffer A&amp;rdquo;&amp;ldquo;buffer B&amp;rdquo;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Android中&amp;rdquo;double-buffer&amp;rdquo;的实现机制，可以很好地解释闪屏现象。在第一个&amp;rdquo;lockCanvas-drawCanvas-unlockCanvasAndPost&amp;rdquo;循环中，更新的是buffer A的内容；到下一个&amp;rdquo;lockCanvas-drawCanvas-unlockCanvasAndPost&amp;rdquo;循环中，更新的是buffer B的内容。如果buffer A与buffer B中某个buffer内容为空，当屏幕轮流显示它们时，就会出现画面黑屏闪烁现象。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##解决方法
出现黑屏是因为buffer A与buffer B中一者内容为空，而且为空的一方还被post到了屏幕。于是有两种解决思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不让空buffer出现：每次向一个buffer写完内容并post之后，顺便用这个buffer的内容填充另一个buffer。这样能保证两个buffer的内容是同步的，缺点是做了无用功，耗费性能。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不post空buffer到屏幕：当准备更新内容时，先判断内容是否为空，只有非空时才启动&amp;rdquo;lockCanvas-drawCanvas-unlockCanvasAndPost&amp;rdquo;这个流程。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>用Helix Server建立点播流/直播流的方法</title><link>https://blog.yuantops.com/tech/helix-server-streaming-guide/</link><pubDate>Thu, 23 Jul 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/helix-server-streaming-guide/</guid><description>
&lt;h2 id=&#34;视频文件预处理&#34;&gt;视频文件预处理&lt;/h2&gt;
&lt;p&gt;Helix Server支持的视频格式很多，我只使用过MP4格式，其余的格式请自行探索。&lt;/p&gt;
&lt;p&gt;一个MP4格式的视频文件要想被Helix流化，必须具有符合要求的头部信息。mp4box这个小命令正是用来做这件事的，它是开源软件GPAC内提供的命令。先安装GPAC(&lt;a href=&#34;https://gpac.wp.mines-telecom.fr/mp4box/)，&#34;&gt;https://gpac.wp.mines-telecom.fr/mp4box/)，&lt;/a&gt; 后在安装目录下找到MP4BOX.exe。如何调用命令不赘言。它的使用格式是：&lt;br /&gt;
&lt;code&gt;mp4box mymovie.mp4 -hint&lt;/code&gt;&lt;br /&gt;
在安装Helix Server前，将所有的视频文件都用这条命令处理一遍。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;Helix Server是收费的，但在官网能申请到一个试用版license，免费使用一段时间。当然，如果你在网上找到了破解版，请在使用时自觉忏悔。&lt;/p&gt;
&lt;p&gt;安装过程不多说，只是要注意记忆所设的帐号和密码。安装完成后，在桌面会生成两个图标：一个指向web控制台，还有一个是启动Helix的快捷方式。我们双击web控制台的图标，输入帐号和密码，进入Web Console。&lt;/p&gt;
&lt;h2 id=&#34;参数配置&#34;&gt;参数配置&lt;/h2&gt;
&lt;p&gt;进入Web Console后，左侧是一栏设置菜单，右侧是对应菜单条目的详情。在Web Console上我们能完成&lt;strong&gt;点播流&lt;/strong&gt;的所有配置,以及直播流的必要配置。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;添加服务器的IP地址&lt;br /&gt;
左侧：&amp;rdquo;服务器设置&amp;rdquo;-&amp;ldquo;IP绑定&amp;rdquo;&lt;br /&gt;
右侧：点击小加号，输入服务器的IP地址。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置流服务的端口号&lt;br /&gt;
Helix 的点播支持Http协议、RTSP协议，直播支持RTSP协议。Helix为这些协议分配了默认的端口号，如果有需要的话我们可以修改它们。&lt;br /&gt;
左侧：&amp;rdquo;服务器设置&amp;rdquo;-&amp;ldquo;端口&amp;rdquo;&lt;br /&gt;
右侧：修改&amp;rdquo;RTSP端口&amp;rdquo;，&amp;rdquo;HTTP端口&amp;rdquo;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加视频加载点&lt;br /&gt;
左侧：&amp;rdquo;服务器设置&amp;rdquo;-&amp;ldquo;配置加载点&amp;rdquo;&lt;br /&gt;
右侧：点击&amp;rdquo;加载点描述&amp;rdquo;右边的小加号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;编辑描述&amp;rdquo;随便给这个配置取一个描述性的名字；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;加载点&amp;rdquo;设置视频目录的加载点（它将作为视频流URL的一部分出现），输入内容形如&amp;rdquo;/NGB/&amp;ldquo;（注意有两个左斜杠）；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;基于路径&amp;rdquo;输入视频文件所在目录的绝对路径，形如&amp;rdquo;E:\Videos&amp;rdquo;。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将加载点添加到HTTP 分发目录&lt;br /&gt;
左侧：&amp;rdquo;服务器设置&amp;rdquo;-&amp;ldquo;HTTP分发&amp;rdquo;&lt;br /&gt;
右侧：点击&amp;rdquo;路径&amp;rdquo;右边的小加号，在&amp;rdquo;编辑路径&amp;rdquo;中填入上面设置的视频加载点，形如&amp;rdquo;/NGB&amp;rdquo;(注意此处只有一个左斜杠)。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将MP4格式加到HTTP协议支持的MIME类型列表&lt;br /&gt;
左侧：&amp;rdquo;服务器设置&amp;rdquo;-&amp;ldquo;MIME类型&amp;rdquo;&lt;br /&gt;
右侧：点击&amp;rdquo;MIME类型&amp;rdquo;右边的小加号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;编辑MIME类型&amp;rdquo;填入&amp;rdquo;video/mp4&amp;rdquo;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;扩展名&amp;rdquo;填入&amp;rdquo;mp4&amp;rdquo;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试配置是否成功&lt;br /&gt;
假设视频文件目录有文件&amp;rdquo;E:\Videos\akame.mp4&amp;rdquo;,视频目录挂载点为&amp;rdquo;/NGB/&amp;ldquo;,配置的Http协议端口为80，Rtsp协议端口为554。在PC上打开一个能播放网络媒体流的视频播放器（推荐VLC），输入下面的URL播放视频：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://192.168.1.100:80/NGB/akame.mp4&#34;&gt;http://192.168.1.100:80/NGB/akame.mp4&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;rtsp://192.168.1.100:554/NGB/akame.mp4&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;点播流的创建到此结束了。完成上述步骤后，下面再来介绍如何用Helix 提供的小命令，由视频文件生成模拟直播流。&lt;/p&gt;
&lt;h3 id=&#34;生成模拟直播流&#34;&gt;生成模拟直播流&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;准备命令&lt;br /&gt;
在Helix Server的安装路径下找到/bin目录，将slta.bat和slta.exe文件拷贝到视频目录（此处为&amp;rdquo;E:\Videos\&amp;ldquo;）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置Helix为Receiver模式&lt;br /&gt;
打开Web Console。左侧：“广播分发”-“接受服务器”，在右侧“加载点”框内输入直播流的挂载点，例如&amp;rdquo;/broadcast/&amp;ldquo;（注意有两个左斜杠）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行模拟直播流命令&lt;br /&gt;
模拟直播流播放哪几个视频，按什么顺序播放它们，是可以自己定义的。例如，如果想循环播放akame.mp4和anotheVideo.mp4这两个视频，我们可以创建一个节目单文本文件：playlist.txt，将“akame.mp4”和“anotheVideo.mp4”做两行写到文件。&lt;br /&gt;
运行命令&lt;code&gt;slta.bat 192.168.1.100 178771 admin admin tv1 playlist.txt&lt;/code&gt;创建直播流，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是slta.bat，而不是slta&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;IP地址是这台机器的IP地址&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;178771是Web Console的端口号。用浏览器打开Web Console，可以在URL中找到&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;admin/admin分别是账号和密码&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;tv1是为直播流分配的任意频道号，可自定义&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;playlist.txt是节目单文件。如果只播放单个视频，也可以换成视频文件名，如&amp;rdquo;akame.mp4&amp;rdquo;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;播放验证直播流&lt;br /&gt;
打开视频播放器，输入形如&amp;rdquo;rtsp://192.168.1.100:554/broadcast/tv1&amp;rdquo;的网址，播放视频。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述步骤创建一个直播流。新开一个cmd窗口，重复上述步骤，可以创建多路直播流。&lt;/p&gt;</description></item><item><title>Ali面试记录</title><link>https://blog.yuantops.com/tech/interview-ali-record-1/</link><pubDate>Thu, 19 Mar 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/interview-ali-record-1/</guid><description>&lt;p&gt;记录：
1. 以支付宝的输入密码界面为例。当支付宝再次回到前台时，有时会进入输手势密码的界面。请问你的实现思路？&lt;br /&gt;
面试官的解答：编写一个BaseActivity继承Activity，然后App中所有的Activity都继承BaseActivity。在BaseActivity中设置计时器，重写BaseActivity的onStop()和onStart()方法&amp;hellip;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;百度、腾讯等旗下有多款App，这些App有的在后台共享SDK数据。请问其中原理？&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IPC调用。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Android中APP是单例还是多例？&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;判断一个Activity是不是位于栈顶。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java中run()和start()区别&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java中lock()和Syncronized()区别&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在按下Back键时，如何自定义返回到哪个Activity？&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Git重新应用gitignore文件规则</title><link>https://blog.yuantops.com/tech/refresh-gitigore/</link><pubDate>Tue, 17 Mar 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/refresh-gitigore/</guid><description>&lt;p&gt;这个问题参见&lt;a href=&#34;https://stackoverflow.com/questions/11451535/gitignore-not-working&#34;&gt;StackOverflow&lt;/a&gt;，记录在下面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保险起见，先对当前Repo提交一个commit，以防丢失数据；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;然后，&lt;br /&gt;
git rm -r &amp;ndash;cached .&lt;br /&gt;
git add .&lt;br /&gt;
git commit -m &amp;ldquo;fixed untracked files&amp;rdquo;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>REST基础概念笔记</title><link>https://blog.yuantops.com/tech/rest-basics/</link><pubDate>Thu, 29 Jan 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/rest-basics/</guid><description>
&lt;p&gt;&lt;strong&gt;Representational State Transfer(REST)&lt;/strong&gt;&lt;br /&gt;
REST is an architecture style or design pattern used as a set of guidelines for creating web services which allow anything connected to a network (web servers, private intranets, smartphones, fitness bands, banking systems, traffic cameras, televisions etc.) to communicate with one another via a shared common communications protocol known as Hypertext Transfer Protocol (HTTP). &amp;ndash;&lt;a href=&#34;http://en.wikipedia.org/wiki/Representational_state_transfer&#34;&gt;REST Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;REST是一种&lt;strong&gt;架构风格&lt;/strong&gt;，&lt;strong&gt;设计模式&lt;/strong&gt;，因此没有一本语法书规定REST应该这样实现，应该那样实现。它不是一种标准。它是一种风格，具有指导意义，凡是遵循这种风格的设计，都可以称之为&amp;rdquo;RESTful&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;REST的常见应用场景是Web服务。在RESTful API的实际实现中，往往遵循一些*约定的*规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于URI，例如&lt;a href=&#34;http://example.com/resources/&#34;&gt;http://example.com/resources/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;传输的数据格式是JSON。虽然理论上数据格式可以是任意一种(XML,ATOM等)，但往往大家都用JSON。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用标准HTTP方法，即GET, PUT, POST, DELETE四个动词。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://rest.elkstein.org/2008/02/how-simple-is-rest.html&#34;&gt;How Simple is REST&lt;/a&gt;这篇文章里举了这样一个例子：&lt;/p&gt;
&lt;p&gt;假设这样一个Web服务，它是一个电话本应用，我们要向它查询某个用户的信息。我们只有用户的ID。&lt;/p&gt;
&lt;p&gt;REST风格下，查询看起来这样:&lt;br /&gt;
&amp;gt;&lt;a href=&#34;http://www.acme.com/phonebook/UserDetails/12345&#34;&gt;http://www.acme.com/phonebook/UserDetails/12345&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不需要在请求中设置额外的body，一条URL就搞定。这条URL以GET方式发送给服务器，返回原始的HTTP数据。返回的数据不嵌套在任何东西里，我们可以直接使用。&lt;/p&gt;
&lt;p&gt;所以，使用REST风格对开发有好处：我们可以用浏览器测试API，哪怕客户端的部分还没完成。&lt;/p&gt;
&lt;p&gt;另外，注意这条URL使用了&amp;rdquo;UserDetails&amp;rdquo;，而不是&amp;rdquo;GetUserDetails&amp;rdquo;。这是REST设计风格的一个例子：使用*名词*而不是*动词*来表示简单的*资源*。&lt;/p&gt;
&lt;h3 id=&#34;资源的概念&#34;&gt;资源的概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;资源(Resources)&lt;/strong&gt;是REST架构中一个非常重要的概念。&lt;strong&gt;逻辑&lt;/strong&gt;URL标识着资源。资源同时表示&lt;strong&gt;状态(state)&lt;/strong&gt;和&lt;strong&gt;功能(functionality)&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑URL，意味着这个资源能被系统中的其它部分定位(universally addressable)。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;资源是一个RESTful 设计中的核心元素。它不同于&amp;rdquo;methods&amp;rdquo;或是&amp;rdquo;services&amp;rdquo;。&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>视频格式学习笔记</title><link>https://blog.yuantops.com/tech/video-format-and-container-study/</link><pubDate>Wed, 28 Jan 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/video-format-and-container-study/</guid><description>
&lt;p&gt;在生活语境里所说的“视频格式”，在学术上有两个概念与之对应：Container format (封装格式)和Codec (暂且译为“编解码格式”)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Container format (封装格式)
Container format 描述了视频文件的结构。正如它的字面含义所说，它是对一个“容器”的规范。一个视频文件往往会包含图像和音频，还有一些配置信息(如图像和音频的关联，如何解码它们等)：这些内容需要按照一定的规则组织、存储起来，Container format就是这些规则。&lt;/p&gt;
&lt;p&gt;如果一个视频文件是以某个Container format封装起来的，那么它的后缀名一般会体现出来。所以，后缀名只是形式，只是为了便于识别(例如，windows系统会根据文件的后缀名决定以什么程序打开它)，不代表实质性的内容。&lt;/p&gt;
&lt;p&gt;附录(一)是常见的视频封装格式和后缀的对应表。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Codec (编解码格式)&lt;br /&gt;
Codec是一种压缩标准。而文件的压缩/还原是通过编/解码实现的，所以Codec也可理解成编/解码标准。要知道，未经过处理的原始视频和音频文件十分巨大，不好存储、传输。为了节省磁盘空间和网络带宽，原始的视频和音频文件都会通过编码压缩体积，然后需要播放时再通过逆向过程解码还原。Codec就是规定编/解码实现细节(数字存储空间、帧速率、比特率、分辨率等)的标准，不同的标准对于压缩的质量和效率有影响。&lt;/p&gt;
&lt;p&gt;世界上制定这套标准的有两大阵营：ITU-T VCEG(Visual Coding Experts Group，国际电联旗下的标准化组织)和MPEG(Moving Picture Experts Group, ISO旗下的组织)。MPEG系列标准是MPEG制定的，H.26x系列标准是ITU-T制定的。这两套标准的更进一步介绍可以参见附录(二)。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Container format 和Codec 有关系吗？&lt;br /&gt;
不妨将视频文件看作容器(Container)，那么这个容器里盛放的就是遵循某种Codec的内容(Content)。一个容器里应该能放下视频、音频、数据信息，即使它们遵循的Codec不相同。例如，QuickTime File Format (.MOV)支持几乎所有的Codec，MPEG(.MP4)也支持相当广的Codec。所以，单从视频文件的格式是无法获知它的质量细节的，这些细节取决与采用的Codec。比较专业的说法是，“给我一个H.264 Quicktime文件(.mov)”。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为何还是有点迷糊？&lt;br /&gt;
以上的解释是从学术角度出发的。只要分清了这些术语，那么在学术讨论时不会有含糊。但现实生活中人们不会一丝不苟地区分“Container format ”“Codec”，往往只会说“这是一个mov文件”。这是日常用语与学术术语混用造成的理解上的混乱。&lt;/p&gt;
&lt;p&gt;另外，Container format和Codec的命名也有让清醒的人摸不清头脑。例如，“MPEG-4”既是“Container format ”，也是“Codec”，这也让混乱的名词世界更糟糕。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://library.rice.edu/services/dmc/guides/video/VideoFormatsGuide.pdf&#34;&gt;https://library.rice.edu/services/dmc/guides/video/VideoFormatsGuide.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://app.zencoder.com/docs/faq/codecs-and-formats&#34;&gt;https://app.zencoder.com/docs/faq/codecs-and-formats&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;附录一-常见的视频封装格式和后缀的对应表&#34;&gt;附录一 常见的视频封装格式和后缀的对应表&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://app.yinxiang.com/shard/s11/res/a7088df6-98db-4089-8bb6-93a2beb1c76e/7295b9399a1a37290870fa8f35f4762e_b.jpg.png?resizeSmall&amp;amp;width=313&#34; alt=&#34;常见的视频封装格式和后缀的对应表&#34; /&gt;&lt;/p&gt;</description></item><item><title>Linux确定监听某个端口的进程</title><link>https://blog.yuantops.com/tech/find-out-process-listening-on-a-port/</link><pubDate>Thu, 22 Jan 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/find-out-process-listening-on-a-port/</guid><description>
&lt;p&gt;比较常见的命令有:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;netstat&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lsof&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ps&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/proc/$pid&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;netstat&#34;&gt;netstat&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;# netstat -tuapn&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数解释:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; -t tcp协议
-u udp协议
-a 显示listening和non-listening端口
-p 显示process ID
-n 显示数字IP，而不是字符形式的hostname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以用grep命令对上条命令的输出进行过滤，显示某条端口的信息。&lt;/p&gt;
&lt;h3 id=&#34;lsof&#34;&gt;lsof&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;# lsof -i :4000&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;lsof列出机器上打开的所有文件。这条命令输出端口4000被占用的情况。它的输出形如&lt;br /&gt;
COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME&lt;br /&gt;
ruby-mri 10482 yyuan 11u IPv4 252906 0t0 TCP localhost:terabase (LISTEN)&lt;/p&gt;
&lt;p&gt;可以看到进程号10482的进程占用了TCP端口4000。&lt;/p&gt;
&lt;h3 id=&#34;ps&#34;&gt;ps&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;# ps aux&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数解释:
-a 显示所有用户的进程&lt;br /&gt;
-u 显示进程的user/owner&lt;br /&gt;
-x 也显示不与终端关联的进程&lt;/p&gt;
&lt;p&gt;同样地，也可以用grep命令对上条命令的输出进行过滤，显示某条端口的信息。&lt;/p&gt;
&lt;h3 id=&#34;proc-pid&#34;&gt;/proc/$pid&lt;/h3&gt;
&lt;p&gt;下面是该目录下，各个文件的作用:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;..............................................................
File Content
clear_refs Clears page referenced bits shown in smaps output
cmdline Command line arguments
cpu Current and last cpu in which it was executed &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;.4&lt;span style=&#34;color:#f92672&#34;&gt;)(&lt;/span&gt;smp&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
cwd Link to the current working directory
environ Values of environment variables
exe Link to the executable of this process
fd Directory, which contains all file descriptors
maps Memory maps to executables and library files &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;.4&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
mem Memory held by this process
root Link to the root directory of this process
stat Process status
statm Process memory status information
status Process status in human readable form
wchan If CONFIG_KALLSYMS is set, a pre-decoded wchan
pagemap Page table
stack Report full stack trace, enable via CONFIG_STACKTRACE
smaps a extension based on maps, showing the memory consumption of
each mapping and flags associated with it
...............................................................&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;具体应用&#34;&gt;具体应用&lt;/h2&gt;
&lt;h3 id=&#34;找到进程3813的owener&#34;&gt;找到进程3813的owener&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;# ps aux | grep &lt;span style=&#34;color:#ae81ff&#34;&gt;3813&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者 cat /proc/3813/environ , 查看USER字段。&lt;/p&gt;
&lt;h3 id=&#34;看到一个根本不认识的端口号&#34;&gt;看到一个根本不认识的端口号&lt;/h3&gt;
&lt;p&gt;/etc/services文件用来将协议/端口号映射到服务的名字。可以用grep命令来匹配某个不认识的端口。&lt;/p&gt;</description></item><item><title>Eclipse中添加Tomcat插件</title><link>https://blog.yuantops.com/tech/install-tomcat-plugin-in-eclipse/</link><pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/install-tomcat-plugin-in-eclipse/</guid><description>&lt;p&gt;##安装Tomcat
&lt;strong&gt;下载链接&lt;/strong&gt;:&lt;a href=&#34;http://tomcat.apache.org/download-70.cgi&#34;&gt;Tomcat7&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载tar.gz包到本地，譬如到/home/yuan/Downloads目录&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;tar -zxf **.**.tar.gz&lt;/code&gt;命令解压tar.gz包，将解压出来的文件夹转移到你希望保存的目的地(譬如说/home/yuan/tomcat7)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用vi打开~/.bashrc文件，在末尾添加如下内容:&lt;br /&gt;
alias tomcat=&amp;lsquo;bash ~/tomcat7/bin/startup.sh&amp;rsquo;&lt;br /&gt;
export CATALINA_HOME=/home/tomcat7&lt;br /&gt;
export JRE_HOME=/usr/lib/jvm/java-7-openjdk-i386/jre&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，JRE_HOME是本机的JRE环境所在目录，需要根据系统的安装情况而定。&lt;br /&gt;
保存退出&lt;/p&gt;
&lt;p&gt;现在，重新打开终端，运行&lt;code&gt;tomcat&lt;/code&gt;可以启动Tomcat服务&lt;/p&gt;
&lt;p&gt;##在Eclipse中添加Tomcat插件
&lt;strong&gt;下载链接&lt;/strong&gt;: &lt;a href=&#34;http://www.eclipsetotale.com/tomcatPlugin/tomcatPluginV33.zip&#34;&gt;TomcatPluginV33.zip&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载压缩包，将解压后的目录复制到Eclipse安装目录下的plugins/目录。启动Eclipse，可以在状态栏中看到三个有小猫的图标。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;菜单栏，&amp;rdquo;Window&amp;rdquo;-&amp;ldquo;Preferences&amp;rdquo;-&amp;ldquo;Tomcat&amp;rdquo;,将Tomcat version和Tomcat home改为对应值。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;单击小猫图标，即可启动Tomcat。在浏览器中输入&lt;code&gt;http://127.0.0.1:8080&lt;/code&gt;能看到欢迎页。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##在Eclipse中新建一个Tomcat项目
- &amp;ldquo;File&amp;rdquo;-&amp;ldquo;New&amp;rdquo;-&amp;ldquo;Project&amp;hellip;&amp;rdquo;-&amp;ldquo;Java&amp;rdquo;-&amp;ldquo;Tomcat Project&amp;rdquo;,新建一个Tomcat工程。&lt;br /&gt;
- 添加源码在&amp;rdquo;WEB-INF/src&amp;rdquo;目录下。&lt;br /&gt;
- 不要忘记在&amp;rdquo;WEB-INF&amp;rdquo;目录下添加web.xml文件。&lt;/p&gt;</description></item><item><title>IPv4协议保留的私有IP段</title><link>https://blog.yuantops.com/tech/ipv4-private-address-space/</link><pubDate>Tue, 20 Jan 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/ipv4-private-address-space/</guid><description>&lt;p&gt;这三个保留IP地址段是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;10.0.0.0/8 IP addresses: 10.0.0.0 &amp;ndash; 10.255.255.255&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;172.16.0.0/12 IP addresses: 172.16.0.0 &amp;ndash; 172.31.255.255&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;192.168.0.0/16 IP addresses: 192.168.0.0 – 192.168.255.255&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，所有以&amp;rdquo;172&amp;rdquo;和&amp;rdquo;192&amp;rdquo;打头的IP中只有部分是保留IP。&lt;/p&gt;</description></item><item><title>北邮校园网通过配置IPv6使用Google服务</title><link>https://blog.yuantops.com/tech/config-ipv6-to-bypass-gfw-in-bupt/</link><pubDate>Sat, 17 Jan 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/config-ipv6-to-bypass-gfw-in-bupt/</guid><description>
&lt;h2 id=&#34;前提&#34;&gt;前提&lt;/h2&gt;
&lt;p&gt;首先，本文针对的是北邮校园网。我在北邮学十亲测，机器是Linux Mint。&lt;/p&gt;
&lt;p&gt;其次，请确保:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自己的机器支持IPv6。Win7默认安装了IPv6协议，WinXP可能需要自己手动安装。我自己的Linux mint默认安装了IPv6。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;自己的网络支持IPv6。包括北邮在内的绝大多数高校校园网都架设了IPv6，通过校园网上网的同学理论上不必担心这点。所以，还在使用校园网的同学们，趁IPv6还没被盯上，珍惜现在吧。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;验证方法&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;打开浏览器，访问&lt;a href=&#34;http://ipv6-test.com/&#34;&gt;IPv6test.com&lt;/a&gt;，页面上&amp;rdquo;IPv6 connectivity&amp;rdquo;一项如果显示&amp;rdquo;Supported&amp;rdquo;，说明前提条件满足。或者访问&lt;a href=&#34;http://bt.byr.cn&#34;&gt;BYR BT&lt;/a&gt;，这是只支持IPv6方式访问的站点，如果能访问也说明前提条件满足。&lt;/p&gt;
&lt;h2 id=&#34;目标&#34;&gt;目标&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用谷歌的服务(google search, gmail, google calendar, google scholar, google plus, youtube, etc.)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;访问其它支持IPv6的网站: wikipedia, facebook, etc.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了能部分避开G)(F)(W之外，北邮校园网内通过IPv6通道产生的流量是不计费的，所以，即使从节约流量这一点看也是值得的。&lt;/p&gt;
&lt;h2 id=&#34;姿势简介&#34;&gt;姿势简介&lt;/h2&gt;
&lt;p&gt;总的来说，这个方法是靠访问网站的IPv6地址。如果要去的网站没有IPv6地址，那就没辙。而让我的电脑知道一个网站的IPv6地址(如果存在的话)，有两个法子:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改hosts文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用IPv6 DNS服务器&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当系统准备访问一个站点时，它需要知道目的站点的IP地址。它先会读取hosts文件，看里面是否有* IP-主机名* 的记录。如果有，它会直接按IP地址访问站点。如果hosts文件中没有相应记录，那么它会向系统设置的DNS服务器查询。DNS服务器会返回目的站点的IP地址。&lt;/p&gt;
&lt;p&gt;所以，这两个方法可以同时使用。(有关DNS的知识，本文限于篇幅将不做讨论。)&lt;/p&gt;
&lt;h3 id=&#34;修改hosts文件&#34;&gt;修改hosts文件&lt;/h3&gt;
&lt;p&gt;这是一份内容随时更新的hosts文件：&lt;a href=&#34;https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/hosts&#34;&gt;Hosts&lt;/a&gt; 。这份文件属于托管在GitHub上的&lt;a href=&#34;https://github.com/lennylxx/ipv6-hosts/&#34;&gt;一个项目&lt;/a&gt;，里面除了IPv6地址外还有一小部分由活雷锋搜集的IPv4地址，大家可以参考。&lt;/p&gt;
&lt;p&gt;将&lt;a href=&#34;https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/hosts&#34;&gt;Hosts&lt;/a&gt;文件的文本复制过来，用任意一款文字编辑器打开hosts文件，将内容粘贴进来。&lt;/p&gt;
&lt;p&gt;hosts文件在不同操作系统中的位置不同。在Windows下，它的默认路径是:&lt;br /&gt;
%SystemRoot%\system32\drivers\etc\hosts&lt;/p&gt;
&lt;p&gt;在Linux下，以我的Mint为例，它的路径是:&lt;br /&gt;
/etc/hosts&lt;/p&gt;
&lt;p&gt;修改它需要系统权限。如果是Linux，记得在前面加上sudo。&lt;/p&gt;
&lt;p&gt;改完hosts，就已经能达到我们的目标了，可以使用Google的服务了。当然，我们还可以继续下面一步，来个双保险。&lt;/p&gt;
&lt;h3 id=&#34;使用ipv6-dns服务器&#34;&gt;使用IPv6 DNS服务器&lt;/h3&gt;
&lt;p&gt;支持IPv6 的免费DNS解析服务器很多，在此仅以Google为例。如果使用其它的IPv6 DNS服务器，将下文中的IP地址替换过来就好。&lt;/p&gt;
&lt;p&gt;Google提供公共&lt;a href=&#34;https://developers.google.com/speed/public-dns/docs/using&#34;&gt;DNS解析服务&lt;/a&gt;，能解析IPv6地址。Google DNS服务器在它的IPv6地址上监听IPv6的通道发来的查询请求。如果这个查询求的是IPv6地址，而且地址存在，那么Google服务器会返回结果AAAA记录。&lt;/p&gt;
&lt;p&gt;GoogleDNS服务器的IPv6地址是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2001:4860:4860::8888&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2001:4860:4860::8844&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将它们设为自己的首选DNS服务器。对于一个典型的Linux系统:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编辑/etc/resolv.conf文件:&lt;br /&gt;
sudo vi /etc/resolv.conf&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;添加如下两条记录:&lt;br /&gt;
nameserver 2001:4860:4860::8888&lt;br /&gt;
nameserver 2001:4860:4860::8844&lt;br /&gt;
这两条记录顺序无所谓；也可以只添加一条。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;保存退出。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果系统是通过DHCP服务器获取的IP地址，那么resolv.conf文件可能会在每次开机时自动被初始化覆盖。这时，可以尝试将DNS服务器的记录保存在初始化的配置文件中。&lt;/p&gt;
&lt;p&gt;例如，我的Mint中/etc/resolv.f文件提示“OpenDNS Fallback (configured by Linux Mint in /etc/resolvconf/resolv.conf.d/tail)”，那么我将这两条记录拷贝到/etc/resolvconf/resolv.conf.d/tail里就好了。&lt;/p&gt;
&lt;p&gt;好了，到现在配置已经完成。可以通过浏览器访问Google的网站试试看了。&lt;/p&gt;
&lt;h2 id=&#34;其它&#34;&gt;其它&lt;/h2&gt;
&lt;h3 id=&#34;北邮校园网内网的dns服务器&#34;&gt;北邮校园网内网的DNS服务器&lt;/h3&gt;
&lt;p&gt;DNS查询也是需要走校外流量的。所以，最好不要将首选DNS服务器设置为外网服务器。北邮校园网内搭建有DNS服务器，譬如:&lt;/p&gt;
&lt;p&gt;#学十能用的内网DNS服务器&lt;br /&gt;
10.3.9.4， 10.3.9.5， 10.3.9.6&lt;/p&gt;
&lt;h3 id=&#34;手机科学上网&#34;&gt;手机科学上网&lt;/h3&gt;
&lt;p&gt;如果手机通过WiFi接入IPv6网络，修改DNS服务器地址为Google DNS服务器的地址，那么手机也能访问Google了。亲测，iOS7的safari能打开youtube。&lt;/p&gt;
&lt;h3 id=&#34;一些观察手段&#34;&gt;一些观察手段&lt;/h3&gt;
&lt;p&gt;在Chrome浏览器地址栏中输入: &lt;code&gt;chrome://net-internals/#dns&lt;/code&gt;可以看到浏览器的DNS解析记录。&lt;/p&gt;</description></item><item><title>厘清Java Socket端口问题 -- 服务器的端口是什么</title><link>https://blog.yuantops.com/tech/some-clarification-about-java-socket-port/</link><pubDate>Tue, 13 Jan 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/some-clarification-about-java-socket-port/</guid><description>
&lt;p&gt;在我之前翻译的&lt;a href=&#34;http://blog.yuantops.com/tech/socket-definition-oracle-java-tutorial/&#34;&gt;Socket是什么&lt;/a&gt;一文中，对java中socket建立的流程有描述。在服务器接受客户端socket连接的部分，它这么说道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果一切顺利，服务器会接受连接。一旦接受了连接，服务器会得到一个绑定了&lt;strong&gt;本地相同端口&lt;/strong&gt;的新socket，这个socket的另一端被置为客户端的地址和端口。服务器需要一个新的socket,所以它能一边继续在原来的socket监听连接请求，一边处理已建立连接的客户端的需求。&lt;/p&gt;
&lt;p&gt;(原文)&lt;br /&gt;
If everything goes well, the server accepts the connection. Upon acceptance, the server gets a new socket bound to the &lt;strong&gt;same local port&lt;/strong&gt; and also has its remote endpoint set to the address and port of the client. It needs a new socket so that it can continue to listen to the original socket for connection requests while tending to the needs of the connected client.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;配图:&lt;br /&gt;
&lt;img src=&#34;http://docs.oracle.com/javase/tutorial/figures/networking/6connect.gif&#34; alt=&#34;socket connection established&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地相同端口(same local port)&lt;/strong&gt;指的到底是哪个端口？依示例图所示，它指的就是服务器端的&lt;strong&gt;监听端口&lt;/strong&gt;，而不是其它的端口。&lt;/p&gt;
&lt;p&gt;官方文档的说法按说是权威的——事实上的确它是对的。但是，在*Head First Java*中描述ServerSocket.accept()方法有这么一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When a client finally tries to connect, the method returns a plain old Socket(on a different port) that knows how to communicate with the client(i.e, knows the client&amp;rsquo;s IP address and the port number).&lt;/p&gt;
&lt;p&gt;The socket is on a different port than the ServerSocket, so that the server socket can go back to waiting for other clients.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个说法就不太正确了。幸好*Head First Java*出版社已经发现了这个小失误，并在官方网站的勘误表上贴出了&lt;a href=&#34;http://www.oreilly.com/catalog/errataunconfirmed.csp?isbn=9780596009205&#34;&gt;说明&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This isn&amp;rsquo;t the case. The thing that has to be unique for each socket is the source port, source ip, destination port &amp;amp; destination ip.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据勘误表上的解释，每一个socket连接都需要保证是唯一的，而socket的标志符由源IP、源端口、目的IP、目的端口四部分构成。只要四者有一个不同，那么就能建立两个不同的socket。所以，对于不同的Socket连接，服务器端的IP和端口号可以相同。&lt;/p&gt;
&lt;p&gt;但*Head First Java*十分畅销，导致错误的说法流传甚广，造成了学习者很多误解。&lt;/p&gt;
&lt;h3 id=&#34;来源参考&#34;&gt;来源参考&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/4307549/serversocket-accept-method/4308243#4308243&#34;&gt;StackOverflow.com&lt;/a&gt;有网友这么解释道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The client chooses its port at random (you don&amp;rsquo;t need to do anything special in Java) and connects to the server on whichever port you specified.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;实践验证&#34;&gt;实践验证&lt;/h3&gt;
&lt;p&gt;根据这个网友提供的思路，我们可以实际检验一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/networking/sockets/clientServer.html&#34;&gt;Writing the server side of a socket&lt;/a&gt;中提供了客户端和服务器端的两个小例子。按照文章里面说的，我将几段代码下载到我的Fedora机器上，先运行服务器代码，它监听4444端口。&lt;br /&gt;
java KnockKnockServer 4444&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;netstat -na&lt;/code&gt; 命令查看机器上打开的端口，(省略无关条目)：&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;Proto Recv-Q Send-Q Local Address Foreign Address State
tcp6 &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; :::4444 :::* LISTEN&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;再运行客户端代码，它与本机上的服务器程序建立socket连接。&lt;br /&gt;
java KnockKnockClient 127.0.0.1 4444&lt;br /&gt;
再使用&lt;code&gt;netstat -na&lt;/code&gt; 命令查看机器上打开的端口，(省略无关条目)：&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;Proto Recv-Q Send-Q Local Address Foreign Address State
tcp6 &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; :::4444 :::* LISTEN
tcp6 &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;127&lt;/span&gt;.0.0.1:50031 &lt;span style=&#34;color:#ae81ff&#34;&gt;127&lt;/span&gt;.0.0.1:4444 ESTABLISHED
tcp6 &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;127&lt;/span&gt;.0.0.1:4444 &lt;span style=&#34;color:#ae81ff&#34;&gt;127&lt;/span&gt;.0.0.1:50031 ESTABLISHED &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;有两条socket的记录。其中一条是服务器的，另一条是客户端的。它们的local address和foreign address刚好是相反的，这对应了socket的local和remote概念。从这两条记录看，建立的socket连接，服务器端占用的端口还是监听端口(4444)，而且此时服务器还在端口(4444)监听连接请求。&lt;/p&gt;</description></item><item><title>理解Docker -- Docker Official Docs翻译</title><link>https://blog.yuantops.com/tech/understanding-docker/</link><pubDate>Mon, 12 Jan 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/understanding-docker/</guid><description>
&lt;h3 id=&#34;docker是什么&#34;&gt;Docker是什么&lt;/h3&gt;
&lt;p&gt;Docker是用于开发(develop)、转移(ship)、运行(run)程序(application)的一个开放平台。Docker的设计目的是为了更快地传递程序。在Docker的帮助下，你能将程序与硬件基础(infrastructure)隔离、把硬件基础看作一个可管理的程序。Docker能帮你更快地转移代码、测试代码、部署代码，缩短编写代码与运行代码之间的周期。&lt;/p&gt;
&lt;p&gt;Docker将一种轻量级的容器虚拟化平台技术(container virtualization platform)与相应的工作流程和工具结合起来，从而能帮你管理、部署自己的程序。&lt;/p&gt;
&lt;p&gt;在核心层面，Docker支持在一个容器(container)中安全(securely)、独立(isolated)地运行几乎任何一种程序。这种独立性、安全性允许你在主机(host)上同时运行多个容器。容器在运行时不需要分配额外负载给监视程序(hypervisor)，它的这种轻量级特性意味着你能更大限度地使用硬件资源。&lt;/p&gt;
&lt;p&gt;基于容器虚拟化，Docker提供的工具和平台能帮助你：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将你的程序(和支持的组件)放到Docker容器中&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;分发(distribute)、转移(ship)这些容器给自己的团队成员，以便他们后续的开发和测试&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;把这些程序部署到产品环境中，不管你的产品环境位于本地数据中心还是在云中&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;我能用docker做什么&#34;&gt;我能用Docker做什么？&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;更快地转移程序&lt;/em&gt;&lt;br /&gt;
Docker是帮你处理开发周期的绝好工具。Docker能允许开发者在包含你的程序和服务的本地容器上开发，然后它能整合到一个连续的整合、部署工作流程中。&lt;/p&gt;
&lt;p&gt;举个例子。开发者在本地编写程序，通过Docker将开发环境与同事共享。当他们的工作完成时，开发者将他们的代码和开发环境推送到一个测试环境上，并且执行任何必要的测试。然后，你能从测试环境将Docker镜像(image)推送到产品，部署代码。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;更方便地部署、扩展&lt;/em&gt;&lt;br /&gt;
Docker基于容器的平台支持高便携性(portable)的工作负载(workload)。Docker容器能运行在开发者的本地机器上、数据中心的物理/虚拟机器上，也能运行在云端。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;支持更高密度，运行更多工作负载&lt;/em&gt;&lt;br /&gt;
Docker是轻量级的，而且很快。与基于监督程序(hypervisor)的虚拟机相比，它提供了可变的、低消耗的替代方案。在高密度(high density)的工作环境中，这一点就显得格外重要，例如：当搭建你自己的云或者Platform-as-a-service服务时。不止如此，当你想尽可能地利用你的资源来做小型/中型的部署时，Docker也同样有用。&lt;/p&gt;
&lt;h2 id=&#34;docker的主要组件有哪些&#34;&gt;Docker的主要组件有哪些？&lt;/h2&gt;
&lt;p&gt;Docker主要组件有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker: 开源的容器虚拟化平台&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;：Software-as-a-Service平台，用来分享、管理Docker容器&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：Docker受开源协议Apache 2.0约束&lt;/p&gt;
&lt;h2 id=&#34;docker的架构&#34;&gt;Docker的架构&lt;/h2&gt;
&lt;p&gt;Docker使用客户端-服务器架构。Docker&lt;em&gt;客户端&lt;/em&gt;(client)与Docker&lt;em&gt;守护进程&lt;/em&gt;(deamon)通信，后者来完成建立版本(build)、运行(run)、分发(distribute)Docker容器等工作。Docker客户端和守护进程*可以*同时运行在一个系统上；你也可以将Docker客户端连接到一个远程Docker守护进程。Docker客户端和Docker守护进程通过socket或者REST API通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://docs.docker.com/article-img/architecture.svg&#34; alt=&#34;Docker Arch&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;docker守护进程&#34;&gt;Docker守护进程&lt;/h3&gt;
&lt;p&gt;如上图所示，Docker守护进程运行在一台宿主机器上。用户不直接与守护进程通信，而是通过客户端与之通信。&lt;/p&gt;
&lt;h3 id=&#34;docker客户端&#34;&gt;Docker客户端&lt;/h3&gt;
&lt;p&gt;Docker客户端，往往是二进制形式的&lt;code&gt;docker&lt;/code&gt;程序，是Docker最主要的用户使用接口。它接收来自用户的命令，将它来回地与守护程序进行通信。&lt;/p&gt;
&lt;h3 id=&#34;在docker内部&#34;&gt;在Docker内部&lt;/h3&gt;
&lt;p&gt;为了理解Docker的内部原理，你需要理解三个组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;镜像(image)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;仓库(registry)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;容器(container)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;镜像&#34;&gt;#镜像&lt;/h3&gt;
&lt;p&gt;镜像是一个只读(read-only)的模板。例如，一个镜像可能包含安装了Apache和你的Web服务器的一个Ubuntu操作系统。镜像是用来创造Docker容器的。通过Docker，你能以简单的方式创建新的镜像、更新现存的镜像，或者下载别人已经创建好了的镜像。Docker镜像是Docker的&lt;strong&gt;创建(build)&lt;/strong&gt;组件。&lt;/p&gt;
&lt;h3 id=&#34;仓库&#34;&gt;仓库&lt;/h3&gt;
&lt;p&gt;仓库保存镜像。它们是你用来上传、下载镜像的私有/公有场所。官方的Docker仓库是&lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;，它提供了一个巨大的镜像仓库集以供你使用。你可以自己创建镜像，也可以使用别人事先已经建好了的镜像。Docker仓库是Docker的&lt;strong&gt;分发(distribute)&lt;/strong&gt;组件。&lt;/p&gt;
&lt;h3 id=&#34;容器&#34;&gt;容器&lt;/h3&gt;
&lt;p&gt;容器与目录类似。容器包含了运行一个程序所需要的所有东西。每个容器都是创建自一个镜像。容器可以被运行、启动、停止、移动、删除。每个容器都是一个隔离、安全的程序平台。Docker容器是Docker的&lt;strong&gt;运行(run)&lt;/strong&gt;组件。&lt;/p&gt;
&lt;h2 id=&#34;那么-docker到底如何工作&#34;&gt;那么，Docker到底如何工作？&lt;/h2&gt;
&lt;p&gt;现在，我们已经知道：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你可以创建Docker镜像来保存程序&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;你可以从Docker镜像中新建Docker容器来运行程序&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;你可以通过&lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;或者自己的私有仓库来分享Docker镜像&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面，让我们看看这些组件是如何协作起来使Docker工作的。&lt;/p&gt;
&lt;h2 id=&#34;镜像如何工作&#34;&gt;镜像如何工作？&lt;/h2&gt;
&lt;p&gt;我们已经知道，镜像是只读模板，由它们启动容器。每个镜像由一系列层(layer)组成。Docker利用&lt;a href=&#34;http://en.wikipedia.org/wiki/UnionFS&#34;&gt;union file system&lt;/a&gt;将这些层组合成单个镜像。Union file system允许独立文件系统的文件和目录(被称作branch)被透明地叠架起来(overlaid)，以此组成一个单个紧密的文件系统。&lt;/p&gt;
&lt;p&gt;Docker被称为“轻量级”，原因之一就在于这些层。当你改变一个镜像的时候，譬如说将某个程序更新到了新版本，一个层会被新建出来。如果我们使用的是虚拟机，这时候往往需要替换整个镜像，要不就是整体再创建一个版本。对比之下，Docker只需添加或者更新一个层。如此，你不必再去分发一整个镜像，而仅仅需要更新层就好了，这使得发布Docker的镜像变得更快、更容易。&lt;/p&gt;
&lt;p&gt;每个镜像都以一个基础镜像为起点，譬如&lt;code&gt;ubuntu&lt;/code&gt;，一个基础的Ubuntu镜像，或者&lt;code&gt;fedora&lt;/code&gt;，一个基础的Fedora镜像。你也可以用自己的镜像做新镜像的基础镜像，譬如如果你有个基础的Apache镜像，你就能用它作你所有网页程序镜像的基础。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：Docker一般从&lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;中获取基础镜像。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从基础镜像出发，我们能通过简单、描述性的一系列步骤(我们称其为&lt;em&gt;指示(instructions)&lt;/em&gt;)新建一个镜像。每一步都会在我们的镜像中新建一个层。这些步骤包括以下动作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行命令&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;添加文件或者目录&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;创建环境变量&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;定义当启动从这个镜像创建的容器时，应该运行那些进程&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些指示被保存在&lt;code&gt;Dockerfile&lt;/code&gt;文件中。当你申请从镜像生成一个版本(build)时，Docker会读取&lt;code&gt;Dockerfile&lt;/code&gt;、执行指示，然后返回最终的镜像。&lt;/p&gt;
&lt;h2 id=&#34;仓库如何工作&#34;&gt;仓库如何工作？&lt;/h2&gt;
&lt;p&gt;仓库是Docker镜像的存储之处。当你创建了一个镜像，你可以将它推送到公共仓库&lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;或者自己防火墙之内的私有仓库。&lt;/p&gt;
&lt;p&gt;使用Docker客户端，你能搜索已发布的镜像，然后将它们拉去到本地的Docker主机，再从它里面创建容器。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;提供镜像的公有和私有存储。公有存储可以被任何人搜索、下载。私有存储不显示在搜索结果中，而且只有你和你的用户能从中拉取镜像、用这些镜像来生成容器。&lt;/p&gt;
&lt;h2 id=&#34;容器如何工作&#34;&gt;容器如何工作？&lt;/h2&gt;
&lt;p&gt;容器由操作系统、用户添加的文件和元文件(meta-data)构成。我们已经知道，每个容器都由一个镜像创建。这个镜像告诉Docker应该持有什么、在启动容器时应该运行什么，以及其他一系列的配置文件。镜像是只读的。当Docker从镜像创建一个容器时，它在镜像的顶端加上一个读写层(read-write layer)，这样我们的程序就能在它上面运行了。&lt;/p&gt;
&lt;h2 id=&#34;启动一个容器时-发生了什么&#34;&gt;启动一个容器时，发生了什么&lt;/h2&gt;
&lt;p&gt;不论通过&lt;code&gt;docker&lt;/code&gt;命令还是API，Docker客户端通知Docker守护进程去启动一个容器。&lt;br /&gt;
$ sudo docker run -i -t ubuntu /bin/bash&lt;/p&gt;
&lt;p&gt;我们将这条命令分解来看。Docker客户端通过带&lt;code&gt;run&lt;/code&gt;参数的&lt;code&gt;docker&lt;/code&gt;命令新启动一个容器。为了启动一个容器，Docker客户端至少需要告知Docker守护进程：&lt;br /&gt;
- 容器应该创建自哪个Docker镜像。在这里是&lt;code&gt;ubuntu&lt;/code&gt;，一个基础Ubuntu镜像。&lt;br /&gt;
- 当容器启动后，你要在容器内运行什么命令。这里是&lt;code&gt;/bin/bash&lt;/code&gt;，它在容器内启动了Bash shell。&lt;/p&gt;
&lt;p&gt;那么，当我们运行这条命令时，后台发生了什么呢？&lt;/p&gt;
&lt;p&gt;Docker按顺序做了如下事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;拉取ubunut镜像&lt;/strong&gt;：Docker检查&lt;code&gt;ubuntu&lt;/code&gt;镜像是否存在，如果在本地不存在，那么它从&lt;a href=&#34;https://hub.docker.com/&#34;&gt;Docker Hub&lt;/a&gt;下载镜像；如果镜像已经存在，Docker将利用它启动新容器。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建新容器&lt;/strong&gt;：Docker有了镜像，用它来新建一个容器。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分配文件系统，挂载读写层&lt;/strong&gt;：在文件系统中新建了容器，并给镜像新添了一个读写层。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分配网络/网桥接口&lt;/strong&gt;：新建一个网络接口，使Docker容器能与本地主机通信。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设置IP地址&lt;/strong&gt;：从地址池中找到一个可用IP，将它关联到容器。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行你指定的程序&lt;/strong&gt;：运行程序。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;捕获、提供程序输出结果&lt;/strong&gt;：连接并记录标准输入、标准输出、标准错误，使你能看到程序的运行情况。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;恭喜，你有了一个运行中的容器！从这里，你可以管理容器，与程序交互，然后当结束后停止、移除容器。&lt;/p&gt;
&lt;h2 id=&#34;底层技术&#34;&gt;底层技术&lt;/h2&gt;
&lt;p&gt;Docker用Go语言编写，而且利用了Linux 内核的相关特性来完成上述的功能。&lt;/p&gt;
&lt;h3 id=&#34;命名空间-namespace&#34;&gt;命名空间(namespace)&lt;/h3&gt;
&lt;p&gt;Docker使用了一项叫作&lt;code&gt;命名空间(namespace)&lt;/code&gt;的技术来为容器提供隔离的工作空间。当我们启动一个容器时，Docker会为它创建一系列命名空间。&lt;/p&gt;
&lt;p&gt;这样形成了一个隔离层：容器的每个部分都在它自己的命名空间里运行，而且没有访问它之外的权限。&lt;/p&gt;
&lt;p&gt;Docker使用的部分命名空间包括：&lt;br /&gt;
- &lt;strong&gt;pid命名空间&lt;/strong&gt;：用于进程隔离(PID, Process ID)&lt;br /&gt;
- &lt;strong&gt;net命名空间&lt;/strong&gt;：用于管理网络接口(NET, networking)&lt;br /&gt;
- &lt;strong&gt;ipc命名空间&lt;/strong&gt;：用于管理IPC资源(IPC, InterProcess Communication进程间通信)&lt;br /&gt;
- &lt;strong&gt;mnt命名空间&lt;/strong&gt;：用于管理挂载点(MNT, Mount)&lt;br /&gt;
- &lt;strong&gt;uts命名空间&lt;/strong&gt;：用于内核和版本标志隔离(UTS, Unix Timesharing System)&lt;/p&gt;
&lt;h3 id=&#34;组控制-control-groups&#34;&gt;组控制(Control groups)&lt;/h3&gt;
&lt;p&gt;Docker还用到&lt;code&gt;cgroups&lt;/code&gt;技术来进行组控制。隔离运行中程序的关键一点在于，让它们只使用你想让它使用的资源。这确保这些容器在宿主机器上能规规矩矩的。组控制允许Docker能向容器共享硬件资源，而且在必要时候设置资源的上限和限制。例如，可以设置某个特定容器的内存上限。&lt;/p&gt;
&lt;h3 id=&#34;union-file-systems&#34;&gt;Union file Systems&lt;/h3&gt;
&lt;p&gt;Union file Systems，或者UnionFS，是通过创建层的方式运行的，轻量、快速的文件系统。Docker使用Union file Systems为容器提供块(block)。Docker能利用包括AUFS, btrfs, vfs, 和DeviceMapper在内的Union file Systems。&lt;/p&gt;
&lt;h3 id=&#34;容器格式&#34;&gt;容器格式&lt;/h3&gt;
&lt;p&gt;Docker将这些组件结合成一个我们称之为容器格式的包裹层(wrapper)。默认的容器格式被称作&lt;code&gt;libcontainer&lt;/code&gt;。Docker也支持使用&lt;a href=&#34;https://linuxcontainers.org/&#34;&gt;LXC&lt;/a&gt;的传统Linux容器。未来，Docker可能会支持更多的容器格式，例如可能会整合BSD Jail或者Solaris Zone。&lt;/p&gt;
&lt;h2 id=&#34;下一步&#34;&gt;下一步&lt;/h2&gt;
&lt;h3 id=&#34;安装docker&#34;&gt;安装Docker&lt;/h3&gt;
&lt;p&gt;访问&lt;a href=&#34;https://docs.docker.com/installation/#installation&#34;&gt;installation guide&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;docker用户指南&#34;&gt;Docker用户指南&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/userguide/&#34;&gt;Learn Docker in depth&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;原文链接&#34;&gt;原文链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/introduction/understanding-docker/&#34;&gt;About Docker&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Activity的生命周期以及两个Activity跳转时的状态变化</title><link>https://blog.yuantops.com/tech/android-activity-lifecycle-with-two-activites/</link><pubDate>Sun, 11 Jan 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/android-activity-lifecycle-with-two-activites/</guid><description>&lt;p&gt;##Android Activity的生命周期
下面这张图非常清晰地介绍了Activity的生命周期：&lt;br /&gt;
&lt;img src=&#34;http://www.startandroid.ru/images/stories/lessons/L0023/L0023_010_en.jpg&#34; alt=&#34;Activity Lifecycle&#34; /&gt;&lt;/p&gt;
&lt;p&gt;##当通过intent跳转时的状态变化
一个Activity的状态有三个：Stopped(存在但看不见)，Paused(部分可见，但无焦点)，Resumed(激活状态，拥有焦点，可以与之交互)。如果将不存在也算作一个状态，那样一共就有四个状态。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.startandroid.ru/en/lessons/complete-list/232-lesson-24-activity-lifecycle-example-about-changing-states-with-two-activities.html&#34;&gt;这篇文章&lt;/a&gt;非常详细地讨论了当通过intent在一个Activity中启动另一个Activity时，它们两个Activity的状态变化过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当由MainActivity跳转到ActivityTwo时&lt;/strong&gt;，下面是方法的调用顺序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; MainActivity: onPause()
ActivityTwo: onCreate()
ActivityTwo: onStart()
ActivityTwo: onResume()
MainActivity: onStop()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;步骤为：MainActivity失去焦点，转到Paused状态-&amp;gt;ActivityTwo新建但不可见,处于Stopped状态-&amp;gt;ActivityTwo可见，处于Paused状态-&amp;gt;ActivityTwo获得焦点，处于Resumed状态-&amp;gt;MainActivity不可见，处于Stopped状态。&lt;/p&gt;
&lt;p&gt;值得注意的是，当ActivityTwo位于前台时，MainActivity并没有被销毁，而是仍保存在内存中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;按下后退键，由ActivityTwo返回MainActivity时&lt;/strong&gt;，方法的调用顺序为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; ActivityTwo: onPause()
MainActivity: onRestart()
MainActivity: onStart()
MainActivity: onResume()
ActivityTwo: onStop()
ActivityTwo: onDestroy()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;步骤与上一步类似。值得注意之处有二：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其一，MainActivity.onRestart方法先于MainActivity.onStart方法调用。如果Activity不是从无到有新建出来的，那么在onStart方法前都会先调用onRestart方法。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;其二，ActivityTwo被销毁了。至于为什么此时ActivityTwo会被销毁，涉及到Task的原理。在&lt;a href=&#34;http://www.startandroid.ru/en/lessons/complete-list/234-lesson-25-task-what-is-it-and-how-it-is-formed.html&#34;&gt;这篇文章&lt;/a&gt;中有介绍。&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Android中Context的作用</title><link>https://blog.yuantops.com/tech/use-of-context-in-android/</link><pubDate>Sun, 11 Jan 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/use-of-context-in-android/</guid><description>&lt;p&gt;##官方文档中对Context的介绍
&amp;gt;Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc.&lt;/p&gt;
&lt;p&gt;翻译：&lt;br /&gt;
Context是Android应用的全局信息的接口。它是一个虚类，它的实现由Android系统完成。它提供了对某个应用的资源和类的访问权限，也提供对应用层面操作(如启动Activity，发送broadcast，接受intent)的调用接口。&lt;/p&gt;
&lt;p&gt;##总结
&lt;a href=&#34;http://stackoverflow.com/questions/3572463/what-is-context-in-android&#34;&gt;StackoverFlow.com&lt;/a&gt;上有人根据自己的理解总结了Context的用法，说得很有道理，以下是我的翻译。&lt;/p&gt;
&lt;p&gt;正如Context的名字所说，它是一个应用/对象(applicaton/object)当前状态的上下文。它让新建的对象知道当前正在发生着什么。典型的用法，你可以调用它来得到关于你程序其它部分(Activity，package/application等)的信息。&lt;/p&gt;
&lt;p&gt;你可以通过以下方式得到context: getApplicationContext(), getContext(), getBaseContext()或者this(当位于一个Activity class中时)。&lt;/p&gt;
&lt;p&gt;典型用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;新建对象&lt;/strong&gt;：新建views, adapters, listeners等：&lt;br /&gt;
TextView tv = new TextView(getContext());
ListAdapter adapter = new SimpleCursorAdapter(getApplicationContext(), &amp;hellip;);&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;访问资源&lt;/strong&gt;：譬如LAYOUT_INFLATER_SERVICE, SharedPreferences一类的资源：&lt;br /&gt;
context.getSystemService(LAYOUT_INFLATER_SERVICE)&lt;br /&gt;
getApplicationContext().getSharedPreferences(&lt;em&gt;name&lt;/em&gt;, &lt;em&gt;mode&lt;/em&gt;);&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;隐式访问组件&lt;/strong&gt;：content providers, broadcast, intent 等：&lt;br /&gt;
getApplicationContext().getContentResolver().query(uri, &amp;hellip;);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Sockets in Java -- Oracle Java Tutorial 翻译</title><link>https://blog.yuantops.com/tech/java-all-about-sockets-oracle-java-tutorial/</link><pubDate>Sun, 11 Jan 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/java-all-about-sockets-oracle-java-tutorial/</guid><description>&lt;p&gt;##课程：关于Sockets的一切
URL和URLConnection为获取因特网上的资源提供了一种相对高层次(high-level)的机制。但有时候，你的程序需要一种相对低层次(lower-level)的网络通信，譬如说，你可能需要编写一个客户端-服务器(client-server)程序。&lt;/p&gt;
&lt;p&gt;在客户端-服务器程序中，服务器端提供一些服务：譬如处理数据库查询，或者发送当前的期货价格。客户端利用服务器提供的这些服务器，用来向用户显示数据库查询的结果，或者给投资者提供期货的购买建议。客户端和服务器端的通信因此必须是&lt;strong&gt;可信&lt;/strong&gt;的。换言之，数据不能丢失，而且它到达客户端的顺序必须与服务器的发送顺序一致。&lt;/p&gt;
&lt;p&gt;TCP协议提供了一个可信的、点到点的通信信道，因特网上的客户端-服务器端程序可以使用它来通信。为了基于TCP通信，客户端程序和服务器程序要和对方建立连接。每个程序各自将一个socket绑定到连接的一头。当通信时，客户端和服务器各自从与连接绑定的socket里面读/写数据。&lt;/p&gt;
&lt;p&gt;##Socket是什么?
因特网上运行着的两个程序建立了一个双向的通信连接，Socket就是这个连接的一端。Socket类用来表示一个客户端程序和一个服务器程序间的连接。java.net包中提供了Socket和ServerSocket这两个类，它们分别是这一连接的客户端实现和服务器端实现。&lt;/p&gt;
&lt;p&gt;##通过Socket读和写
&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/networking/sockets/readingWriting.html&#34;&gt;Reading from and Writing to a Socket&lt;/a&gt;包含一个小例子，它演示了客户端程序如何从Socket读数据和向socket写数据。&lt;/p&gt;
&lt;p&gt;##编写一对socket Client/Server
&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/networking/sockets/readingWriting.html&#34;&gt;Reading from and Writing to a Socket&lt;/a&gt;演示了客户端程序如何通过socket与一个存在的服务器端交互。&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/networking/sockets/clientServer.html&#34;&gt;Writing a Client/Server Pair&lt;/a&gt;则演示如何实现连接的另一端——服务器端的功能。&lt;/p&gt;
&lt;p&gt;##原文链接
&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/networking/sockets/index.html&#34;&gt;Lesson: All About Sockets&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Socket是什么 -- Oracle Java Tutorial 翻译</title><link>https://blog.yuantops.com/tech/socket-definition-oracle-java-tutorial/</link><pubDate>Sun, 11 Jan 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/socket-definition-oracle-java-tutorial/</guid><description>&lt;p&gt;一般而言，一个服务器运行在一台电脑上，这个服务器有一个绑定了端口号的socket。这个服务器一边等待，一边守着socket监听从客户端发过来的连接请求。&lt;/p&gt;
&lt;p&gt;在客户端：客户端知道服务器所在的主机的主机名(hostname)和服务器正在监听的端口号。为了发出连接请求，客户端尝试着连接服务器所在的主机名和端口。客户端同时也需要向服务器端证明自己的身份，因此它也绑定了一个本地的端口号以便在本次连接中使用。这一般是由系统指定的。&lt;br /&gt;
&lt;img src=&#34;http://docs.oracle.com/javase/tutorial/figures/networking/5connect.gif&#34; alt=&#34;Server listening on port&#34; /&gt;&lt;br /&gt;
如果一切顺利，服务器会接受连接。一旦接受了连接，服务器会得到一个绑定了本地相同端口的新socket，这个socket的另一端被置为客户端的地址和端口。服务器需要一个新的socket,所以它能一边继续在原来的socket监听连接请求，一边处理已建立连接的客户端的需求。&lt;br /&gt;
&lt;img src=&#34;http://docs.oracle.com/javase/tutorial/figures/networking/6connect.gif&#34; alt=&#34;connection_established&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在客户端，如果连接请求被接受，会成功新建一个socket。客户端能利用这个socket来与服务器端通信。&lt;/p&gt;
&lt;p&gt;现在，客户端和服务器能通过向它们的sockets读/写数据来通信了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;定义&lt;br /&gt;
Socket是网络上运行着的两个程序所形成的双向通信连接的一端(endpoint)。每个socket都绑定了一个端口号，所以TCP层能确定数据接收方的程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;连接的一端&lt;/em&gt;(&lt;em&gt;endpoint&lt;/em&gt;)是一个IP地址和一个端口号的组合。每个TCP连接能被两个*连接的一端*唯一标志。这样，主机和服务器之间就能存在多个连接。&lt;/p&gt;
&lt;p&gt;Java平台上的java.net包提供了Socket这个类，它实现了Java程序和网络上另一个程序的双向连接的一边。Socket类位于依赖于平台的实现方式的顶端，向Java程序隐藏了所有系统的细节。通过使用java.net.Socket类而不是系统的原生代码，Java程序能一种独立于平台的实现方式与网络通信。&lt;/p&gt;
&lt;p&gt;另外，java.net包也包括了ServerSocket类，它实现的socket能被服务器用来监听、接受来自客户端的连接请求。&lt;/p&gt;
&lt;p&gt;如果你想连接Web，那么URL类和与之相关的类(URLConnection, URLEncoder)可能比Socket类更适合。事实上，URL类是连接Web相对更高层次的方式，它也用到sockets作为底层的部分实现。&lt;/p&gt;
&lt;p&gt;##原文链接
&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/networking/sockets/definition.html&#34;&gt;What Is a Socket?&lt;/a&gt;&lt;/p&gt;</description></item><item><title>[转载]Android Intent原理分析</title><link>https://blog.yuantops.com/tech/an-insight-of-android-intent/</link><pubDate>Sun, 11 Jan 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/an-insight-of-android-intent/</guid><description>&lt;p&gt;##原文链接
&lt;a href=&#34;http://blog.chinaunix.net/uid-741742-id-359319.html&#34;&gt;Android Intent原理分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##转载原文正文
Revision History&lt;/p&gt;
&lt;p&gt;wylhistory&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Abstract&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Introduction&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Intent的架构&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Intent的发送过程&lt;br /&gt;
4.1 Intent消息在发送进程的逻辑&lt;br /&gt;
4.2 Intent发送在服务器端的执行&lt;br /&gt;
4.2.1 进入消息队列之前&lt;br /&gt;
4.2.2 进入消息队列后的处理&lt;br /&gt;
4.2.3 消息的分发过程&lt;br /&gt;
4.2.4 deliverToRegisteredReceiver的逻辑&lt;br /&gt;
4.2.5 processCurBroadcastLocked的逻辑&lt;br /&gt;
4.2.6 startProcessLocked的逻辑&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Intent的接收过程&lt;br /&gt;
5.1 Receiver的注册&lt;br /&gt;
5.2 scheduleReceiver&lt;br /&gt;
5.3 scheduleRegisteredReceiver的逻辑&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;未分析&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Abstract&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;主要是分析一下android的IPC通讯之Intent；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Introduction&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;任何一个操作系统，都有自己的IPC通讯机制，Android也不例外；&lt;br /&gt;
IPC通讯在linux下面通常包括共享内存，管道，消息队列等，这其中共享内存的效率比较高，我想；&lt;br /&gt;
这里将要说的Intent的通讯机制是基于Binder的，而Binder的机制本质上是共享内存；&lt;br /&gt;
Intent中文翻译为：n.意图，意向，目的 a.专心的；急切的；没有一个特别适合，所以我还是决定用英文；&lt;br /&gt;
它的作用，我想就是传达一些信息各特定的对象，或者广播一些信息各某些对象；这里涉及两方面的内容：&lt;br /&gt;
A） 消息的发送；&lt;br /&gt;
B） 消息的接收；&lt;/p&gt;
&lt;p&gt;后面就会具体的展开；&lt;/p&gt;
&lt;p&gt;讨论之前先看一个简单的例子：
Intent intent = new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);&lt;br /&gt;
mContext.sendBroadcast(intent);&lt;/p&gt;
&lt;p&gt;这是摘自HeadsetObserver.java的代码；&lt;br /&gt;
后面将会以此为例，分析发送和接收的过程；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Intent的架构&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Intent的架构包括三方面：&lt;br /&gt;
Client，也就是发送这个Intent的activity；&lt;br /&gt;
Server，也就是activityManagerService.java,它主要是负责分发这些Intent给适当的对象；&lt;br /&gt;
Target，也就是那些需要处理这个Intent的activity，我们称为Receiver；&lt;/p&gt;
&lt;p&gt;需要大致的了解一下，Intent通常有哪些部分？我们常用的包括三方面：&lt;br /&gt;
A） action，就是这个intent是想达到什么目的，比如是想打电话，还是想告诉我们电池电量低？&lt;br /&gt;
B） 数据，也就是这个intent要处理的是这些数据，如果你是receiver的话，你需要考虑，你是否需要处理这个intent，这里包括数据的URI，以及数据的类型；&lt;br /&gt;
C） Category，这个就是需要处理这个Intent的activity的种类，这个种类是比较难以理解的，我想Google的本意是想区分一下不同的Activity的种类，比如对于CATEGORY_LAUNCHER，这个就表示它是一个启动器，有些消息只需要由特定类型的activity来处理；&lt;/p&gt;
&lt;p&gt;当然还有其它的一些属性，但是我们经常遇到的就是这三个，而这三个里面最常用的是Action；&lt;br /&gt;
这些项的作用，主要是被activityManagerService用来挑选适当的Activity来处理这个Intent；&lt;br /&gt;
好了，太多的概念，让人有点头晕，后面会再详细的讲；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Intent的发送过程&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;4.1 Intent消息在发送进程的逻辑&lt;/p&gt;
&lt;p&gt;回到我们先前的那个例子：&lt;/p&gt;
&lt;p&gt;Intent intent = new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);&lt;br /&gt;
mContext.sendBroadcast(intent);&lt;/p&gt;
&lt;p&gt;第一句话是构造一个Intent，注意只传入了一个参数，这个参数就是一个Action，没有指定data以及Category；也就是说如果某个Receiver写成这样（在AndroidManifext.xml里面）：&lt;/p&gt;
&lt;p&gt;&lt;receiver android:name=&#34;MediaButtonIntentReceiver&#34;&gt;
&lt;intent-filter&gt;
&lt;action android:name=&#34;android.media.AUDIO_BECOMING_NOISY&#34; /&gt;
&lt;/intent-filter&gt;&lt;br /&gt;
&lt;/receiver&gt;&lt;/p&gt;
&lt;p&gt;这个receiver的onReceive函数将会被调用，其中receiver表示处理这个Intent消息的类，而intent-filter表示这个receiver关心哪些Intent，这里写明了，我只关心，action == android.media.AUDIO_BECOMING_NOISY的Intent，如果是其它的Intent请别来烦我；&lt;/p&gt;
&lt;p&gt;第二句话的目的就是把这个消息广播出去，谁关心谁处理去，从此和我没关系了；&lt;br /&gt;
我可以很负责任的说，这个mContext的类型为ApplicationContext，在Android的代码里，这样命名的变量多半是这个类型，所以后面的逻辑就简单描述为：&lt;br /&gt;
Android的代码很多都这样，一层层的调用，很多时候都是二传手，这是模块化设计需要付出的代价，不过，值得；&lt;/p&gt;
&lt;p&gt;对于分析来说，需要理清楚这个调用到底去了什么地方？&lt;/p&gt;
&lt;p&gt;代码在ActivityManagerNative.java里面：&lt;br /&gt;
这是一个典型的Binder调用，从此以后代码的执行进入了另外一个进程；&lt;/p&gt;
&lt;p&gt;4.2 Intent发送在服务器端的执行&lt;br /&gt;
4.2.1 进入消息队列之前&lt;br /&gt;
这个图的逻辑是由ActivityManagerService.java来执行的，基本上也没什么意思；&lt;br /&gt;
重要的是最后调用的这个函数broadcastIntentLocked，基本上主要的工作都是由它来完成的；&lt;br /&gt;
这个函数非常重要，需要详细分析：&lt;br /&gt;
1，首先是进行一些权限检查，保证非串行的Intent其resultTo receiver必须是null;&lt;br /&gt;
2，如果这个Intent是说某个包被删除了或者改变了，那么当前的历史栈里面的属于这个包的activity就必须被关掉；&lt;br /&gt;
3，如果是时区改变的消息，那么将会先被放进队列里面通知当前正在运行的进程；&lt;br /&gt;
4，权限检查，判断是否有权限发送受保护的Intent，对于SYSTEM_UID，PHONE_UID，SHELL_UID，或者callingUid == 0的情况不做检查，也就是说默认这些调用者有这个发送的权限；&lt;br /&gt;
5，对于sticky类型的Intent做一些特殊处理（关于sticky类型等概念后面会讲），简单就是把这个Intent加入到mStickyBroadcasts链表中去；&lt;br /&gt;
6，判断这个Intent是有一个明确的对象，如果是那么直接把它的对象加入到receivers列表中去，如果不是，那么会继续判断是不是这个Intent在发送的时候设置了FLAG_RECEIVER_REGISTERED_ONLY标志，如果是，那么这个Intent将只发送给已经注册的Receiver，不会发送给Broadcast receiver,否则就发送给所有的那些满足条件的receivers；这里就涉及Intent的匹配原则，主要是通过函数queryIntent(Intent intent, String resolvedType, boolean defaultOnly)来匹配的，原则就是我前面说的，根据Action，data type，category等来匹配，记住，每条规则之间的关系是或的关系，比如：&lt;br /&gt;
&lt;receiver android:name=&#34;MediaButtonIntentReceiver&#34;&gt;
&lt;intent-filter&gt;
&lt;action android:name=&#34;android.intent.action.MEDIA_BUTTON&#34; /&gt;
&lt;action android:name=&#34;android.media.AUDIO_BECOMING_NOISY&#34; /&gt;
&lt;/intent-filter&gt;
&lt;/receiver&gt;&lt;/p&gt;
&lt;p&gt;就表示只要匹配到其中一条就算成功；另外，对于没有写明的匹配规则默认就算成功，比如对于此规则，没有写明数据类型，种类等，那么默认所有的数据类型都可以匹配上；&lt;/p&gt;
&lt;p&gt;7，如果是registeredReceivers不为空并且这个Intent不是串行的，也就是上一步已经取出了对应的接收者，那么就需要把这个Intent封装成一个BroadcastRecord，然后加入到mParallelBroadcasts，这个称为并行广播，也就是说可以同时发送给多个接收者，再通过scheduleBroadcastsLocked触发真正的发送；&lt;br /&gt;
8，过滤一种特殊情况，也就是对于ACTION_PACKAGE_ADDED消息，这个被安装的包本身不能作为这个消息的接收者；&lt;br /&gt;
9，然后对registeredReceivers和receivers做一个合并，如果这两个都不为空的话，记住，合并前这个receivers标识了“具有固定对象的接收者或者是当前已经注册的接收者不包括广播接收者”，而registeredReceivers表示broadcast Filter，另外这步能合并的前提是这个Intent是串行的Intent，否则是不会合并的；&lt;br /&gt;
10， 合并以后receivers表示所有的串行receivers通过mOrderedBroadcasts.add&amp;reg;加入到列表中去，再通过scheduleBroadcastsLocked触发真正的发送；&lt;/p&gt;
&lt;p&gt;OK，这个函数基本上就结束了，这里有三个概念需要解释，串行,并行，sticky的BroadCast；&lt;br /&gt;
串行：就表示这个Intent必须一个一个的发送给接收者；&lt;br /&gt;
并行：表示这个Intent可以同时发送给多个接收者，通常广播的消息都是并行的；&lt;br /&gt;
Sticky：这个类型的BroadCast比较难以理解，问了google也没有答案，我个人的理解是这样的，某些Intent需要被保留，当新的应用起来后，需要关注这个消息，但是呢，又不需要启动这个应用来接收此消息，比如耳机插入等消息，这里说实话，真的很巧妙，我们以前在maemo上碰到过这个问题，当时我们的策略是应用起来的时候自己查询耳机的状态，这里的处理明显就高明许多；&lt;/p&gt;
&lt;p&gt;总结一下这个函数：它的主要作用是根据这个Intent的特点，构造BroadCastRecord加入到不同的列表，等待被处理；&lt;/p&gt;
&lt;p&gt;OK，控制到了scheduleBroadcastsLocked这里，它的逻辑很简单：&lt;br /&gt;
private final void scheduleBroadcastsLocked() {
if (mBroadcastsScheduled) {
return;
mHandler.sendEmptyMessage(BROADCAST_INTENT_MSG);
mBroadcastsScheduled = true;
先判断mBroadcastsScheduled是否为真，如果为真就直接返回,这个变量主要是实现scheduleBroadcastsLocked和processNextBroadcast之间的顺序执行，后面会看到在processNextBroadcast函数里面会把它设置为false；&lt;br /&gt;
下面就是通过BROADCAST_INTENT_MSG消息放入到消息队列里面，从这个角度来说Intent最后也是通过线程本身的消息队列来实现Intent的分发的；&lt;/p&gt;
&lt;p&gt;4.2.2 进入消息队列后的处理&lt;br /&gt;
上面有提到会通过mHandler.sendEmptyMessage(BROADCAST_INTENT_MSG)，把这个消息传递给mHandler，下面看看这个逻辑是如何实现的；&lt;br /&gt;
到这里消息就是按照时间顺序进入了mQueue了；&lt;br /&gt;
我们再看看一个activity的thread是如何进入主循环的：&lt;br /&gt;
首先是通过prepareMainLooper建立基本的数据结构，包括mQueue以及mThread,mMainLooper;&lt;br /&gt;
并把当前的这个Looper放入到线程独有的变量中；&lt;br /&gt;
其次是通过Looper.loop进入到主循环，逻辑如下：&lt;br /&gt;
首先是取出当前进入主循环的Looper，然后取出这个looper所拥有的mQueue，接下来就开始处理这个队列里面的消息了；&lt;br /&gt;
根据处理方式分两种消息，一种是消息的处理由一个线程来完成，一种是消息的处理时由一个函数来完成；&lt;br /&gt;
后者的话也分两种，一种是handler创建的时候提供了callback，这种情况非常少见；另外一种是通过handleMessage的方式来处理，通常我们在创建handler的时候都会提供这样一个函数，于是消息就可以被处理了；&lt;/p&gt;
&lt;p&gt;注意，最左边的分支我们还没有讨论，后面会遇到；&lt;/p&gt;
&lt;p&gt;我们先看看这个handleMessage对于BROADCAST_INTENT_MSG的处理：&lt;br /&gt;
这是最重要的函数，如果说broadcastIntentLocked是负责把Intent转化为BroadCast的话放入不同的队列，那么这个函数主要就是负责分发了，当然也涉及一点接收的流程；&lt;/p&gt;
&lt;p&gt;4.2.3 消息的分发过程&lt;/p&gt;
&lt;p&gt;下面分析函数private final void processNextBroadcast(boolean fromMsg)；&lt;br /&gt;
1，先判断fromMsg,如果是通过消息发送过来的就为真，否则为假，如果为真mBroadcastsScheduled = false，这样的话在函数scheduleBroadcastsLocked里面就可以再次发送BROADCAST_INTENT_MSG的消息从而触发processNextBroadcast函数被再次调用；&lt;br /&gt;
2，先判断mParallelBroadcasts是否为空，不为空就开始调用这个列表里面的receivers来接收消息，这个过程后面在串行intent的时候也会碰到，我们留到后面讨论，这里只需要知道它通过一个while循环把Intent发送给关注这个Intent的所有的receivers；&lt;br /&gt;
3，再判断mPendingBroadcast是否为空，如果不为空，就表示先前发送的串行的Intent还没有处理完毕，一般出现这种可能是因为我们要发送到的receiver还没有启动，所以需要先启动这个activity，然后等待起来的这个activity处理，这时候，这个mPendingBroadcast就为true；如果发送这种情况需要判断这个Activity是否死了，如果死了，那么就把mPendingBroadcast设为false，否则就直接返回，继续等待；&lt;br /&gt;
4，接下来就顺序的从mOrderedBroadcasts里面取出BroadCastRecord消息，然后对这个消息的receiver一个一个的调用其接收流程，注意这里要把这个BroadCast的所有的receivers串行发送，都发送完了，才会进入到下一个BroadCastRecord消息；对于这个消息的处理，先判断其接收者是不是BroadFilter，如果是，就调用deliverToRegisteredReceiver来接收，它的处理流程和前面的处理并行BroadCast一样，所以留到后面讲；&lt;br /&gt;
5，如果不是BroadCast Filter，就需要找出这个reiver所在的进程，这时候通常就是一个IntentFilter所在的进程，如果这个进程活着，那么就调用processCurBroadcastLocked(r, app)来处理，否则&lt;br /&gt;
6，需要先启动这个进程，这就是startProcessLocked做的事情，然后设置mPendingBroadcast = r，这样等应用起来它会处理这个消息，后面会有进一步的说明；&lt;/p&gt;
&lt;p&gt;到这里这个函数就结束了，比较复杂，里面还有一些安全的检查等等，上面遗留了三个问题：&lt;br /&gt;
A）deliverToRegisteredReceiver的处理流程；&lt;br /&gt;
B）processCurBroadcastLocked的处理流程；&lt;br /&gt;
C）startProcessLocked以后的进程如何处理这个唤醒它的Intent；&lt;/p&gt;
&lt;p&gt;4.2.4 deliverToRegisteredReceiver的逻辑&lt;br /&gt;
这里也分为这个receiver是否启动，如果已经启动就通过binder调用到了接收 activity的进程里面了，右边的分支performReceive也会调用到activityThread这边，留到接收过程再看；&lt;/p&gt;
&lt;p&gt;4.2.5 processCurBroadcastLocked的逻辑&lt;br /&gt;
可以看到它和deliverToRegisteredReceive的最终差别，只在于一个调用的是ScheduleRegisterdReceiver,一个是scheduleReceiver，这两个函数最后都会进入到目标activity的线程；&lt;/p&gt;
&lt;p&gt;4.2.6 startProcessLocked的逻辑&lt;br /&gt;
从这里可以看出最后通过Process.start启动了ActivityThread.java的进程，我们看看这个线程启动后的执行逻辑：&lt;br /&gt;
首先是在进入主循环之前调用attachApplication通过binder调用进入到activityManagerService.java的进程；&lt;br /&gt;
这个服务器进程在把我们先前设置的mPendingBroadcast设置为null，表示这个pending的broadcat已经得到处理了，然后调用processCurBroadcastLocked来处理这个broadcast消息，最后通过app.thread.scheduleReceiver进入到目标线程的接收流程；&lt;br /&gt;
OK,到这里的话所有的发送分发流程已经结束了，剩下的就是两个接收函数还没有讨论一个就是ScheduleRegisterdReceiver,一个是scheduleReceiver；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Intent的接收过程&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;5.1 Receiver的注册&lt;/p&gt;
&lt;p&gt;Receiver的注册一般分为动态注册和静态注册，动态注册就是通过API registerReceiver来注册，静态的一般就是写在AndroidManifest.xml,比如我们在前面已经看到的：&lt;/p&gt;
&lt;p&gt;&lt;receiver android:name=&#34;MediaButtonIntentReceiver&#34;&gt;
&lt;intent-filter&gt;
&lt;action android:name=&#34;android.intent.action.MEDIA_BUTTON&#34; /&gt;
&lt;action android:name=&#34;android.media.AUDIO_BECOMING_NOISY&#34; /&gt;
&lt;/intent-filter&gt;
&lt;/receiver&gt;&lt;/p&gt;
&lt;p&gt;至于它的原理以后在分析packageManger的时候再分析；&lt;br /&gt;
下面重点来看看这个动态注册的逻辑：&lt;/p&gt;
&lt;p&gt;这两条路径都可能被走到，如果不在ApplicationContent环境里面就需要通过context.registerReceiver来注册了，经过几层传递会通过registerReceiverInternal进入主题；&lt;/p&gt;
&lt;p&gt;这个图看起来复杂，其实很简单，就是构造receiver放入到列表中去，只是中间又经历了Binder，这些receiver也就是我们先前在发送的过程中看到的那些receiver，当然它们能进入到broadcast的列表还要看发送的intent是否满足它们给自的filter；&lt;/p&gt;
&lt;p&gt;好，现在可以看看我们在发送阶段遗留的两个函数：&lt;/p&gt;
&lt;p&gt;scheduleReceiver&lt;br /&gt;
scheduleRegisteredReceiver；&lt;/p&gt;
&lt;p&gt;5.2 scheduleReceiver&lt;/p&gt;
&lt;p&gt;它的入口通常是Binder的分发函数，如下：&lt;/p&gt;
&lt;p&gt;右下方的这个函数scheduleReceiver才会真正调用到ActivityThread.java，这个就是目标activity的母体；&lt;/p&gt;
&lt;p&gt;前面两个就是封装参数，最后放入到消息队列中，等待主循环的处理，这段逻辑我们前面已经看到了，就不再细说，总之会调用到handlemessage函数；&lt;/p&gt;
&lt;p&gt;在收到这个消息的时候通过handleReceiver来处理；&lt;/p&gt;
&lt;p&gt;这又是一个非常重要的函数，需要详细分析：&lt;/p&gt;
&lt;p&gt;1，取得这个Intent指向的component，包括包名，类名；&lt;/p&gt;
&lt;p&gt;2，取得包信息，这个结构提供了getClassLoader接口；&lt;/p&gt;
&lt;p&gt;3，通过java.lang.ClassLoader cl = packageInfo.getClassLoader取得classLoader；&lt;/p&gt;
&lt;p&gt;4，动态创建一个receiver，receiver = (BroadcastReceiver)cl.loadClass(component).newInstance()；&lt;/p&gt;
&lt;p&gt;5，调用receiver.onReceive(context.getReceiverRestrictedContext(), data.intent)，进入到真正的处理流程中去了；&lt;/p&gt;
&lt;p&gt;6，调用finishReceiver来触发ActivityManagerService这个消息到其它receivers的发送或者下一个broadcast的发送；&lt;/p&gt;
&lt;p&gt;这其中最重要的就是这个onReceive函数，我们通常都会实现这么一个函数，然后在里面处理我们收到的消息；&lt;/p&gt;
&lt;p&gt;5.3 scheduleRegisteredReceiver的逻辑&lt;/p&gt;
&lt;p&gt;入口还是Binder得分发函数，如下：&lt;/p&gt;
&lt;p&gt;这种处理在Android的代码里面随处可见，都是在native文件里面通过onTransact分发调用service文件里面的同名函数来完成真正的功能；&lt;/p&gt;
&lt;p&gt;逻辑如下：&lt;/p&gt;
&lt;p&gt;也就是说，这里把参数打包放入到args里面去，然后通过post放入到消息队列里面等待处理，后面的逻辑和一个消息的发送很相似，如下：&lt;/p&gt;
&lt;p&gt;这里需要关注两个点，&lt;/p&gt;
&lt;p&gt;一个就是m.callback=r,这个赋值会导致后面在分发消息的时候走不同的路径；&lt;/p&gt;
&lt;p&gt;Msg.target=this,表示将来分发的时候谁来处理这个消息，如果设置为null将会导致主循环退出；&lt;/p&gt;
&lt;p&gt;分发的逻辑前面我们有介绍就是dispatchMessage的时候，我们再看看这段代码：&lt;/p&gt;
&lt;p&gt;public void dispatchMessage(Message msg) {&lt;/p&gt;
&lt;p&gt;if (msg.callback != null) {&lt;/p&gt;
&lt;p&gt;handleCallback(msg);&lt;/p&gt;
&lt;p&gt;} else {&lt;/p&gt;
&lt;p&gt;if (mCallback != null) {&lt;/p&gt;
&lt;p&gt;if (mCallback.handleMessage(msg)) {&lt;/p&gt;
&lt;p&gt;return;&lt;/p&gt;
&lt;p&gt;handleMessage(msg);&lt;/p&gt;
&lt;p&gt;这里就是需要先判断msg.callback是否为null，前面我们已经看到赋值了，所以这里不为null；&lt;/p&gt;
&lt;p&gt;于是调用handleCallback,如下：&lt;/p&gt;
&lt;p&gt;private final void handleCallback(Message message) {&lt;/p&gt;
&lt;p&gt;message.callback.run();&lt;/p&gt;
&lt;p&gt;这个callback我们也看到了其实就是我们封装的Args的args，原型为：&lt;/p&gt;
&lt;p&gt;class Args implements Runnable，&lt;/p&gt;
&lt;p&gt;也就是说它是一个类似线程的对象，它的run函数代码有点多，所以画了个图：&lt;/p&gt;
&lt;p&gt;基本上这个逻辑就和我们之前看到的逻辑一致了，会调用receiver提供的onReceive函数来处理，这个onReceive函数是需要我们自己提供的，里面一般的逻辑都是根据不同的消息做不同的处理；&lt;/p&gt;
&lt;p&gt;最后就是通过finishReceiver来触发ActivityManagerService对Intent的其它receivers的发送；&lt;/p&gt;
&lt;p&gt;需要总结一下，&lt;/p&gt;
&lt;p&gt;Intent从使用的角度来说，就是构造Intent，提供适当的参数，比如Action，比如数据类型，数据的uri等，然后发送出去；接收方需要注册一个receiver，然后提供onReceive函数就可以了；这个注册可以简单的写在AndroidManifest.xml里面也可以通过registerReceiver来完成；&lt;/p&gt;
&lt;p&gt;发送的时候有三个API可以用：&lt;/p&gt;
&lt;p&gt;sendBroadcast&lt;/p&gt;
&lt;p&gt;sendStickyBroadcast&lt;/p&gt;
&lt;p&gt;sendOrderedBroadcast&lt;/p&gt;
&lt;p&gt;第一个用于发送并行广播；&lt;/p&gt;
&lt;p&gt;第二个用于发送粘性广播；&lt;/p&gt;
&lt;p&gt;第三个用于发送串行广播；&lt;/p&gt;
&lt;p&gt;从原理的角度来说，本质上都是通过共享内存把信息传递给ActivityManagerService，它查询已经注册的那些receiver的过滤器，看是否和这个Intent匹配，如果匹配成功就加入到这个Intent的receiver列表中去，当然要根据这个Intent的参数决定加入到并行，串行，还是sticky的列表中，再通过Message传递，到主循环的下一轮来分发；这时候控制已经到了另外一个进程，然后分发好以后再调用目标线程的处理函数，所以基本上就是涉及三个进程，源——&amp;gt;server——&amp;gt;receiver；当然，源和目的可以是同一个进程；&lt;/p&gt;
&lt;p&gt;另外这里需要处理一种情况，就是这个消息发送的时候，目标线程还没有创建，比如我们系统里面的校准程序，需要在第一次开机的时候执行，那么就需要捕捉一个广播消息，比如：&lt;/p&gt;
&lt;p&gt;&lt;receiver android:name=&#34;StartupIntentReceiver&#34; &gt;&lt;/p&gt;
&lt;p&gt;&lt;intent-filter&gt;&lt;/p&gt;
&lt;p&gt;&lt;action android:name=&#34;android.intent.action.BOOT_COMPLETED&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;category android:name=&#34;android.intent.category.HOME&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;/intent-filter&gt;&lt;/p&gt;
&lt;p&gt;&lt;/receiver&gt;&lt;/p&gt;
&lt;p&gt;这个消息的意思就是说启动已经完毕了；&lt;/p&gt;
&lt;p&gt;处理这个消息的类是StartupIntentReceiver,首先包含这个receiver的主activity将会被执行，然后再执行这个接收类的onReceive来接收消息并处理，所谓主activity是这样的：&lt;br /&gt;
&amp;lt;activity android:name=&amp;ldquo;.CalibrationTest&amp;rdquo;&lt;/p&gt;
&lt;p&gt;android:label=&amp;ldquo;Calibration Test&amp;rdquo;&lt;/p&gt;
&lt;p&gt;android:theme=&amp;ldquo;@android:style/Theme.Black.NoTitleBar.Fullscreen&amp;rdquo;&lt;/p&gt;
&lt;p&gt;android:configChanges=&amp;ldquo;keyboard|keyboardHidden|navigation|orientation&amp;rdquo;&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;intent-filter&gt;&lt;/p&gt;
&lt;p&gt;&lt;action android:name=&#34;android.intent.action.MAIN&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;category android:name=&#34;android.intent.category.LAUNCHER&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;/intent-filter&gt;&lt;/p&gt;
&lt;p&gt;&lt;/activity&gt;&lt;/p&gt;
&lt;p&gt;就是activity filter里面包含ACTION android.intent.action.MAIN,种类包含android.intent.category.LAUNCHER的activity；&lt;/p&gt;
&lt;p&gt;这个启动过程是由ActivityManagerService.java来完成的，我们不必关心；&lt;/p&gt;
&lt;p&gt;OK，基本上就这些了，关于Activity本身的原理，需要专门的文档来描述；&lt;br /&gt;
7. 未分析&lt;/p&gt;
&lt;p&gt;1，包管理器的信息来源；&lt;/p&gt;
&lt;p&gt;2，AndroidManifest.xml的解析；&lt;/p&gt;
&lt;p&gt;3，权限的检查；&lt;/p&gt;
&lt;p&gt;4,其它；&lt;/p&gt;
&lt;p&gt;作者：wylhistory&lt;/p&gt;
&lt;p&gt;联系方式：wylhistory@gmail.com&lt;/p&gt;
&lt;p&gt;##个人思考
当调用startIntent方法时，从这篇文章可以看出，其实是在消息队列中添加了一个消息。之后，这个消息会被分发、处理。如果是用Intent启动某个Activity，启动的过程会在调用方法的那个进程结束后才会开始。这是需要注意的，因为不是startActivity方法被调用后马上就会启动一个新的Activity。&lt;/p&gt;</description></item><item><title>HTTP Methods: GET vs. POST</title><link>https://blog.yuantops.com/tech/difference-between-http-get-and-post/</link><pubDate>Fri, 09 Jan 2015 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/difference-between-http-get-and-post/</guid><description>&lt;p&gt;##HTTP是什么？&lt;br /&gt;
超文本传输协议(The Hypertext Transfer Protocol, HTTP)是为客户端(client)与服务器(server)之间的通信(communication)设计的。&lt;/p&gt;
&lt;p&gt;HTTP是在客户端与服务器之间以请求-响应(request-response)方式工作的协议。&lt;/p&gt;
&lt;p&gt;客户端可以是一个网页浏览器，服务器可以是一台提供web服务的主机上的某个应用程序。&lt;/p&gt;
&lt;p&gt;例如：一个客户端(浏览器)向服务器提交了HTTP请求；服务器接着向客户端返回响应。响应中包含了请求的状态信息，同时可能包含所请求的资源。&lt;/p&gt;
&lt;p&gt;##最常用的两种HTTP请求方式：GET和POST
- &lt;strong&gt;GET&lt;/strong&gt;: 向某个指定的资源申请数据&lt;br /&gt;
- &lt;strong&gt;POST&lt;/strong&gt;: 向某个指定的资源提交需要处理的数据&lt;/p&gt;
&lt;p&gt;##GET方式
&lt;strong&gt;注意，GET请求的查询字符串(name/value对)是包含在URL中发送的&lt;/strong&gt;&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;/test/demo_form.asp?name1=value1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;amp;&lt;/span&gt;name2=value2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于GET还需注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET请求能被缓存&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;GET请求保存在浏览器的历史记录中&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;GET请求能被当作书签添加&lt;/li&gt;
&lt;li&gt;GET请求永远&lt;strong&gt;不应用在&lt;/strong&gt;处理敏感数据的场合&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;GET请求有长度限制&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;GET请求只应该用来获取数据&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##POST方式
&lt;strong&gt;注意，POST请求的查询字符串(name/value对)是包含在HTTP消息体中发送的&lt;/strong&gt;&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;amp;&lt;/span&gt;name2=value2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于POST还需注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;POST请求不能被缓存&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;POST请求不保存在浏览器的历史记录中&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;POST请求不能被添作标签&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;POST请求没有长度限制&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##GET与POST对比&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;GET&lt;/th&gt;
&lt;th&gt;POST&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;返回/刷新按钮&lt;/td&gt;
&lt;td&gt;无影响&lt;/td&gt;
&lt;td&gt;数据会被再次提交(浏览器应该会警示用户这一点)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;书签&lt;/td&gt;
&lt;td&gt;能被添作书签&lt;/td&gt;
&lt;td&gt;不能被添作书签&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缓存&lt;/td&gt;
&lt;td&gt;能被缓存&lt;/td&gt;
&lt;td&gt;不能缓存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;编码方式&lt;/td&gt;
&lt;td&gt;application/x-www-form-urlencoded&lt;/td&gt;
&lt;td&gt;application/x-www-form-urlencoded或者multipart/form-data。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;历史记录&lt;/td&gt;
&lt;td&gt;参数保存在浏览器记录中&lt;/td&gt;
&lt;td&gt;参数不保存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据长度限制&lt;/td&gt;
&lt;td&gt;在传输数据时，GET方式会将数据添加到URL中，而URL的最大长度是2048个字符。&lt;/td&gt;
&lt;td&gt;无限制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据类型限制&lt;/td&gt;
&lt;td&gt;只允许ASCII字符&lt;/td&gt;
&lt;td&gt;无限制。二进制数据也是合法的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;安全&lt;/td&gt;
&lt;td&gt;与POST相比，更不安全，因为GET方式数据是URL的一部分。永远不要用GET来发送密码之类的敏感信息！&lt;/td&gt;
&lt;td&gt;相对GET更安全一点，因为数据不会存储在浏览器历史记录或者服务器日志中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可见性&lt;/td&gt;
&lt;td&gt;每个人都能看见URL中的数据&lt;/td&gt;
&lt;td&gt;数据不在URL中显示&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;##原文链接
&lt;a href=&#34;http://www.w3schools.com/tags/ref_httpmethods.asp&#34;&gt;HTTP Methods: GET vs. POST&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Buffered Streams -- Oracle Java Tutorial 翻译</title><link>https://blog.yuantops.com/tech/oracle-java-tutorial-buffered-stream/</link><pubDate>Wed, 31 Dec 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/oracle-java-tutorial-buffered-stream/</guid><description>
&lt;h2 id=&#34;buffered-streams-缓冲流&#34;&gt;Buffered Streams 缓冲流&lt;/h2&gt;
&lt;p&gt;此前我们所见识的例子使用的大多*非缓冲I/O*。非缓冲，意味着每一次读/写的请求都由底层的OS直接处理。这降低了程序效率，因为每一次请求往往会触发磁盘操作、网络活动、或者其它代价昂贵的操作。&lt;/p&gt;
&lt;p&gt;为了减少这类消耗，Java平台实现了*缓冲I/O*流。输入缓冲流从一块别名为&amp;rdquo;缓存&amp;rdquo;(&lt;em&gt;buffer&lt;/em&gt;)的内存区域中读入数据;只有当缓存区变空的时候，原生的输入API才会被调用。类似地，缓冲的输出流向一块缓存中写数据，只有当缓存区满了的时候，原生的API的输出API才会被调用。&lt;/p&gt;
&lt;p&gt;程序能把一个非缓冲流转化为缓冲流。我们已经使用过几次这样的&amp;rdquo;包装类&amp;rdquo;了：非缓冲流作为参数传入缓冲流类的构造函数。下面就是一个例子，你可以在用它替代CopyCharacters代码中的构造函数以使用缓冲I/O：&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;inputStream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; BufferedReader&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FileReader&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;xanadu.txt&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;));&lt;/span&gt;
outputStream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; BufferedWriter&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FileWriter&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;characteroutput.txt&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;可以用来包裹非缓冲流的缓冲流类有4类：BufferedInputStream和BufferedOutputStream生成缓冲字节流, BufferedReader 和BufferedWriter 生成缓冲字符流。&lt;/p&gt;
&lt;h3 id=&#34;洗刷-flush-缓冲流&#34;&gt;洗刷(flush)缓冲流&lt;/h3&gt;
&lt;p&gt;在某些重要的时刻，我们等不及缓存填满就要将它的内容输出。这样的操作一般被称作*洗刷(flush)*缓存。&lt;/p&gt;
&lt;p&gt;一些缓冲输出流支持&amp;rdquo;自动洗刷(autoflush)&amp;ldquo;，只要你在它的构造函数中指定某个参数即可。当开启了自动洗刷后，某些关键事件会触发洗刷。例如，一个自动洗刷的PrintWriter对象，每当*println*或者*format*被调用时都会自动洗刷缓存。&lt;/p&gt;
&lt;p&gt;可以使用*flush*函数来手动洗刷缓存。可以对任何一个输出流使用*flush*函数，但只有在这个流被缓冲时才有效果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：flush也可以翻译成“刷新”，但我觉得这样可能造成含混，所以还是将它翻作“洗刷”来得直白。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;原文链接&#34;&gt;原文链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/io/buffers.html&#34;&gt;Buffered Streams&lt;/a&gt;&lt;/p&gt;</description></item><item><title>在GitHub pages中添加标签Tags(非插件方式)</title><link>https://blog.yuantops.com/tech/add-tags-in-gh-pages/</link><pubDate>Wed, 31 Dec 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/add-tags-in-gh-pages/</guid><description>
&lt;h3 id=&#34;参考内容&#34;&gt;参考内容&lt;/h3&gt;
&lt;p&gt;本文参考了以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.lanyonm.org/articles/2013/11/21/alphabetize-jekyll-page-tags-pure-liquid.html&#34;&gt;Alphabetizing Jekyll Page Tags In Pure Liquid (Without Plugins)&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boylee.me/development/2014/11/20/Tips-For-Sorting-Tags-In-GitHub-Page-With-Jekyll/&#34;&gt;Tips For Sorting Tags In GitHub Page With Jekyll&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.minddust.com/post/tags-and-categories-on-github-pages/&#34;&gt;HOW TO USE TAGS AND CATEGORIES ON GITHUB PAGES WITHOUT PLUGINS&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;Jekyll引擎按照post/page文件-layout模板-HTML文件的逻辑处理、生成数据，因此添加Tags功能时也应遵循对应的顺序。&lt;br /&gt;
1. 在_posts目录下新建post文件时，在yaml头中加入tags变量。如果有多个tag，那么用中括号括起来、逗号分开。&lt;br /&gt;
2. 在_layouts目录下，post文件引用的模板文件中，加入解析单个post文件的tags的逻辑，并显示。&lt;br /&gt;
3. 在博客文件夹的根目录下新建一个tags.html文件，列出博客所有文章的tags，通过Html定位符确定每个tag的位置。将这个页面的链接摆放在首页或者其它合适的地方。&lt;/p&gt;
&lt;h3 id=&#34;步骤&#34;&gt;步骤&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Step 1&lt;/strong&gt;
在_layouts目录下的post.html文件中，在你想Tags出现的地方加入下面的代码：&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt; &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;entry-tags&amp;#34;&lt;/span&gt;&amp;gt; {% for tag in page.tags %}&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;href&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{{ site.url }}/tags.html#{{ tag | cgi_ e scape }}&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;title&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Pages tagged {{ tag }}&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rel&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tag&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;post-tag&amp;#34;&lt;/span&gt;&amp;gt;{{ tag }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt;&amp;gt;{% unless forloop.last %} {% endunless %}{% endfor %}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;strong&gt;Step 2&lt;/strong&gt;
在博客的根目录下新建tags.html文件，内容如下:&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt; ---
layout: page
title: Tags
description: &amp;#34;An archive of posts sorted by tag.&amp;#34;
--- &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt; {%raw%} {% capture site_tags %}{% for tag in site.tags %}{{ tag | first }}{% unless forloop.last %},{% endunless %}{% endfor %}{% endcapture %}
&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- site_tags: {{ site_tags }} --&amp;gt;&lt;/span&gt;
{% assign tag_words = site_tags | split:&amp;#39;,&amp;#39; | sort %}
&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- tag_words: {{ tag_words }} --&amp;gt;&lt;/span&gt; {%endraw%}
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tags&amp;#34;&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;ul&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tag-box inline&amp;#34;&lt;/span&gt;&amp;gt;
{%raw%} {% for item in (0..site.tags.size) %}{% unless forloop.last %}
{% capture this_word %}{{ tag_words[item] | strip_newlines }}{% endcapture %}
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;href&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;#{{ this_word | cgi_escape }}&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tag-in-page&amp;#34;&lt;/span&gt;&amp;gt;{{ this_word }} &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;span&lt;/span&gt;&amp;gt;{{ site.tags[this_word].size }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;span&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;
{% endunless %}{% endfor %} {%endraw%}
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;ul&lt;/span&gt;&amp;gt;
{%raw%} {% for item in (0..site.tags.size) %}{% unless forloop.last %}
{% capture this_word %}{{ tag_words[item] | strip_newlines }}{% endcapture %}
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;h2&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{{ this_word | cgi_escape }}&amp;#34;&lt;/span&gt;&amp;gt;{{ this_word }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;h2&lt;/span&gt;&amp;gt; {%endraw%}
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;ul&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;posts&amp;#34;&lt;/span&gt;&amp;gt;
{%raw%} {% for post in site.tags[this_word] %}{% if post.title != null %}
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;itemscope&lt;/span&gt;&amp;gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;span&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;entry-date&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;time&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;datetime&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{{ post.date | date_to_xmlschema }}&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;itemprop&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;datePublished&amp;#34;&lt;/span&gt;&amp;gt;{{ post.date | date: &amp;#34;%B %d, %Y&amp;#34; }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;time&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;span&lt;/span&gt;&amp;gt; &amp;amp;raquo; &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;href&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{{ post.url }}&amp;#34;&lt;/span&gt;&amp;gt;{{ post.title }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;
{% endif %}{% endfor %} {%endraw%}
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;ul&lt;/span&gt;&amp;gt;
{% endunless %}{% endfor %}
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 3&lt;/strong&gt;
将tags.html的链接放到合适的地方：Header，Siderbar，Footer或者其他地方。&lt;br /&gt;
&lt;strong&gt;Step 4&lt;/strong&gt;
以后在写博客时，在post的yaml头部加入tags变量。&lt;/p&gt;
&lt;h3 id=&#34;显示效果美化&#34;&gt;显示效果美化&lt;/h3&gt;
&lt;p&gt;如果觉得Tags在post页面和tags.html的显示效果不够酷炫，可以自己在对应的css文件中加入/修改规则。&lt;/p&gt;
&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基于lanyon模板的博客：&lt;a href=&#34;https://github.com/LanyonM/lanyonm.github.io&#34;&gt;lanyonm.github.io GitHub Project&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;想定制Tags显示的排序规则，以及定制CSS效果：&lt;a href=&#34;http://boylee.me/development/2014/11/20/Tips-For-Sorting-Tags-In-GitHub-Page-With-Jekyll/&#34;&gt;Boyi Li webpage&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;本博客： &lt;a href=&#34;https://github.com/yuantops/blog&#34;&gt;Yuantops&amp;rsquo; Blog GitHub Project&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Jekyll安装指南</title><link>https://blog.yuantops.com/tech/jekyll-installation/</link><pubDate>Tue, 30 Dec 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/jekyll-installation/</guid><description>
&lt;h3 id=&#34;环境准备&#34;&gt;环境准备&lt;/h3&gt;
&lt;p&gt;准备安装Jekyll前，确保系统满足以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ruby&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;RubyGems&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Linux, Unix, 或者 Mac OS X&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Nodejs, 或者其它JavaScript运行环境&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以Ubuntu为例，安装上述软件的方法：&lt;br /&gt;
&lt;strong&gt;Ruby&lt;/strong&gt;&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ sudo apt-get install ruby, ruby-dev&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
要注意，*ruby-dev*包需要一并安装，否则在后续会报错。&lt;/p&gt;
&lt;p&gt;在Redhat/Fedora下，需要安装的软件包为ruby,ruby-devel。有可能还需要安装gcc包。&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ sudo yum install ruby, ruby-devel, gcc&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RubyGems&lt;/strong&gt;&lt;br /&gt;
RubyGems是Ruby程序包管理器，类似Redhat的RPM。更多的概念介绍，请参看&lt;a href=&#34;http://henter.me/post/ruby-rvm-gem-rake-bundle-rails.html&#34;&gt;整理Ruby相关的各种概念&lt;/a&gt;。&lt;br /&gt;
新版本的Ruby已经包含RubyGems，无需额外安装了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Nodejs&lt;/strong&gt;&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ sudo apt-get install nodejs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h3 id=&#34;设置gemfile&#34;&gt;设置Gemfile&lt;/h3&gt;
&lt;p&gt;将GitHub上你的博客Repo克隆到本地。假设Repo的根目录为blog。终端路径切换到blog目录，新建名为&lt;code&gt;Gemfile&lt;/code&gt;的文件，并填充内容:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;source &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://rubygems.org&amp;#39;&lt;/span&gt;
gem &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;github-pages&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;使用rubygems安装jekyll&#34;&gt;使用RubyGems安装Jekyll&lt;/h3&gt;
&lt;p&gt;终端路径切换到blog，运行命令：
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ sudo gem install jekyll&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h3 id=&#34;运行jekyll-查看博客效果&#34;&gt;运行Jekyll，查看博客效果&lt;/h3&gt;
&lt;p&gt;终端路径切换到blog，运行命令：
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ jekyll serve&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;</description></item><item><title>Byte Streams -- Oracle Java Tutorial 翻译</title><link>https://blog.yuantops.com/tech/oracle-java-tutorial-byte-stream/</link><pubDate>Mon, 29 Dec 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/oracle-java-tutorial-byte-stream/</guid><description>
&lt;h2 id=&#34;byte-streams-字节流&#34;&gt;Byte Streams 字节流&lt;/h2&gt;
&lt;p&gt;程序使用*字节流*来处理8bit字节的输入和输出。所有的字节流类都派生(descend)自InputStream和OutputStream。&lt;/p&gt;
&lt;p&gt;字节流类有很多。为了演示字节流的工作原理，我们将关注文件的I/O字节流,FileInputStream和FileOutputStream。其它字节流类的使用方法往往与之类似，仅在构造的方法上存在差别。&lt;/p&gt;
&lt;h3 id=&#34;使用字节流&#34;&gt;使用字节流&lt;/h3&gt;
&lt;p&gt;下面我们通过一段代码CopyBytes来演示FileInputStream和FileOutputStream的用法。这段代码通过字节流逐字节地拷贝xanadu.txt。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.io.FileInputStream&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.io.FileOutputStream&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.io.IOException&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CopyBytes&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; IOException &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
FileInputStream in &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
FileOutputStream out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
in &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FileInputStream&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;xanadu.txt&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FileOutputStream&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;outagain.txt&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; c&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;((&lt;/span&gt;c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; in&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;read&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;())&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
out&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;write&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;c&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;in &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
in&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;out &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
out&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CopyBytes在运行时形成一个循环:它不断从输入流中逐字节地读入数据，然后将字节输出到输出流。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://docs.oracle.com/javase/tutorial/figures/essential/byteStream.gif&#34; alt=&#34;图片链接&#34; title=&#34;Byte Stream&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;永远记得关闭流&#34;&gt;永远记得关闭流&lt;/h3&gt;
&lt;p&gt;关闭不再使用的流十分重要——以至于你可以看到在CopyBytes中，我们甚至使用finally区块来确保输入流和输出流即使在出现错误的情况下都能被关闭。关闭操作可以避免严重的资源泄露。&lt;/p&gt;
&lt;p&gt;可能出现的错误是CopyBytes无法打开一个或者多个文件。当这样的错误发生时，与这些文件相关的流变量不会改变它们最初的null值。这就是为什么在CopyBytes中，当我们最后调用close函数时要先确认每个流变量所持有的引用对象非空的原因。&lt;/p&gt;
&lt;h3 id=&#34;何时避免使用字节流&#34;&gt;何时避免使用字节流&lt;/h3&gt;
&lt;p&gt;CopyBytes看上去是一个很普通的程序，但它实际上是一种你应该避免使用的、低层次的I/O操作方式。因为xanadu.txt中包含了字符数据，所以最适当的方式是使用字符流(character stream)。我们将在下一部分讨论字符流。对于更复杂的数据类型，也有专门的流类来处理它们。字节流只应该用于最原始的I/O操作。&lt;/p&gt;
&lt;p&gt;那为何还要讨论字节流呢？因为所有其它的流类的&lt;strong&gt;基础&lt;/strong&gt;都是字节流。&lt;/p&gt;
&lt;h3 id=&#34;原文链接&#34;&gt;原文链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/io/bytestreams.html&#34;&gt;Byte Streams&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Character Streams -- Oracle Java Tutorial 翻译</title><link>https://blog.yuantops.com/tech/oracle-java-tutorial-character-stream/</link><pubDate>Mon, 29 Dec 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/oracle-java-tutorial-character-stream/</guid><description>
&lt;h2 id=&#34;character-streams-字符流&#34;&gt;Character Streams 字符流&lt;/h2&gt;
&lt;p&gt;Java平台使用Unicode字符集存储字符值(character value)。字符流I/O自动将内部的Unicode格式翻译成本地的字符集，反之亦然。在西方的使用环境(locale)下，本地字符集往往是8bit的ASCII码的超集(superset)。&lt;/p&gt;
&lt;p&gt;对大多数程序来说，使用字符流的I/O不会比使用字节流的I/O更复杂。与输入和输出相关的流类会自动完成与本地字符集的翻译过程。一个使用字符流而不是字节流的程序，它会自动使用本地字符集，而且它可以完成国际化的过程——不需要程序员付出过多的额外工作。&lt;/p&gt;
&lt;p&gt;如果国际化的需求优先级不高，你尽管以最简单的方式使用字符流类，而不需太关注字符集的问题。如果之后有了国际化的需求，你的程序也可以轻松地予以修改。参见&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/i18n/index.html&#34;&gt;国际化的章节&lt;/a&gt;了解更多。&lt;/p&gt;
&lt;h3 id=&#34;使用字符流&#34;&gt;使用字符流&lt;/h3&gt;
&lt;p&gt;所有的字符流类都派生自Reader和Writer。与字节流一样，有专为文件I/O而设的字符流类：FileReader和FileWriter。下面的CopyCharacters代码演示了它们的使用方法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.io.FileReader&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.io.FileWriter&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.io.IOException&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CopyCharacters&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; IOException &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
FileReader inputStream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
FileWriter outputStream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
inputStream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FileReader&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;xanadu.txt&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
outputStream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FileWriter&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;characteroutput.txt&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; c&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;((&lt;/span&gt;c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; inputStream&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;read&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;())&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
outputStream&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;write&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;c&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;inputStream &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
inputStream&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;outputStream &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
outputStream&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CopyCharacters和CopyBytes很相似。它们之间最大的不同在于CopyCharacters使用FileReader和FileWriter来完成输入和输出，CopyBytes使用FileInputStream和FileOutputStream。值得注意的是，CopyCharacters和CopyBytes都使用了一个int变量来暂存读入/写出的值。在CopyCharacters中这个int变量在它的后16bit中暂存一个字符值(character value),然而在CopyBytes中这个int变量在它的后8bit中暂存一个字节值(byte value)。&lt;/p&gt;
&lt;h3 id=&#34;使用字节流的字符流&#34;&gt;使用字节流的字符流&lt;/h3&gt;
&lt;p&gt;字符流往往是字节流的&amp;rdquo;包装&amp;rdquo;(wrapper)。字符流利用字节流完成物理I/O操作，同时字符流完成字符和字节之间的翻译。举例来说，FileReader使用FileInputStream，FileWriter使用FileOutputStream。&lt;/p&gt;
&lt;p&gt;起到字节-字符之间“桥梁”(bridge)作用的通用类有两个：InputStreamReader和OutputStreamWriter。在没有已经封装好的字符流包能满足你的操作需求时，你可以用它们创建字符流。&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/networking/sockets/readingWriting.html&#34;&gt;socket lesson&lt;/a&gt;和&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/networking/index.html&#34;&gt;network trial&lt;/a&gt;中会介绍如何从socket相关类提供的字节流中创建字符流。&lt;/p&gt;
&lt;h3 id=&#34;行导向的i-o&#34;&gt;行导向的I/O&lt;/h3&gt;
&lt;p&gt;字符I/O操作的往往不是单个字符，而是更大的单元。最常见的单元是行：以行终止符结尾的一个字符串。行终止符可以是回车(carrige-return)/新行(line-feed)的字符组合(&amp;rdquo;\r\n&amp;rdquo;)，可以是单个的回车符号(&amp;rdquo;\r&amp;rdquo;)，也可以是单个的新行符号(&amp;rdquo;\n&amp;rdquo;)。兼容所有可能存在的行终止符，这样会使程序能读取在任何流行的操作系统上创建的文本。&lt;/p&gt;
&lt;p&gt;让我们对CopyCharacters稍作修改，使其变为基于行的I/O。我们会使用之前没使用的两个类：BufferedReader和PrintWriter。我们将在&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/io/buffers.html&#34;&gt;Buffered I/O&lt;/a&gt;和&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/io/formatting.html&#34;&gt;FormaFormattingtting&lt;/a&gt;这两个章节中详细讨论这两个类。&lt;/p&gt;
&lt;p&gt;下文的CopyLines程序会调用BufferedReader.readLine和PrintWriter.println来完成每次输入/输出一行的操作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.io.FileReader&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.io.FileWriter&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.io.BufferedReader&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.io.PrintWriter&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.io.IOException&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CopyLines&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; IOException &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
BufferedReader inputStream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
PrintWriter outputStream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
inputStream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; BufferedReader&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FileReader&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;xanadu.txt&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;));&lt;/span&gt;
outputStream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; PrintWriter&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FileWriter&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;characteroutput.txt&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;));&lt;/span&gt;
String l&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;((&lt;/span&gt;l &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; inputStream&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;readLine&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;())&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
outputStream&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;l&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;inputStream &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
inputStream&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;outputStream &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
outputStream&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用readLine会返回文本中的一行。CopyLines使用println输出每一行，println函数会在每一行末尾添上当前操作系统的行终止符，再打印出来。这样的话，最后打印出来的行所使用的行终止符不一定与输入文件中的行终止符相同。&lt;/p&gt;
&lt;h3 id=&#34;原文链接&#34;&gt;原文链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/io/charstreams.html&#34;&gt;Character Streams&lt;/a&gt;&lt;/p&gt;</description></item><item><title>OSC Android源码学习笔记 四 listview初始化、获取数据、加载数据的流程</title><link>https://blog.yuantops.com/tech/osc-android-app-notes-4/</link><pubDate>Sat, 27 Dec 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/osc-android-app-notes-4/</guid><description>&lt;p&gt;OSC App显示的信息分为资讯(news)，博客(blog)，问答(Question)，动弹(tweet)几屏，每屏对应一个ListView。以资讯(news)为例，粗略看一下它的ListView是如何初始化、获取数据、加载数据的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实例化一个ListViewNewsApapter并添加到lvNews：&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;lvNewsAdapter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ListViewNewsAdapter&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; lvNewsData&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; R&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;layout&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;news_listitem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
ListViewNewsApapter这个类继承BaseAdapter，重写了getView()方法。值得注意的是，getView()方法中news实体被被作为Tag添加到了listView的ItemView中。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为lvNews设置lvNewsAdapter。lvNews和lvNewsAdapter都是Main这个类持有的变量，而不是某个函数的局部变量。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;为lvNews设置OnClickListener，这个Listener以匿名内部类方式初始化：
当点击单个item view时，从view中取出news这个Tag，然后使用UIHelper.showNewsRedirect()方法跳转到新闻阅读详情页。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实例化一个lvNewsHandler：&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;lvNewsHandler &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getLvHandler&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;lvNews&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; lvNewsAdapter&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; lvNews_foot_more&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; lvNews_foot_progress&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; AppContext&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;PAGE_SIZE&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个Handler定义了当接收到有数据更新的通知时，应该作何处理。主要是通知adapter数据发生了变化：&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;adapter&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;notifyDataSetChanged&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载数据，加载数据：&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;loadLvNewsData&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;curNewsCatalog&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; lvNewsHandler&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; UIHelper&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;LISTVIEW_ACTION_INIT&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
新开进程，调用appContext.getNewList()从服务器获取数据。数据获取完成后，通过传入的lvNewsHandler发送Message，回调handleMessage(Message msg)方法。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>开源中国安卓客户端源码学习笔记 三 自定义Exception类</title><link>https://blog.yuantops.com/tech/osc-android-app-notes-3/</link><pubDate>Thu, 25 Dec 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/osc-android-app-notes-3/</guid><description>&lt;p&gt;net.oschina.app包中包含四个类的定义文件，它们分别是AppConfig, AppException, AppManager, AppStart。其中AppStart类继承Activity，是跳转界面。AppException类是Exception的子类，是自定义的异常类。&lt;/p&gt;
&lt;p&gt;AppException类中有8个final static类型的类变量，定义异常类型: network, socket, http, xml, io, run, jason几种。这个类中有对应的静态方法，以Exception为形参，返回对应的新建对象。值得注意的是，代码中预留了debug的选项，如果在新建AppException对象时传入“debug”参数，那么对应的Exception信息会被写到文件中保存。&lt;/p&gt;
&lt;p&gt;这个类中定义了异常的处理方式：收集错误信息，然后显示异常信息&amp;amp;发送错误报告。显示异常信息和发送错误报告的过程在新建的Thread里完成。&lt;/p&gt;</description></item><item><title>使用OpenSSL工具制作证书的方法</title><link>https://blog.yuantops.com/tech/ssl-creation-guide/</link><pubDate>Wed, 24 Dec 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/ssl-creation-guide/</guid><description>
&lt;div class=&#34;message&#34;&gt;
&lt;/div&gt;
&lt;p&gt;之前&lt;a href=&#34;http://blog.yuantops.com/tech/SSL-certificate-details-and-creation-guide/&#34;&gt;一篇文章&lt;/a&gt;介绍了SSL证书的一些细节，这篇文章介绍OpenSSL工具的基本使用方法。老实说，OpenSSL工具实在是太难用了，我参考了&lt;a href=&#34;http://pages.cs.wisc.edu/~zmiller/ca-howto/&#34;&gt;How To Setup a CA&lt;/a&gt;和&lt;a href=&#34;http://rhythm-zju.blog.163.com/blog/static/310042008015115718637/&#34;&gt;基于 OpenSSL 的 CA 建立及证书签发&lt;/a&gt;这两篇文章，捣鼓了很久才理清流程。虽然原理很清楚，但是操作起来却不那么容易，这告诉我们要多实践才对，不然发现不了问题。&lt;/p&gt;
&lt;h3 id=&#34;一些坑&#34;&gt;一些坑&lt;/h3&gt;
&lt;p&gt;在使用openssl ca命令时，如果不手动指定-config参数，它会自动调用/etc/pki/tls/openssl.cnf作为-config配置文件，这个openssl.cnf文件里定义了要调用的CA证书、私钥路径。如果我们在创建CA时将它的证书和私钥等文件保存在了别处，或者/etc/pki/tls/openssl.cnf里的定义的那些文件不存在，那么在openssl ca找不到要使用的这些文件时，就会报错。其中典型的错误有：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;Using configuration from /etc/pki/tls/openssl.cnf
unable to load CA private key
&lt;span style=&#34;color:#ae81ff&#34;&gt;139911890630472&lt;/span&gt;:error:0906D06C:PEM routines:PEM_read_bio:no start line:pem_lib.c:703:Expecting: ANY PRIVATE KEY &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，我们如果想自定义CA的目录位置，那么要事先1）按照OpenSSL的默认配置建立相应的目录结构，2）定制openssl.cnf文件，修改CA目录的路径定义。&lt;/p&gt;
&lt;h3 id=&#34;建立ca-生成root证书&#34;&gt;建立CA，生成Root证书&lt;/h3&gt;
&lt;h4 id=&#34;生成ca目录结构&#34;&gt;生成CA目录结构&lt;/h4&gt;
&lt;p&gt;假设我要将/root/newCA作为CA文件根目录，那么在Terminal中敲入命令：&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@node ~&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# pwd
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;/root
&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@node ~&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# mkdir -p ./newCA/{private,newcerts}
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@node ~&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# touch ./newCA/index.txt
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@node ~&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;# echo &lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt; &amp;gt; ./newCA/serial&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h4 id=&#34;定制openssl-cnf文件&#34;&gt;定制openssl.cnf文件&lt;/h4&gt;
&lt;p&gt;将/etc/pki/tls/openssl.cnf文件复制到newCA目录下，将CA_default下面的dir的值更新为自定义的openssl.cnf文件的路径(在本文中为/root/newCA)。&lt;/p&gt;
&lt;p&gt;除此之外，出于方便后续设置的目的，还可以修改openssl.cnf文件中[req_distinguished_name]区域内后缀为default的变量，将它们预设合适的值。下面是我修改后的样子：&lt;br /&gt;
&amp;gt; [ req_distinguished_name ]
countryName = Country Name (2 letter code)
countryName_default = CN
countryName_min = 2
countryName_max = 2&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt; stateOrProvinceName = State or Province Name (full name)
stateOrProvinceName_default = Beijing
localityName = Locality Name (eg, city)
localityName_default = HaiDian
0.organizationName = Organization Name (eg, company)
0.organizationName_default = Yuantops&#39; Company Ltd
# we can do this but it is not needed normally :-)
#1.organizationName = Second Organization Name (eg, company)
#1.organizationName_default = World Wide Web Pty Ltd
organizationalUnitName = Organizational Unit Name (eg, section)
organizationalUnitName_default = Head Office
commonName = Common Name (eg, your name or your server\&#39;s hostname)
commonName_max = 64
emailAddress = Email Address
emailAddress_max = 64
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;生成ca的root-key和self-signed的证书&#34;&gt;生成CA的root key和self-signed的证书&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;生成密钥对&lt;br /&gt;
# openssl genrsa -out private/cakey.pem 2048&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;生成证书申请、用CA的密钥自签名，用一条语句完成&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@node newCA&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# openssl req -new -x509 -days 3650 -key private/cakey.pem -out cacert.pem -config openssl.cnf
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;, the field will be left blank.
-----
Country Name &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; letter code&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;CN&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;:
State or Province Name &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;full name&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;Beijing&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;:
Locality Name &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;eg, city&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;HaiDian&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;:
Organization Name &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;eg, company&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;Yuantops Company Ltd&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;:
Organizational Unit Name &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;eg, section&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;Head Office&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;:
Common Name &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;eg, your name or your server&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt;s hostname&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt;:test.yuantops.com
Email Address &lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt;:&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;查看我们生成的root-ca.crt的内容&lt;br /&gt;
# openssl x509 -noout -text -in root-ca.crt&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;使用ca-root证书签署证书&#34;&gt;使用CA Root证书签署证书&lt;/h4&gt;
&lt;p&gt;在上一步完成之后，就可以用CA的root 证书来签署证书了。&lt;/p&gt;
&lt;p&gt;可以使用一条OpenSSL命令完成生成密钥对，生成证书签名请求的操作：&lt;br /&gt;
# openssl req -newkey rsa:1024 -keyout zmiller.key -config openssl.cnf -out zmiller.req&lt;/p&gt;
&lt;p&gt;然后用CA的Root证书签发证书&lt;br /&gt;
# openssl ca -config openssl.cnf -out zmiller.crt -infiles zmiller.req&lt;/p&gt;</description></item><item><title>BIND安装笔记</title><link>https://blog.yuantops.com/tech/bind-installation-guide/</link><pubDate>Tue, 23 Dec 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/bind-installation-guide/</guid><description>
&lt;h3 id=&#34;安装环境&#34;&gt;安装环境&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网络环境：两台KVM虚拟机，通过NAT方式组成子网(IP地址分别为192.168.100.139, 192.168.100.172)，彼此能ping通，均能访问互联网&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;系统：Redhat 6.6&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;要解析的域名：yuantops.com&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;安装bind软件包&#34;&gt;安装BIND软件包&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;$ yum install bind bind-utils&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;为要解析的域名生成dnssec-key&#34;&gt;为要解析的域名生成DNSSEC KEY&lt;/h3&gt;
&lt;p&gt;这一步不是配置基本DNS解析器时必须包括的步骤，因此可以省略。&lt;/p&gt;
&lt;p&gt;DNSSEC是为了解决DNS欺骗和缓存污染而设计的一种安全机制。由于DNS域名解析系统在设计之初没有考虑到安全问题，经常有针对DNS系统的攻击发生，而且由于DNS协议十分脆弱，攻击一旦发生就会造成大面积的影响甚至瘫痪。DNSSEC的原理是通过引入加密技术，依靠数字签名保证DNS应答报文的真实性和完整性。具体的介绍请见&lt;a href=&#34;http://netsec.ccert.edu.cn/duanhx/archives/1479&#34;&gt;DNSSEC的原理、配置与部署简介&lt;/a&gt;一文。&lt;/p&gt;
&lt;p&gt;假设我要解析的域名为yuantops.com，准备将这个域名对应的DNSSEC KEY文件保存在/var/named/路径下。&lt;br /&gt;
&amp;gt; $ cd /var/named&lt;br /&gt;
&amp;gt; $ dnssec-keygen -a HMAC-SHA256 -b 256 -n USER -r /dev/urandom yuantops.com&lt;/p&gt;
&lt;p&gt;在/var/named/路径下生成了文件名形如Kyuantops.com.+163+15844.key和Kyuantops.com.+163+15844.private的一对key文件。&lt;/p&gt;
&lt;h3 id=&#34;启用rndc工具作为bind的控制工具&#34;&gt;启用rndc工具作为BIND的控制工具&lt;/h3&gt;
&lt;p&gt;这一步同样不是配置一个最基本的DNS解析服务器所必须包含的步骤，因此可以省略。&lt;/p&gt;
&lt;p&gt;rndc是BIND安装包提供的一种域名服务控制工具，它可以运行在其他计算机上，通过网络与DNS服务器进行连接，然后根据管理员的指令对named服务进行远程控制，此时，管理员不需要DNS服务器的根用户权限。更重要一点，rndc能实现数据的&lt;strong&gt;热更新&lt;/strong&gt;，这对繁忙的实际场景而言是十分有必要的。具体的介绍可以请见&lt;a href=&#34;http://book.51cto.com/art/200912/169294.htm&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;使用rndc-confgen命令生成rndc的配置文件。&lt;br /&gt;
&amp;gt; $ rndc-confgen -a -r /dev/urandom&lt;/p&gt;
&lt;p&gt;在/etc路径下生成了rndc.key文件。&lt;/p&gt;
&lt;h3 id=&#34;配置bind对域名的解析&#34;&gt;配置BIND对域名的解析&lt;/h3&gt;
&lt;p&gt;这一步是必须完成的、最重要的步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;新建yuantops.com域的zone文件，保存到/var/named/dynamic目录。&lt;br /&gt;
域的zone文件有自己的语法规范，配置起来需要事先对DNS的术语有一定了解。可以参看&lt;a href=&#34;http://www.zytrax.com/books/dns/ch8/soa.html&#34;&gt;文章一&lt;/a&gt;和 &lt;a href=&#34;http://www.zytrax.com/books/dns/ch6/mydomain.html&#34;&gt;文章二&lt;/a&gt;。&lt;br /&gt;
下面是域yuantops.com的zone文件yuantops.com.db的内容:&lt;br /&gt;
&amp;gt;$TTL 86400 ; 24 hours could have been written as 24h or 1d&lt;br /&gt;
; $TTL used for all RRs without explicit TTL value&lt;br /&gt;
$ORIGIN yuantops.com.&lt;br /&gt;
@ 1D IN SOA ns1.yuantops.com. hostmaster.yuantops.com. (&lt;br /&gt;
2002022401 ; serial&lt;br /&gt;
3H ; refresh&lt;br /&gt;
15 ; retry&lt;br /&gt;
1w ; expire&lt;br /&gt;
3h ; minimum )&lt;br /&gt;
IN NS ns1.yuantops.com. ; in the domain&lt;br /&gt;
IN MX 10 mail.yuantops.com. ;&lt;br /&gt;
; server host definitions&lt;br /&gt;
ns1 IN A 192.168.100.172;name server definition&lt;br /&gt;
www IN A 192.168.100.172;web server definition&lt;br /&gt;
ftp IN CNAME www.yuantops.com. ;ftp server definition&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将yuantops.com域的DNSSEC Key添加到/var/named/目录。&lt;br /&gt;
在生成DNSSEC Key的第一步中，我们得到了一对key文件。如果因为不准备部署DNSSEC key而跳过了第一步，那么现在这一步也应该跳过。&lt;br /&gt;
打开/var/named/Kyuantops.com.+163+15844.private文件，复制其中的Key字段到剪贴板。&lt;br /&gt;
新建/var/named/yuantops.com.key文件，将以下内容填入文件:&lt;br /&gt;
&amp;gt;key yuantops.com {&lt;br /&gt;
algorithm HMAC-SHA256;&lt;br /&gt;
secret &amp;ldquo;2viM+VhhgiFGMrOjLAqBtY9usGstiRuZdOElI5U6l/o=&amp;rdquo;;&lt;br /&gt;
};&lt;/p&gt;
&lt;p&gt;替代secret字段为剪贴板中的内容。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置BIND的配置文件/etc/named.conf，添加yuantops.com域的定义、DNSSEC Key定义。&lt;br /&gt;
named.conf文件是BIND服务器的全局配置文件，非常重要。我们要在里面加入对yuantops.com域的定义、yuantops.com域的DNSSEC Key的定义。&lt;br /&gt;
将以下内容填入/etc/named.conf文件:&lt;br /&gt;
&amp;gt;options {&lt;br /&gt;
listen-on port 53 { any; };//注意，此处为any，不是127.0.0.1&lt;br /&gt;
listen-on-v6 port 53 { ::1; };&lt;br /&gt;
directory &amp;ldquo;/var/named&amp;rdquo;;&lt;br /&gt;
dump-file &amp;ldquo;/var/named/data/cache_dump.db&amp;rdquo;;&lt;br /&gt;
statistics-file &amp;ldquo;/var/named/data/named_stats.txt&amp;rdquo;;&lt;br /&gt;
memstatistics-file &amp;ldquo;/var/named/data/named_mem_stats.txt&amp;rdquo;;&lt;br /&gt;
allow-query { any; }; //注意，此处是any，不是localhost&lt;br /&gt;
recursion yes;&lt;br /&gt;
dnssec-enable yes;&lt;br /&gt;
dnssec-validation yes;&lt;br /&gt;
dnssec-lookaside auto;&lt;br /&gt;
/* Path to ISC DLV key */&lt;br /&gt;
bindkeys-file &amp;ldquo;/etc/named.iscdlv.key&amp;rdquo;;&lt;br /&gt;
managed-keys-directory &amp;ldquo;/var/named/dynamic&amp;rdquo;;&lt;br /&gt;
};&lt;br /&gt;
logging {&lt;br /&gt;
channel default_debug {&lt;br /&gt;
file &amp;ldquo;data/named.run&amp;rdquo;;&lt;br /&gt;
severity dynamic;&lt;br /&gt;
};&lt;br /&gt;
};&lt;br /&gt;
// use the default rndc key&lt;br /&gt;
include &amp;ldquo;/etc/rndc.key&amp;rdquo;;&lt;br /&gt;
controls {&lt;br /&gt;
inet 127.0.0.1 port 953&lt;br /&gt;
allow { 127.0.0.1; } keys { &amp;ldquo;rndc-key&amp;rdquo;; };&lt;br /&gt;
};&lt;br /&gt;
zone &amp;ldquo;.&amp;rdquo; IN {&lt;br /&gt;
type hint;&lt;br /&gt;
file &amp;ldquo;named.ca&amp;rdquo;;&lt;br /&gt;
}//;&lt;br /&gt;
&amp;gt; include &amp;ldquo;/etc/named.rfc1912.zones&amp;rdquo;;&lt;br /&gt;
&amp;gt; include &amp;ldquo;/etc/named.root.key&amp;rdquo;;&lt;br /&gt;
include &amp;ldquo;yuantops.com.key&amp;rdquo;;&lt;br /&gt;
zone &amp;ldquo;yuantops.com&amp;rdquo; IN {&lt;br /&gt;
type master;&lt;br /&gt;
file &amp;ldquo;dynamic/yuantops.com.db&amp;rdquo;;&lt;br /&gt;
allow-update { key yuantops.com ; } ;&lt;br /&gt;
};&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;修改配置文件的权限-使能被读取&#34;&gt;修改配置文件的权限，使能被读取&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;$ chmod 644 /etc/named.conf&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;启动bind服务器&#34;&gt;启动BIND服务器&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;$ service named start&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果以后BIND服务器设置有改动，需要重启named服务。&lt;/p&gt;
&lt;h3 id=&#34;将机器的dns服务器ip地址设为bind程序所在机器的ip地址&#34;&gt;将机器的DNS服务器IP地址设为BIND程序所在机器的IP地址&lt;/h3&gt;
&lt;p&gt;BIND服务器所在机器的IP地址为192.168.100.172。如果有一台192.168.100.139的机器想以192.168.100.172为DNS服务器，那么修改它的/etc/resolv.conf文件，将第一次出现的nameserver 地址改为192.168.100.172。&lt;/p&gt;
&lt;h3 id=&#34;验证bind服务已经成功安装并启动&#34;&gt;验证BIND服务已经成功安装并启动&lt;/h3&gt;
&lt;p&gt;在192.168.100.139机器上运行命令：&lt;br /&gt;
&amp;gt;$ dig @192.168.100.172 www.yuantops.com&lt;/p&gt;
&lt;p&gt;如果成功解析出IP地址，证明成功。否则，可以检查BIND服务器的/var/log/message日志文件，寻找原因。&lt;/p&gt;
&lt;h3 id=&#34;使用nsupdate命令操作bind服务器的配置&#34;&gt;使用nsupdate命令操作BIND服务器的配置&lt;/h3&gt;</description></item><item><title>开源中国安卓客户端源码学习笔记 二 欢迎界面跳转与渐变效果</title><link>https://blog.yuantops.com/tech/osc-android-app-notes-2/</link><pubDate>Tue, 23 Dec 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/osc-android-app-notes-2/</guid><description>&lt;p&gt;OSC客户端启动时会先显示欢迎界面，再跳转到主页，其中跳转过程有渐变效果。&lt;/p&gt;
&lt;p&gt;这里使用了AlphaAnimation类。AlphaAnimation类能实现渐进渐出的效果，官方文档里说“This animation ends up changing the alpha property of a Transformation”。alpha property可以理解为透明度，&amp;rdquo;0.0&amp;rdquo;为全透明，“0.5”为半透明，“1.0”时不透明。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//渐变展示启动屏
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; AlphaAnimation aa &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; AlphaAnimation&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;3f&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;0f&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
aa&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setDuration&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;3000&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
view&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;startAnimation&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;aa&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
aa&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setAnimationListener&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; AnimationListener&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onAnimationEnd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Animation arg0&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
redirectTo&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onAnimationRepeat&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Animation animation&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{}&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onAnimationStart&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Animation animation&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，欢迎界面的图片可以更新。从代码分析，在将View设置为ContentView之前，程序会检查欢迎界面对应缓存文件夹里的图片文件，图片文件的文件名有一个时间期限，如果今天正好落在这个期限内，那么就将它设为背景图片。如此可以推测APP会在启动后自动下载新的图片文件(如果存在的话)到缓存文件夹，从而达到更新效果。&lt;/p&gt;
&lt;p&gt;果然，在跳转到Main Activity后，在onCreate()方法里调用了checkBackGround()方法。这个方法会新开一个Thread去服务器检查是否有新的图片需要下载，如果有，那么会下载下来。&lt;/p&gt;</description></item><item><title>开源中国安卓客户端源码学习笔记 一</title><link>https://blog.yuantops.com/tech/osc-android-app-notes-1/</link><pubDate>Mon, 22 Dec 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/osc-android-app-notes-1/</guid><description>&lt;p&gt;##前言
开源中国(OSCHINA)是国内一个开源社区,社区自己开发了Android和iOS平台的客户端，而且将各自的代码开源了。值得夸奖的是，他们的Android APP不是基于HTML，而是Android原生API。我最近在学习它Android App的&lt;a href=&#34;http://git.oschina.net/oschina/android-app&#34;&gt;源代码&lt;/a&gt;，毕竟像它这样性能优秀、注释齐全的开源项目是比较稀少的。&lt;/p&gt;
&lt;p&gt;希望能通过阅读源代码，学到一些Android开发的实战技巧，并加深对已有知识的理解。&lt;/p&gt;
&lt;p&gt;##学习笔记一 利用getApplication()共享全局数据&lt;br /&gt;
程序启动Activity是net.oschina.app.AppStart。这个Activity类持有一个自定义的AppContext成员。查看net.oschina.app.AppContext类的定义，作者说它是“全局应用程序类，用于保存和调用全局应用配置及访问网络数据”。&lt;/p&gt;
&lt;p&gt;AppContext类是Application类的子类。Google了getApplication()函数，找到了一篇介绍得比较明白的文章：&lt;br /&gt;
- &lt;a href=&#34;http://www.cnblogs.com/liu666bin/archive/2013/01/05/2846081.html&#34;&gt;android利用getApplication()共享全局数据&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在平时开发中，如果需要一些能被所有Activity和View访问到的全局数据，就可以自定义一个继承Application类的子类，扩展它所持有的成员。&lt;strong&gt;值得注意&lt;/strong&gt;，还需在android Manifest.xml文件中将application的android:name属性指定为自定义的类。&lt;/p&gt;
&lt;p&gt;另外,关于getApplication()和getApplicationContext()的区别,&lt;a href=&#34;http://stackoverflow.com/questions/5018545/getapplication-vs-getapplicationcontext&#34;&gt;stackoverflow&lt;/a&gt;上有人这么解释:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;虽然当前Anroid Activity和Service的实现方式使得getApplication()和getApplicationContext()返回相同的object，但不能保证它们将来会一直这样。
如果你想在Manifest.xml文件中注册Application class，那么**永远不要**调用getApplicationContext()并将其cast为你的application类，因为它返回的很可能不是你的application实例。
getApplication()仅仅在Activity和Service类中可以被调用，而getApplicationContext()则是在Context类中被声明的。这意味着，譬如说你写了一个Broadcast Receiver，Broadcast Receiver本身不是一个Context类，尽管它能通过onReceive()方式获得一个Context类的引用，这时你就只能调用getApplicationContext()了——这也就意味着，不能确保在BroadcastReceiver中访问到application。
另外，Android的官方文档中提到，你**不应该**需要去继承Application类:
There is normally no need to subclass Application. In most situation, static singletons can provide the same functionality in a more modular way. If your singleton needs a global context (for example to register broadcast receivers), the function to retrieve it can be given a Context which internally uses Context.getApplicationContext() when first constructing the singleton.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然官方推荐用静态singleton的方式去设置全局数据，但是在回复中有人提到，在实际中还是继承Application的方式来得更方便。所以，到底用那种方式更好，就见仁见智吧。&lt;/p&gt;</description></item><item><title>制作属于自己的字母favicon</title><link>https://blog.yuantops.com/tech/make-custom-character-favicon/</link><pubDate>Sat, 20 Dec 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/make-custom-character-favicon/</guid><description>&lt;p&gt;每个自己搭建博客的人，应该都想自己的博客更具个性。favicon是浏览器浏览网页时标签左边的那个小图标，是可以自己设计的。&lt;/p&gt;
&lt;p&gt;这里，推荐一个网站：&lt;a href=&#34;http://faviconist.com/&#34;&gt;faviconist.com&lt;/a&gt;。你可以输入一个字母，得到这个字母的图标，而且字体、文字前景色、背景色都可以调整。调整到满意后，下载到本地，保存到对应的网页文件夹，就可以了。&lt;/p&gt;
&lt;p&gt;效果可以参见我的网页。&lt;/p&gt;</description></item><item><title>Java 的一些术语解释</title><link>https://blog.yuantops.com/tech/java-terminology-explanation/</link><pubDate>Sun, 14 Dec 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/java-terminology-explanation/</guid><description>
&lt;p&gt;作为JAVA初学者，往往弄不清楚一系列术语的概念。这篇文章搬运&lt;a href=&#34;http://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre&#34;&gt;文章一&lt;/a&gt;与&lt;a href=&#34;http://stackoverflow.com/questions/10858193/java-jdk-sdk-se&#34;&gt;文章二&lt;/a&gt;，解释JRE与JDK, JavaSE、JavaME与JavaEE，Java版本等术语 。&lt;/p&gt;
&lt;h3 id=&#34;jre-vs-jdk&#34;&gt;JRE vs JDK&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;JRE&lt;/strong&gt;: Java Runtime Environment&lt;br /&gt;
基本说来它是Java Virtual Machine，你的Java程序在它上面运行。它也为浏览器提供Applet运行插件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK&lt;/strong&gt;: Java Development Kit&lt;br /&gt;
Java软件开发包，它不仅&lt;strong&gt;包括&lt;/strong&gt; JRE,还包括编译器等其它工具(JavaDoc, Java Debugger等)。它用来创建、编译程序。&lt;/p&gt;
&lt;p&gt;一般说来，如果你仅仅想让Java程序在自己的电脑和浏览器上跑起来，那么只需安装JRE。如果你想用Java编程，那么需要安装JDK。&lt;/p&gt;
&lt;h3 id=&#34;javase-javame和javaee&#34;&gt;JavaSE，JavaME和JavaEE&lt;/h3&gt;
&lt;p&gt;因为围绕Java形成的生态圈十分庞大，所以Sun公司提供了Java的不同发行版。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JavaSE&lt;/strong&gt;: Java Standard Edition&lt;br /&gt;
适合于客户端软件、常规程序等。我们平时所使用的、所下载的Java版本一般都是它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JavaME&lt;/strong&gt;: Java Mobile Edition&lt;br /&gt;
通常是老式手机游戏所产生的平台，它对Java进行了精简，使其更适合低性能的处理器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JavaEE&lt;/strong&gt;: Java Enterprise Edition&lt;br /&gt;
通常用来研发服务器端的产品，因此往往它包含很多服务器需要用到的包。&lt;/p&gt;
&lt;h3 id=&#34;java的版本号&#34;&gt;Java的版本号&lt;/h3&gt;
&lt;p&gt;我们在下载安装Java JRE或者JDK后，使用&amp;rdquo;java -version&amp;rdquo;命令查看当前的Java版本，会发现类似下面的信息：&lt;br /&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;java version &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1.7.0_71&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
Java 1.7是我机器上的java版本号，它也被称为Java 7：它们是一个东西，两个名称。再累赘一点地说，它也是JavaSE 7。&lt;/p&gt;
&lt;h3 id=&#34;扩展阅读&#34;&gt;扩展阅读&lt;/h3&gt;
&lt;p&gt;更详细、更权威的资料，可以阅读Oracle的&lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/tech/index.html&#34;&gt;Java SE Technologies文档&lt;/a&gt;。&lt;/p&gt;</description></item><item><title>SSL术语与基本原理</title><link>https://blog.yuantops.com/tech/ssl-terminologies-and-concepts/</link><pubDate>Sat, 06 Dec 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/ssl-terminologies-and-concepts/</guid><description>
&lt;p&gt;非对称加密的又一大应用是SSL。对于SSL的介绍，阮一峰有一篇深入浅出的博客，推荐阅读：&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html&#34;&gt;数字签名是什么？&lt;/a&gt;。这篇文章也非常不错：&lt;a href=&#34;http://httpd.apache.org/docs/current/ssl/ssl_intro.html&#34;&gt;SSL/TLS Strong Ebcryption: An introduction&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;SSL协议对互联网的安全十分重要。要理解SSL协议，必须先理解几个基本概念：&lt;strong&gt;信息摘要(message digest)&lt;/strong&gt;，&lt;strong&gt;数字签名(digital signature)&lt;/strong&gt;，&lt;strong&gt;数字证书(digital certificate)&lt;/strong&gt;。阮一峰的博客里写得十分清楚了，看完后做一点自己的笔记。&lt;/p&gt;
&lt;h3 id=&#34;ssl术语&#34;&gt;SSL术语&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;公钥(public key): 非对称加密密钥对中可以分发给其它人的一方。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;私钥(private key): 非对称加密密钥对中自己保存的一方。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;信息摘要(message digest): 对一段很长的数据消息，计算它的Hash函数值，得到的一串*较短*且*定长*的短数值。Hash函数可以是MD5或者SHA 1。Hash函数过程是单向不可逆的，不可能通过message digest 反推出原数据信息。同时，message digest也是独一无二的。可以理解为某一段数据内容独一无二的特征值。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数字签名(digital signature): 使用用户私钥对信息摘要(message digest)进行加密，生成的信息。数字签名只能用用户的公钥解开。反过来，如果用户Alice的公钥成功解密了数字签名，那么一定能确定这个签名的签发者是用户Alice(因为只可能是Alice的私钥签发了它)。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数字证书(digital certificate): 由某个被信任的机构(如Certificate Authority，CA)签发、认证用户身份的数字文件。(数字证书的内容复杂，将在另外一篇博客中专门介绍)。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ssl基本原理&#34;&gt;SSL基本原理&lt;/h3&gt;
&lt;p&gt;这里介绍的是SSL的设计思想和大致原理，不是实现细节。转述自从阮一峰的博客。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设用户Alice有属于自己的公钥/私钥对。她准备和好朋友Bob，Susan等通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Alice把自己的公钥送给朋友们：Bob，Susan每人一把。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Bob如果要给Alice写一封保密的信，那么他写完后用Alice的公钥加密，就可以达到保密的效果。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Alice收到信后，用自己私钥解密，就看到了信件内容。这里要强调的是，只要Alice的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;试思考：如果Alice事先没有把自己公钥送给自己的朋友们，她自己手中也没有朋友们的公钥，那他们之间通信如何保证不被篡改？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;假设Alice要给Bob写信。她写好信(message)后，先使用Hash函数生成信息摘要(message digest)。然后，她使用私钥，对这个摘要加密，生成数字签名(digital signature)。最后，她把自己的信件内容、数字签名，还有自己的公钥一起发送给Bob。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Bob收到了信件。他取出Alice的公钥、数字签名，用公钥解密数字签名，得到信息摘要;他再读出信件内容，用Hash函数自己计算内容的信息摘要。如果取出来的摘要和算出来的摘要吻合，那么这封信就未被修改过。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可是，万一黑客John截获了Alice发给Bob的信件，然后自己编造了一些内容，生成摘要、用自己密钥加密生成数字签名，再连同自己的公钥一起发给Bob，他就可以冒充Alice了。Bob如何确定取出的公钥就是Alice的，而不是别人(例如，黑客John)的？&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Bob无法确定公钥是不是属于Alice，于是想到一个办法：他建议Alice去找权威机构(例如，certificate authority，简称CA)给她的公钥做认证，做个证书(certificate)。Alice领取了一份申请表格，填入自己的姓名、住址、联系方式、和自己的公钥，跑到CA去提交。CA接受申请，确认是Alice本人无误，就用自己的私钥处理Alice的表格内容，生成数字签名并附在申请表格后面，这就成了“数字证书”(digital ceritificate)。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;以后Alice给Bob写信，就会发送信件内容+数字签名+数字证书三部分。Bob收到来信，先检查数字证书的真伪。如果为真，那么从数字证书中取出Alice的公钥。这时可以确认得到的是Alice的真实公钥。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数字证书的现实应用-https中的ssl协议&#34;&gt;数字证书的现实应用：https中的SSL协议&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;首先，客户端向服务器发出加密请求。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;服务器用自己的私钥加密网页，连同本身的数字证书，一起发送给客户端。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;客户端打开自己的“证书管理器”，看证书是否由“受信任的根证书颁发机构”颁发。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果证书合法，而且确实颁发给你所浏览的网址的，那么客户端就可以取出真实的公钥。否则客户端会提出警告。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;思考-ssl协议的实现流程-与ssl-certificate的实现细节&#34;&gt;思考：SSL协议的实现流程，与SSL certificate的实现细节&lt;/h3&gt;
&lt;p&gt;这篇文章为了解释SSL协议的原理，引入并介绍了“摘要”“数字签名”“数字证书”等概念。这篇文章主要介绍原理，而且用了比喻，可能在细节上有出入，这是需要注意的。在实际的互联网环境中，SSL协议的实现更为复杂精细。&lt;/p&gt;
&lt;p&gt;但就谈到的点而言，可能还存在这样的疑问：&lt;br /&gt;
&amp;gt; 客户端(浏览器)如何确认一份数字证书的真伪？&lt;/p&gt;
&lt;p&gt;这个问题值得思考。为了确认公钥是真实的，我们引入了“数字证书”为它担保——问题只不过换了一种问法，但信任锚点还是没能确认。在下一篇文章中，会讨论数字证书的细节，并介绍如何确认一份“数字证书”的真伪。&lt;/p&gt;</description></item><item><title>SSL证书的细节与制作方法</title><link>https://blog.yuantops.com/tech/ssl-certificate-details-and-creation-guide/</link><pubDate>Sat, 06 Dec 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/ssl-certificate-details-and-creation-guide/</guid><description>
&lt;p&gt;在上篇文章中，讨论了数字证书(digital certificate)的重要意义。在实际中，Internt工程任务组(IETF)PKI X.509专门负责制定数字证书的格式，并提出了一套标准。根据这套标准(X.509)，互联网上的各级单位各自予以实现，从而形成一套完备的公钥基础设施(Public Key Infrastructure, PKI)。这是本篇文章将要讨论的内容。&lt;/p&gt;
&lt;h3 id=&#34;ssl证书的x-509标准&#34;&gt;SSL证书的X.509标准&lt;/h3&gt;
&lt;p&gt;X.509 规定一份digital certificate应该由这几部分构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Certificate Data&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;Version (marked as X.509 v3, even if v4 or v5)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Serial number&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Signature algorithm ID&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Issuer name(DN, Distinguished Name)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Validity (start and end time)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Subject name(DN)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Subject Public key&lt;/li&gt;
&lt;li&gt;Extensions (added in X.509 v3): Extra identification information, usage constraints, policies, and general kitchen-sink area&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Certificate Signature Algorithm&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Certificate Signature&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注:
- 一般Subject Name, 或者Issuer name + Serial number唯一确定一份证书;&lt;br /&gt;
- Certificate Data中的Signature algorithm ID必须和Certificate Signature Algorithm中的内容一致，标志CA用来生成Certificate Signature所用的加密算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Certificate Data的Subject name与Issuer name这两项中，其Distinguished Name包含更多字段(这些字段往往用字母简写)，以更好地作唯一标识：&lt;br /&gt;
- CN: Common Name, 证书持有者的名称&lt;br /&gt;
- O: Organization or Company, 持有者所在的公司/组织&lt;br /&gt;
- OU: Organization Unit, 持有者在公司/组织的部门&lt;br /&gt;
- L: City/Locality, 持有者所在的城市&lt;br /&gt;
- ST: State/Province, 持有者所在的州/省&lt;br /&gt;
- C: Country, 持有者所在的国家(ISO码)&lt;/p&gt;
&lt;h3 id=&#34;ssl-x-509证书的后缀名&#34;&gt;SSL X.509证书的后缀名&lt;/h3&gt;
&lt;p&gt;一份X.509 Certificate往往会以DER(Distinguished Encoding Rules)方式翻译成二进制格式的文件。如果有些传输过程不能处理二进制数据，那么二进制格式的文件会以Base64 编码转翻为ASCII文件。用Base64 编码后的数据被置于“&amp;mdash;&amp;ndash;BEGIN CERTIFICATE&amp;mdash;&amp;ndash;”和“&amp;mdash;&amp;ndash;END CERTIFICATE&amp;mdash;&amp;ndash;”之间，这就是PEM(Privacy-enhanced Electronic Mail)格式。&lt;/p&gt;
&lt;p&gt;不同格式的证书常见的后缀名有:&lt;br /&gt;
- cer, .crt, .der : 二进制DER格式&lt;br /&gt;
- pem: Base64 编码后的DER格式&lt;/p&gt;
&lt;h3 id=&#34;x-509的-证书链-与-信任锚点&#34;&gt;X.509的“证书链”与“信任锚点”&lt;/h3&gt;
&lt;p&gt;数字证书存在的意义，在于认证持有者的身份。譬如说，在Alice申请证书的时候，证书颁发机构(CA, Certificate Authority)会先确认Alice本人的信息与她申请书上所写的一致。&lt;/p&gt;
&lt;p&gt;由于证书上有第三方认证中心的真实性确认签名、由第三方认证中心的信用为这张证书的真实性背书，所以，只要确定了证书为真，就能确认证书持有者的身份为真。但这样问题还是没得到解决，而是变成了另一个问题：如何确定一张证书的真伪？&lt;/p&gt;
&lt;p&gt;为了回答这个问题，需要先了解实际部署在互联网上的证书颁发机构(CA, Certificate Authority)的架构。互联网中，一个证书颁发机构(CA, Certificate Authority)有自己的证书。一个证书颁发机构(CA, Certificate Authority)不仅可以给证书申请者颁发证书，也可以给其它证书颁发机构(CA, Certificate Authority)颁发证书。那么谁来给最顶层的证书颁发机构(top-level Certificate Authority)授权呢？答案是：它自己给自己签名，自己给自己授权(它拥有的证书，Issuer和Subject是一样的)。&lt;/p&gt;
&lt;p&gt;这样就形成了一个“证书链”(Certificate chain),也称“证书路径”(Certificate path)：最开始为用户持有的证书，最末尾为自己给自己签名的证书。证书链中:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个证书(最末尾的证书除外)的颁发者(Issuer)是下一个证书的持有者(Subject);&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;每个证书的(最末尾的证书除外)的Certificate Signature都能用下一个证书中包含的Public Key解密;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;最末尾的证书是“信任锚点”(a trust anchor)——往往它会以某种值得信赖的方式，提前传递到你手中。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，确认一张证书真实性的过程，就是一个不断追溯，直到“信任锚点”的过程。&lt;/p&gt;
&lt;p&gt;在主流的浏览器(IE, Chrome, Firefox等)中，预置了主流证书颁发机构(VeriSign等)的根证书。当浏览器收到网站的SSL证书后，会有一系列验证过程，如果该证书的“证书链”中任意一环存储在本地，那么就能确认该证书为真实。浏览器对证书链的认证过程，将在另一篇文章中介绍。&lt;/p&gt;
&lt;h3 id=&#34;生成根证书与签发证书&#34;&gt;生成根证书与签发证书&lt;/h3&gt;
&lt;p&gt;上面讲了那么多，都是理论。现在转入实战，介绍如何生成一张证书, 以及这张证书的持有者如何为申请者签发证书。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux下最常使用的SSL根证书相关的命令是openssl的一套工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般情况下，用户制作证书要经过几个步骤：&lt;br /&gt;
1. 首先用openssl genrsa生成一个私钥&lt;br /&gt;
2. 然后用openssl req生产一个证书签发请求&lt;br /&gt;
3. 最后把证书签发请求交给CA，CA签发后就得到该CA认证的证书。&lt;/p&gt;
&lt;p&gt;如果生成证书签发请求时加上-X509参数，那么就直接生成一个self-signed的证书，即自己充当CA认证自己。&lt;/p&gt;
&lt;p&gt;一张self-signed的证书，不能证明持有者的身份。大部分软件在遇到这种证书时都会发出警告。使用自签发证书的主要意义也不是证明身份，而是使用户与系统间能SSL通信，保证信息传输时的安全。&lt;/p&gt;
&lt;p&gt;使用openssl工具制作证书时，会接触到新名词:&lt;br /&gt;
- CSR(Certificate Signing Request): 提交给CA的认证申请文件，包含了申请者的公钥和名字等信息，通常以.csr为后缀，是中间文件。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;制作自签名证书(根证书)步骤(参考&lt;a href=&#34;http://rhythm-zju.blog.163.com/blog/static/310042008015115718637/&#34;&gt;内容&lt;/a&gt;)：&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;生成一个RSA私钥private.key&lt;br /&gt;
&amp;gt; $ openssl genrsa -des3 -out private.key 1024&lt;/p&gt;
&lt;p&gt;参数解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;genrsa: 用于生成RSA密钥对的OpenSSL命令&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;des3: 使用 3-DES 对称加密算法加密密钥对，该参数需要用户在密钥生成过程中输入一个口令用于加密。今后使用该密钥对时，需要输入相应的口令。如果不加该选项，则不对密钥进行加密。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;out: 将生成的密钥保存到文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2014: RSA模数位数，在一定程度上表征密钥强度。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成一个CA证书认证申请&lt;br /&gt;
&amp;gt;$ openssl req -new -days 365 -key private.key -out req.csr&lt;/p&gt;
&lt;p&gt;参数解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;req: 用于生成证书认证申请的openSSL命令&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;-new： 生成一个新的证书认证请求。加上这个参数后，会提示用户输入申请者的信息&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;-days 365: 证书的有效期：从生成之日起365天&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;-out req.csr: 证书申请保存的目的文件。为中间文件，可以在证书生成以后删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该命令会提示用户输入密钥的口令(如果上一步中没有加des3参数则不会)，以及一系列证书申请者的相关信息。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对CA证书申请进行签名&lt;br /&gt;
&amp;gt; $ openssl ca -selfsign -in req.csr -out ca.pem&lt;/p&gt;
&lt;p&gt;参数解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ca: 用于CA相关操作的命令&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;-selfsign: 自签名(用与证书中包含公钥所对应的密钥签名)&lt;/li&gt;
&lt;li&gt;-in req.csr: 证书认证申请文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;-out ca.pem: 证书保存到目的文件&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注：以上两个步骤可以合二为一。利用ca的-x509参数可以生成自签名的证书，将申请和签发两步一起完成：&lt;br /&gt;
&amp;gt; $ openssl req -new -x509 -days 365 -key private.key -out ca.pem&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;利用生成的根证书签发证书&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一部分请参看&lt;a href=&#34;http://blog.yuantops.com/tech/SSL-creation-guide&#34;&gt;文章&lt;/a&gt;，因为下面的步骤可能有些问题。&lt;/p&gt;
&lt;p&gt;利用生成的根证书签发证书的过程，1，2步与上一部分相同，只是在第3部分，签名的时候有差异:&lt;br /&gt;
&amp;gt; $ openssl ca -in req.csr -cert ca.pem -out userca.pem -keyfile private.key&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 参数解释：
- ca: 用于CA相关操作的命令
- -in req.csr: 证书认证申请文件
- -cert ca.pem: 用于签发的CA证书
- -out userca.pem: 处理完成后输出的证书文件
- -keyfile private.key: CA的私钥文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;一些思考与体会&#34;&gt;一些思考与体会&lt;/h3&gt;
&lt;p&gt;因为openssl工具十分强大，每个人的使用方法都不同，所以在参考别人的使用方法时会有很多疑惑。下面是一些思考与体会：(参考&lt;a href=&#34;http://www.cnblogs.com/littlehann/p/3738141.html&#34;&gt;这篇博客&lt;/a&gt;)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在生成过程中有很多文件扩展名(.crt、.csr、.pem、.key等等)，从本质上讲，扩展名并不具有任何强制约束作用，重要的是这个文件是由哪个命令生成的，它的内容是什么格式的。 使用这些特定的文件扩展名只是为了遵循某些约定俗称的规范，让人能一目了然。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;openssl的指令之间具有一些功能上的重叠，所以我们会发现完成同样一个目的(例如SSL证书生成)，往往可以使用看似不同的指令组达到目的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;释疑:openssl genrsa -des3 -out private.key 1024 命令生成的private.key真正包含了什么？&lt;br /&gt;
&amp;gt; 注意到, 在生成证书认证申请时($ openssl req -new -days 365 -key private.key -out req.csr)，参数只用了申请者的private.key，而理论上应该提供申请者的public.key。而且根据RSA加密的数学原理，不可能由private key推出public key。所以这往往会带来疑惑: public key从哪儿来？&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考&lt;a href=&#34;http://stackoverflow.com/questions/5244129/use-rsa-private-key-to-generate-public-key&#34;&gt;这个回答&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实际上，第一步( $ openssl genrsa -des3 -out private.key 1024 )命令生成的是public-private 的公钥/私钥对,这一对公钥/私钥都保存在private.key文件中。所以，准确说来这一行命令的作用是：生成用户的&lt;strong&gt;公钥/私钥对&lt;/strong&gt;，而不是生成用户的私钥。(虽然一般我们都按后者的方式说)。因此，答案就是：public key本身就包含在private.key中。&lt;/p&gt;
&lt;p&gt;另外，可以使用openssl命令，从private.key中提取出public.key&lt;br /&gt;
&amp;gt; $ openssl rsa -in private.key -pubout -out public.key&lt;/p&gt;</description></item><item><title>SSH登录原理</title><link>https://blog.yuantops.com/tech/ssh-login-procedure/</link><pubDate>Fri, 05 Dec 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/ssh-login-procedure/</guid><description>
&lt;p&gt;关于SSH登录的原理，阮一峰的这篇博客写得很清楚，值得一看。&lt;br /&gt;
&amp;gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html&#34;&gt;SSH原理与运用(一)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;读完这篇博客后，下面是笔记和摘抄。&lt;/p&gt;
&lt;h3 id=&#34;ssh密码登录的流程&#34;&gt;SSH密码登录的流程&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;远程主机收到用户的登录请求，把自己的公钥发给用户。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用户使用这个公钥，将登录密码加密后，发送回来&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;如何防范-中间人-攻击&#34;&gt;如何防范&amp;rdquo;中间人&amp;rdquo;攻击&lt;/h3&gt;
&lt;p&gt;如果有人拦截了远程主机发给用户的公钥，然后将自己的公钥发送给用户，可能会造成远程主机密码泄漏(著名的“中间人攻击”)。用户要识别公钥的真伪，没有更好的办法，只有比较收到的公钥的fingerprint（公钥的MD5值）是不是与服务器公布在网站上的fingerprint相同。&lt;/p&gt;
&lt;p&gt;在用户初次SSH登录一台远程主机时，终端往往会显示远程主机的fingerprint和一条Warning，询问是否确定远程主机的身份并继续。当用户选择确认后，远程主机的公钥会记录到本地系统的known_hosts文件中。下次再登录时，系统如果发现远程主机的公钥记录在案，就不再发出Warning。&lt;/p&gt;
&lt;h3 id=&#34;ssh公钥登录的流程&#34;&gt;SSH公钥登录的流程&lt;/h3&gt;
&lt;p&gt;以密码方式SSH登录远程主机，每次都需要输入密码，这样既麻烦，又存在密码泄露的潜在危险。公钥登录可以解决这两个问题。(有的高安全规格的服务器甚至不允许用户以SSH密码登录，只允许以SSH公钥方式登录。)&lt;/p&gt;
&lt;p&gt;公钥登录的流程：&lt;br /&gt;
1. 用户将自己的公钥存储在远程主机上。&lt;br /&gt;
2. 登录时，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。&lt;br /&gt;
3. 远程主机用实现存储的公钥解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。&lt;/p&gt;
&lt;h3 id=&#34;linux下生成公钥-私钥对的命令&#34;&gt;Linux下生成公钥/私钥对的命令&lt;/h3&gt;
&lt;p&gt;在用SSH公钥登录时，第一步需要用户提供自己的公钥。Linux，特别是服务器环境下，经常会有用到公钥/私钥对的场景，生成它们的命令也十分基础。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;生成公钥/私钥对&lt;br /&gt;
&amp;gt;$ ssh-key&lt;/p&gt;
&lt;p&gt;运行命令，并确认它的默认设置，会在$HOME/.ssh/目录下生成两个文件： id_rsa.pub和id_rsa。rsa意味着它们是以RSA加密算法生成的。以pub为后缀的是公钥，可以分发出去(会在下一步添加到远程服务器)；后者是自己的私钥，要妥善保存。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;存储用户公钥到远程服务器&lt;br /&gt;
用户公钥需要添加到远程主机上对应用户的$HOME/.ssh/authorized_keys文件中，以字符串形式附到末尾。有两种方式可以做到：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ssh系列命令
&amp;gt; $ ssh-copy-id user@host&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;等价的手工操作&lt;br /&gt;
&amp;gt; $ ssh user@host #登录远程主机&lt;br /&gt;
&amp;gt; $ mkdir -p $HOME/.ssh #如果用户主目录下.ssh目录不存在则创建&lt;br /&gt;
&amp;gt; $ gedit .ssh/authorized_keys #用文本编辑器打开.ssh/authorized_keys文件，将上一步生成的id_rsa.pub文件里的内容附在末尾。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;个人思考-信任的锚点如何建立&#34;&gt;个人思考：信任的锚点如何建立&lt;/h3&gt;
&lt;p&gt;SSH无论密码登录还是公钥登录，为了保证传输的安全，不得不考虑各种潜在的安全漏洞。由于SSH引入了公钥/私钥机制，可以认为已经建立的连接是安全的。最高危的时刻是建立连接的时候：谁来确认对方的身份、建立对它的信任？&lt;/p&gt;
&lt;p&gt;机器是不能帮我们做到的。所以在首次登录远程主机时，终端会显示远程主机公钥的fingerprint，并询问是否要继续连接它。这时，就需要我们自行承担风险：我信任，或者不信任。一旦选择&amp;rdquo;信任&amp;rdquo;，就意味着建立了&amp;rdquo;信任的锚点&amp;rdquo;。后面的连接都会根据这个锚点而建立信任关系。&lt;/p&gt;
&lt;p&gt;SSH公钥登录的方式也是同理。对一台远程主机而言，当用户的公钥被附到authorized_key文件末尾时，就意味着建立了&amp;rdquo;信任的锚点&amp;rdquo;。执行这个操作的人，就是建立&amp;rdquo;信任的锚点&amp;rdquo;的人，显然也是承担风险的人。&lt;/p&gt;
&lt;p&gt;我觉得从这个角度来思考SSH登录的原理，也是很独特的。&lt;/p&gt;</description></item><item><title>关于Git,需要理解的几个关键概念</title><link>https://blog.yuantops.com/tech/key-concepts-to-understand-git/</link><pubDate>Fri, 05 Dec 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/key-concepts-to-understand-git/</guid><description>
&lt;p&gt;Git的控制哲学十分优雅,特别是了解它后会更为之倾倒。Git的入门在此不赘述。在掌握常用命令之后,再思考下面这些概念,相信对Git的认识会得到提升。&lt;/p&gt;
&lt;h3 id=&#34;git基于commit-每个commit有独一无二的sha-1作为标志&#34;&gt;Git基于Commit,每个Commit有独一无二的SHA 1作为标志&lt;/h3&gt;
&lt;p&gt;Git有Working Tree,Index,Repo的概念。Working Tree指当前的工作目录,当这个目录下有改动时,通过add命令将改动添加到Index区域。当改动都被加到了Index、需要提交时,使用commit命令将它们提交到Repo中。这次提交会形成一个Commit记录,它相当于当前状态的一个SnapShot。&lt;/p&gt;
&lt;p&gt;基于Commit的版本控制是十分优雅的想法。原因在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次Commit,系统只是保存了&lt;strong&gt;文件的改变&lt;/strong&gt;(而不是改变后的文件),这样节省了磁盘空间&lt;/li&gt;
&lt;li&gt;每次Commit都是在上次Commit的基础上发生的(当Git Repo初始化时建立第一个Commit,它是所有Commit的最终基础),包含了对上次Commit的引用,因此一次次的Commit形成了一个链式结构&lt;/li&gt;
&lt;li&gt;每个Commit都有&lt;strong&gt;唯一&lt;/strong&gt;的标志符号: (一般为)SHA 1值。它是Commit的内容经过数学计算得到的。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过引入Commit,我们的所有改动都被纳入系统中,使改动变得有迹可循。&lt;/p&gt;
&lt;h3 id=&#34;branch-head-tag本质上都是为commit所取的别名&#34;&gt;Branch, HEAD, TAG本质上都是为Commit所取的别名&lt;/h3&gt;
&lt;p&gt;只有先理解“Git基于Commit”,才能理解上面这句话。&lt;/p&gt;
&lt;p&gt;因为Repo的更改记录是以一个个Commit组织起来的,它们就像一个个节点,能确定某个确定时刻的目录状态。因此,当我们想要切换到某个状态时,就要在庞大的Commit网络中定位某个Commit,并转到那个Commit。但唯一标准Commit的SHA 1值是很长的一串数字,为了方便识别与输入,就给这些SHA 1添加字符串的别名。因此Branch,HEAD,TAG本质上都是SHA 1的别名,确定Commit用的。&lt;/p&gt;
&lt;p&gt;但Branch, HEAD, TAG毕竟有特殊的地方(不然为什么不给所有的Commit都取别名呢？),它们标记的是特殊的Commit：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Branch标记某个分支上离现在时刻最近的那次Commit。显然,随着在分支上不断提交Commit,Branch的指向对象也不断前进。试想一棵有枝干和树叶的树,那么Branch就是所有树枝末端的那片叶子。又因为每个Commit都包含它父Commit的标识(SHA 1值),所以确定了一个分叉的末端,就相当于确定了这个分叉上的所有Commit。一般而言,Git Repo都默认存在一个叫master的Branch。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HEAD标记当前工作在哪个Commit位置。试想我正在开发软件项目,5个不同分支对应相对5个独立的功能,我要接着修改哪一个分支,就把HEAD移到这个分支上。又因为Branch指向分支的最新Commit,所以也就是把HEAD移到了这个Branch上。当然,如果我不想接着某个Branch的最新进度修改,当然也是可以的,直接切换到那个Commit即可。总之,可以将HEAD想象成*我此时此刻站着干活的地方*。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TAG是单纯的给Commit的SHA 1取的别名。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;checkout其实是在移动head&#34;&gt;Checkout其实是在移动HEAD&lt;/h3&gt;
&lt;p&gt;只有理解了HEAD的意义,才能理解上面这句话。&lt;/p&gt;
&lt;p&gt;当我们谈论“在不同branch之间切换时”,真正起作用的是HEAD。既然HEAD指向的是某个Commit,那么checkout的参数可以是任何能确定Commit的标志(Branch,TAG,或者直接某个SHA 1值)。当然,checkout命令的用法很多,也有特殊情况checkout命令不会改变HEAD指向的Commit。&lt;/p&gt;</description></item><item><title>SSL学习笔记 前言</title><link>https://blog.yuantops.com/tech/ssl-series-introduction/</link><pubDate>Sun, 30 Nov 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/ssl-series-introduction/</guid><description>&lt;p&gt;最近实习时接触到了SSL协议，CA证书，ssh登录之类的东西，总是一知半解的感觉非常不好，于是我决定好好钻研一下。在网上查找了很多资料后，终于理清了很多以前很模糊的知识点。用几篇博客来记录一下，算是一个总结。&lt;/p&gt;
&lt;p&gt;SSL(Secured Sockets Layer)与SSH(Secure Shell)，是用来解决网络传输中安全问题的协议。如何保证传输安全，使消息不被窃听、不被篡改，这需要用到加密技术。所以，要理解SSL中CA certificate的意义、ssh登录的工作原理，首先得理解它们所基于的加密原理: &lt;strong&gt;非对称加密&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;非对称加密技术是在信息论的理论基础上，以数学为工具的现代加密技术。它是现在最先进、最不易破解的加密技术。由于非对称加密技术在这一系列概念中的基础性地位，会有单独一篇文章介绍它的历史渊源和数学原理。&lt;/p&gt;
&lt;p&gt;非对称加密技术与对称加密技术最明显的区别之处在于，它的密码都是以“&lt;strong&gt;公钥/密钥&lt;/strong&gt;”形式成对存在的。如果要使用非对称加密技术，就出现了很自然的疑问：如何生成这些公钥/密钥对呢？我又该如何使用、部署它们？在Linux系统中，有一些非常强大、非常好用的命令工具帮助我们操作它们。这些命令会在后续谈论应用的技术实现的文章中介绍。(默认Linux环境)&lt;/p&gt;
&lt;p&gt;非对称加密技术最著名的，也是本系列文章将会介绍的，是两大应用：SSH登录和SSL协议。SSH登录的原理相对简单，阮一峰的博客上有几篇文章介绍得非常详细好懂，因此只会有一篇文章讨论它。&lt;/p&gt;
&lt;p&gt;而SSL协议，内容会多一些。首先，参考阮一峰的博客，会有一篇文章关于SSL加密的基本原理(包括Digest, Signature, Certificate等概念)。其次，因为Certificate在现实中使用得非常广泛，会有一到两篇文章介绍Certificate证书与X.509标准，也会介绍CA以及Certificate的&amp;rdquo;信任链&amp;rdquo;，PKI等概念。然后，会有一篇文章介绍如何为自己的域名生成Certificate。最后，从另外一个角度出发，会有一篇文章讨论当浏览器通过https链接访问网页时的交互流程(基本上翻译一篇国外的博客)。&lt;/p&gt;
&lt;p&gt;非对称加密技术也可以在DNS系统中使用，即DNSSEC技术。关于这一技术，如果有时间的话，也会有一到两篇博客予以介绍。&lt;/p&gt;</description></item><item><title>vim增加markdown语法高亮支持</title><link>https://blog.yuantops.com/tech/vim-add-markdown-syntax-support/</link><pubDate>Sun, 30 Nov 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/tech/vim-add-markdown-syntax-support/</guid><description>&lt;p&gt;markdown是一种非常简洁美观的语法格式，非常适合用来撰写博客(&lt;a href=&#34;http://www.jianshu.com/p/q81RER&#34;&gt;简书 语法简介&lt;/a&gt;)。在linux下，我个人最习惯用vim做文本编辑器。那么，如何使vim支持markdown的语法高亮呢？&lt;/p&gt;
&lt;p&gt;vim是支持自定义语法高亮插件的。于是，问题就变成了两部分：&lt;br /&gt;
1. 找到markdown语法高亮显示的vim配置文件&lt;br /&gt;
2. 在vim中导入这个配置文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vim配置文件下载&lt;/strong&gt;&lt;br /&gt;
vim语法配置文件一般后缀为.vim。markdown的语法配置文件可以从下面链接中找到，假设它为markdown.vim, 将其下载到本地。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.vim.org/scripts/script.php?script_id=1242&#34;&gt;vim官网链接&lt;/a&gt;, 或者这个项目的最新&lt;a href=&#34;http://github.com/plasticboy/vim-markdown/&#34;&gt;github项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置文件导入&lt;/strong&gt;&lt;br /&gt;
vim自定义配置文件的导入和安装见&lt;a href=&#34;http://www.fleiner.com/vim/create.html&#34;&gt;链接&lt;/a&gt;。 在这里我将其转述如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在.vimrc文件(.vimrc文件一般在$HOME目录下，若不存在则新建)中添加一条语句，定义一种语法格式，以及这种格式对应的配置文件。&lt;br /&gt;
以本文为例，假设markdown.vim保存路径为$HOME/.vim/markdown.vim，则在.vimrc文件中添加&lt;br /&gt;
&amp;gt; au! Syntax markdown source $HOME/.vim/markdown.vim&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注&lt;/em&gt;: 配置文件路径一定要正确配置&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;再在.vimrc文件中添加一条语句，规定何种后缀名的文件适用这种语法格式。&lt;br /&gt;
以本文为例，我想后缀名为md与markdown的文件以markdown格式显示，那么在.vimrc中添加语句&lt;br /&gt;
&amp;gt; au BufRead,BufNewFile *.md set filetype=markdown&lt;br /&gt;
&amp;gt; au BufRead,BufNewFile *.markdown set filetype=markdown&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;保存.vimrc文件并退出，整个配置过程结束。&lt;/p&gt;</description></item><item><title>自杀，沉重的日常</title><link>https://blog.yuantops.com/opinions/heavy-topic-of-suicides-in-china/</link><pubDate>Sat, 09 Aug 2014 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/heavy-topic-of-suicides-in-china/</guid><description>&lt;p&gt;自杀什么时候成了流行话题？每天都有媒体报导形形色色的自杀，理由千奇百怪：避债、情困、喊冤……实在数不过来。这些新闻往往出现在报纸的社会版块，是吸引读者的猎奇故事。&lt;/p&gt;
&lt;p&gt;自杀是困扰全世界的大难题。The economist的&lt;a href=&#34;http://www.economist.com/news/china/21605942-first-two-articles-chinas-suicide-rate-looks-effect-urbanisation-back&#34;&gt;这篇文章&lt;/a&gt;将目光转向中国，讨论了中国近几年自杀率急剧下降的现象。下面梳理下文章的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中国在90年代的自杀率在全球占前几位，尤其农村青年妇女的自杀率高到离谱。但到了2011年，中国已经成为世界范围内自杀率垫底的几个国家之一。&lt;/li&gt;
&lt;li&gt;研究发现，自杀率的降低关键在于农村妇女的自杀急剧减少。官方和民间的数据都显示，过去二十年间从农村、城市、男性、女性、以及各个年龄层等不同角度看，自杀率都处于下降趋势。唯一的例外是，&lt;strong&gt;老年人&lt;/strong&gt;的自杀率在最近几年有所上升。&lt;/li&gt;
&lt;li&gt;自杀率的下降有两大驱动因：移民(migration)和城市中产阶级的壮大(the rise of an urban middle class)。移民到大城市工作（即使是做农民工）使得妇女有更大的人身和财产自由，摆脱了父母、婚姻、公婆、贫穷等等压迫。另外，在城市里即使想自杀也不像在农村那么容易，因为城里剧毒的农药不是身边的必备品。城市的家庭规模往往小，家庭矛盾也随之减少。&lt;/li&gt;
&lt;li&gt;随着中国的人口变老、变富，情况有可能转恶。城市化的推进使得家庭规模变小，降低了年轻人的负担，但也有副作用：农村里照顾老人的人手不够，城市里老年公寓里老人孤单寂寞。在接下来的几年里，这一趋势会更明显。&lt;/li&gt;
&lt;li&gt;无论将来的发展如何，中国的自杀率肯定是不会堕落到90年代的水平了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章从宏观的角度讨论了中国在控制自杀率方面取得的骄人成就。事实上，这一成就不是刻意为之，而是经济发展的附加产物。文章里提到的几点忧虑，例如如何面对老龄化的问题，十分值得重视，因为现在这些问题已经凸显出来了。中国青年报的&lt;a href=&#34;http://zqb.cyol.com/html/2014-07/30/nw.D110000zgqnb_20140730_3-09.htm&#34;&gt;这篇报道&lt;/a&gt;就为我们展示了一幅农村老人自杀“平静与惨烈”的现状，令人震撼。&lt;/p&gt;
&lt;p&gt;这篇报道提到学者刘燕舞的研究结论：
&amp;gt;从1990年开始，中国农村老年人自杀率大幅上升，并保持在高位。&lt;/p&gt;
&lt;p&gt;这与上文经济学人的援引的数据相悖。有趣的是，这篇文章里学者刘燕舞正面回应了这一反差：
&amp;gt;“中国的自杀率总体上是在下降的。”刘燕舞告诉中国青年报记者，然后换了一种沉重的语气说，“但是，农村老人却越来越难以摆脱这条（自杀的）路，这或许是他们稀释和消化现代老龄化社会痛苦的特有方式。”&lt;/p&gt;
&lt;p&gt;数据很容易解释得通，但相对于冰冷的数字，残酷的现实带给人的震惊就不那么容易平复了。这篇文章所描述的场景很，简直让看到的人冒冷气。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“我们这儿的老人都有三个儿子。”一个柴姓老人乐呵呵地告诉满是疑惑的刘燕舞，“药儿子（喝农药）、绳儿子（上吊）、水儿子（投水），这三个儿子最可靠。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这位老人位于湖北凉山地区。这里的老年人自杀比例非常高，而且村里的人都见怪不怪，习以为常——“越是平静，越是让人不寒而栗。”而老人们的自杀死法也有令人不敢相信的：
&amp;gt;有不少老人，因为行动困难，拿不到药水瓶也站不上板凳悬梁，便在不及人高的窗户上，搭起一根绳，挎住头，蜷起腿活活吊死。有两位山西的老人，儿子不给饭吃，还屡遭媳妇打骂，头朝下扎进家里的水窖中。“这些都是有必死的决心的。”刘燕舞分析道。他还记得有人跟他介绍说，一位老人要自杀，但怕子女不埋他，便自己挖了个坑，躺在里面边喝药边扒土。&lt;/p&gt;
&lt;p&gt;真正令人毛骨悚然的在于，有些老人的“自杀”有“他杀”的痕迹。老人如果不能为子女带孙子孙女，或者照看家里农活，那么就变成了“累赘”。很多老人都有这种“利他”心态，怀着这种心态自杀。有学者如此解释“利他”表象后面的实质：
&amp;gt;刘燕舞的老师、华中科技大学中国乡村治理研究中心主任贺雪峰，将这种已然形成的“自杀秩序”归因为“代际剥削”：自杀的老人们年轻时“死奔”（干活干到死），给孩子盖房、娶媳妇、看孩子，一旦完成“人生任务”，丧失劳动能力，无论是物质或情感上，得到的反馈却少得可怜。&lt;/p&gt;
&lt;p&gt;现实很残忍，甚至让亲情和传统溃败。如何养老的问题不解决好，老人们如何安然走过人生的最后路途呢？这篇文章分析了农村老人自杀的直接原因和困境的解决之道：
&amp;gt;据刘燕舞统计，农村老人自杀最主要的原因是生存困难，其次是摆脱疾病的痛苦，两者合计占直接死因的60%，之后是情感问题。“换句话说，要减少老年人非正常死亡，就要解决三个问题：不饿死，不病死，不寂寞死”。&lt;/p&gt;
&lt;p&gt;几千年前《礼记》里所畅想的“大同”世界里，重要一条是“老有所依”。老有所依，就不会选择不归路，以非正常方式结束生命。老年人的自杀问题之严峻，每个人都或多或少要予以关心。我不由得想起来曾经看到过的一则刷在乡村墙面上的宣传语，觉得很有道理：
&amp;gt;&lt;strong&gt;人人都会老，家家要养老&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>独裁的伟人——读《邓小平时代》</title><link>https://blog.yuantops.com/opinions/dengxiaoping-a-dictatorial-great-man/</link><pubDate>Wed, 14 Aug 2013 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/dengxiaoping-a-dictatorial-great-man/</guid><description>&lt;p&gt;在与华莱士谈笑风生时，江哥面对华莱士一定要扣给他的”独裁者”帽子，十分坚定地予以否认。多才多艺多门外语流畅辩才无碍的江哥，当然知道”独裁者”不是什么好词。他本人固然是不肯承认，但他没底气承受也是事实。《海贼王》里伟大的白胡子说道，”我是旧时代的残党，新时代没有承载我的船”。同样，在邓小平谢幕后，中国这片大海已不再会承载”独裁者”这艘船。邓小平是中国最后一位独裁者。&lt;/p&gt;
&lt;p&gt;中国领导人的个人传记往往是十分敏感的，特别是这位”独裁者”和”伟人”身份合一的小个子领导。而一本面世的传记，除了关心其资料的质量，也要注意作者个人的立场倾向。这本书原本用英文写就，后续再翻译成中文的。这本书的史料翔实，以时间为脉络介绍邓的一生，每章一个阶段，章后附有很长的引用表，显得很严谨。总的说来，是一部很踏实的传记。&lt;/p&gt;
&lt;p&gt;看完这本书，个人有一些收获。平时接触到的更多是邓小平在革命和文革期间的遭遇，”三起三落”&amp;rdquo;挺进大别山”之类的，反而是他发挥能量的八九十年代所知不多（也许是距现在太近的原因）。这本传记介绍了毛周去世后高层争斗的很多史实，包括与华国锋的权力争夺，对陈云等元老的争取和制衡，对赵紫阳胡耀邦等自由派干部从信任提拔到不满放弃，还有他自身在波澜壮阔的这段时期里的作为。说实话，读这段历史当真给人这样一种感觉，毛周的逝世是一个分水岭，分开前后两个截然不同的时期，之前与之后就像一步从古代穿越到今天。而经历了这两段历史，并最终将中国扳回正轨的邓小平，手腕和眼界都让人不得不佩服。名义上邓小平从未做过”国家元首”，但他一直牢牢掌握权力。他是党的元老，经历过抗战和内战，领导过战役（大别山），接管过城市（上海），历经多次政治风暴而不倒，因此在党政军系统都能树立权威。他用个人的威严推动改革，因而被称作”独裁者”并无不妥。&lt;/p&gt;
&lt;p&gt;无独有偶，在海峡对岸的台湾也有类似的一位人物–蒋经国（他和邓小平还在莫斯科有过同窗经历。）。小蒋从父亲手中接过台湾的领导权，在他主政期间，台湾经济腾飞，跃居亚洲”四小龙”之列。他们二人都是威权时代的过来人。所不同的是，小蒋在弥留之际解除党禁报禁，将台湾推上民主轨道；而终邓小平一生，他都是坚定奉行集体主义和所谓”党内民主”，视西方民主为洪水猛兽。历史虽然有其相似之处，但又绝非一成不变。在东欧剧变，共产主义国家纷纷倒戈的年代，中国也在骚动。西方的冲击和改革的混乱纠缠在一起，新旧矛盾合流，终于一发而不可收拾。在事态最危急的时刻，邓拍板用了武力，而且事后没有一丝后悔。广场上的年轻人的诉求，在他看来已经越过了底线。本文作者似乎对邓小平的残酷举动表示了理解。就这样，中国镇压了学生运动，朝着与台湾不同的方向前进，而且势头不可收拾。&lt;/p&gt;
&lt;p&gt;傅高义还浓墨重彩地描写了”南巡”的前后。我才知道，当时邓觉察到以北京为据点的经济保守派势力抬头，而他所挑选的接班人江哥又举棋不定，他才决定绕到相对开放的沿海获取支持、倒逼中央。所谓”独裁者”，这就显示出来了–效忠于他的军队甚至做出了”为改革保驾护航”&amp;rdquo;不改革就下台”的表态。改革开放的贯彻，若没有邓小平的权威在后盯着，触动保守势力也不是那么容易之事。&lt;/p&gt;
&lt;p&gt;传记的最后部分写了香港回归时中英谈判细节。邓小平与撒切尔夫人交手，为香港回归制定了路线。书中所披露的一些细节颇为有趣。港英政府和北京政府如何勾心斗角，如何拉拢民心，香港民众对红色政权如何地不信任–在学潮后到达顶点。邓小平当初许诺回归后”五十年不变”，但现在无论内地香港都对彼此不满，这估计也是他始料未及的。&lt;/p&gt;
&lt;p&gt;邓在中国更广为人知的称号是”改革开放的总设计师”，他被称为”伟人”。更为人津津乐道的是他政治生涯中的”三起三落”。这个矮个子政治家的形象可谓深入人心，他的”猫论”、”过河论”可谓家喻户晓。他最大的污点可能是在”八九年春夏之交的那场政治风波”里的表现。他对中国的贡献是毋庸置疑的。他同时是”独裁者”和”伟人”，无论如何，我对他怀有一份钦佩。&lt;/p&gt;</description></item><item><title>农民没有了土地</title><link>https://blog.yuantops.com/opinions/when-farmers-have-no-land/</link><pubDate>Wed, 27 Mar 2013 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/when-farmers-have-no-land/</guid><description>&lt;p&gt;今天（3月17号）两会闭幕，新总理李克强参加新闻发布会。新华社一位记者问城镇化问题，说有人担心随着城镇化的推进，会有很多农民失去土地，进而形成一个新的阶层–城市贫民阶层，问总理怎么看。&lt;/p&gt;
&lt;p&gt;李Sir的回答避开了城市贫民阶层这点。他说，中国的城镇化规模是人类历史上罕见的，是广大农民的愿望。同时，这一工程非常复杂，还需要各项配套改革推进。总而言之，城镇化有难度，但不会放弃。&lt;/p&gt;
&lt;p&gt;这个问题是本次两会闭幕记者会上最有深度的问题之一。新华社的记者很懂中国的现状。城镇化是中国这片海域里即将扑来的巨浪，因为涉及到土地的分配流转，实在具有全局性的影响。（当年的土地革命和改革开放，无一不是先拿土地问题开刀。）这位记者提及农民会失去土地，让我想到去年回家时所见。&lt;/p&gt;
&lt;p&gt;隔壁镇近年来兴起葡萄种植，而且已颇具规模。过年时，家里长辈带我走亲戚。这位亲戚在自家责任田里建起来一块葡萄园，据说所产葡萄的品质很高，因为靠近国道、临近镇中心，销路也不错。他希望扩大规模，但当地的土地已经很紧俏了，所以有意在我们那儿寻觅一块地方，托长辈们帮忙打听。他于是介绍了与土地主人的合作模式。&lt;/p&gt;
&lt;p&gt;第一种，收租金模式。土地主人把地出租，接下来的十年或者二十年，客户每年向其支付定额租金。客户掌握了土地的所有使用权，原主人不得干涉。第二种，参股模式。土地主人出土地，客户出钱和其他资本，双方合作。每年分红一次，按股份投入比例分配盈亏。（土地按市价折算为股本。）对农民而言，这两种模式的差别在于，前者的风险小，旱涝保收，只要坐收租金就好；后者的盈利幅度可能更大，但如果年成不好，就会亏本，风险也大。&lt;/p&gt;
&lt;p&gt;2013年的中央一号文件，提出要加强土地经营权的流通方式转变，鼓励建设集体农庄。这两种模式，也就是集体农庄的模式了。&lt;/p&gt;
&lt;p&gt;我的想法是，这其实是很危险的。在土地租出去的这一段时间，或者10年或者更长，农民实际上就是无产阶级，丧失了土地经营管理权。十年的时间，足够时局发生翻天覆地的变化，农民作为弱势群体，待到租赁期满，对于土地的发言权实际已经很弱了。那么不难想见，到时候土地兼并而来的”大农庄”会何等气派，零星的农民想抽身出来会何等曲折。这部分农民除了继续持有名义上的土地经营权”所有者”身份，将再无作为。&lt;/p&gt;
&lt;p&gt;不知道国外的土地问题是如何解决的。集体农庄之路，或者说城镇化之路，潜在的风险很大。处在社会底层的农民如果不稳当，那是很危险的。我想，如何防止事实上的”大地主”出现，如何预防新的剥削阶层出现，尚待政策制定者们深思。&lt;/p&gt;</description></item><item><title>读前人笔记</title><link>https://blog.yuantops.com/opinions/book-review-of-some-ancient-notes/</link><pubDate>Fri, 22 Mar 2013 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/book-review-of-some-ancient-notes/</guid><description>
&lt;p&gt;最近看了一些前人的笔记，觉得很有意思。它们比较轻松，又有点猎奇，体裁短小，很适合作睡前读物。&lt;/p&gt;
&lt;h3 id=&#34;阅微草堂笔记&#34;&gt;《阅微草堂笔记》&lt;/h3&gt;
&lt;p&gt;纪昀的作品。他更为人熟知的称呼是纪晓岚，这得感谢狂轰乱炸的《铁齿铜牙纪晓岚》系列电视剧。在电视剧中，纪晓岚机智又充满正义感，与和珅斗智斗勇，甚得皇帝倚重。历史上的纪昀没有如此风光。他虽才高八斗，被乾隆委任编撰《四库全书》，但乾隆帝仅仅将他视作一介书生外加滑稽者，不怎么在正事上看重他。但毕竟是在皇帝身边摸爬滚打，纪昀对世俗的一套溜须拍马功理解深刻，见识也非常犀利露骨，讽刺起伪君子来针针见血。这部笔记就显示了他的文学功力和老练的洞察本领。小说中屡次出现狐仙，但狐仙大都不可恶，不似聊斋那么情节惊悚，更多时候是以写狐来写人。&lt;/p&gt;
&lt;p&gt;这部笔记语言生动幽默，戏谑的尺度把握得很好，读来令人忍俊不禁。&lt;/p&gt;
&lt;h3 id=&#34;浮生六记&#34;&gt;《浮生六记》&lt;/h3&gt;
&lt;p&gt;沈复的作品，感人至深的一部作品。中学语文课本上曾节选过其中片段。季羡林曾说，古今称颂的散文篇章，多是以真感情动人（大意如此）。此话诚然。沈复从小时候的事情写起，写到自己与妻子相识、成亲、相伴、分离的生活琐事，不以情节取胜，单凭诚挚感人。语言清新淡然，十分雅致。&lt;/p&gt;
&lt;p&gt;如果能遇到像沈复妻子一样的伴侣，两人感情能像书中所写一般真挚美好，当真是幸事了。&lt;/p&gt;
&lt;h3 id=&#34;耳食录&#34;&gt;《耳食录》&lt;/h3&gt;
&lt;p&gt;（清）乐钧作品。多记鬼神之事。每篇故事都不长。&lt;/p&gt;
&lt;p&gt;语言上成就一般，仅为消闲之物。&lt;/p&gt;
&lt;h3 id=&#34;醒世恒言-喻世明言-警示恒言&#34;&gt;《醒世恒言》《喻世明言》《警示恒言》&lt;/h3&gt;
&lt;p&gt;冯梦龙编撰作品。大名鼎鼎的”三言二拍”中的”三言”部分，话本小说。每话的质量参差不齐，宣扬传统的价值观，因果报应，贞节烈女，仁义道德之类的。有名的杜丽娘怒沉百宝箱就出于此。&lt;/p&gt;
&lt;p&gt;靠情节取胜。话本的痕迹十分明显。&lt;/p&gt;</description></item><item><title>《三娘子·包公案》</title><link>https://blog.yuantops.com/opinions/a-short-story-from-baogong-records/</link><pubDate>Sun, 17 Mar 2013 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/a-short-story-from-baogong-records/</guid><description>&lt;blockquote&gt;
&lt;p&gt;话说广东潮州府揭阳县有赵信者，与周义相交。义相约同往京中买布，先一日讨定张潮艄公船只，约次日黎明船上会。至期，赵信先到船，张潮见时值四更，路上无人，将船撑向深处去，将赵信推落水中而死，再撑船近岸，依然假睡。黎明，周义至，叫艄公，张潮方起。等至早饭过，不见赵信来，周义乃令艄公去催。张潮到信家，连叫几声，三娘子方出开门，盖因早起造饭，夫去后复睡，故反起迟。潮因问信妻孙氏道：”汝三官人昨约周官人来船，今周官人等候已久，三官人缘何不来？”孙氏惊道：”三官人出门甚早，如何尚未到船？”潮回报周义，义亦回去，与孙氏家追寻四处，三日无踪。义思：”信与我约同买卖，人所共知，今不见下落，恐人归罪于我。”因往县去首明，为急救人命事，外开干证艄公张潮，左右邻舍赵质、赵协及孙氏等。&lt;/p&gt;
&lt;p&gt;知县朱一明准其状，拘一干人犯到官。先审孙氏称：”夫已食早饭，带银出外，后事不知。”次审艄公，张潮道：”前日周、赵二人同来讨船是的。次日，天未明，只周义到，赵信并未到，附帮数十船俱可证。及周义令我去催，我叫’三娘子’，彼方睡起，初开大门。”又审左右邻。赵质、赵协，俱称：”信前将往买卖，妻孙氏在家吵闹是实。其侵早出门事，众俱未见。”又问原告道：”此必赵信带银在身，汝谋财害命，故抢先糊涂来告此事。”周义道：”我一人岂能谋得一人，又焉能埋没得尸身？且我家胜于彼家，又是至相好之友，尚欲代彼伸冤，岂有谋害之理？”孙氏亦称：”义素与夫相善，决非此人谋害。但恐先到船，或艄公所谋。”张潮辩称：”我一帮船几十只，何能在口岸头谋人，怎瞒得人过？且周义到船，天尚未明，叫醒我睡已有明证。彼道夫早出门，左右邻里并未知之，及我去叫，他睡未起，门未开，分明是他自己谋害。”朱知县将严刑拷勘孙氏，那妇人香姿弱体，怎当此刑？只说：”我夫已死，我拚一死陪他。”遂招认”是我阻挡不从，因致谋死。”又拷究尸身下落，孙氏说：”谋死者是我，若要讨他尸身，只将我身还他，何必更究？”再经府复审，并无变异。&lt;/p&gt;
&lt;p&gt;次年秋谳，请决孙氏谋杀亲夫事，该至秋行刑。有一大理寺左任事杨清，明如冰鉴，极有见识，看孙氏一宗案卷，忽然察到。因批曰：”敲门便叫三娘子，定知房内已无夫。“只此二句话，察出是艄公所谋，再发巡行官复审。&lt;/p&gt;
&lt;p&gt;时包公遍巡天下，正值在潮州府，单拘艄公张潮问道：”周义命汝去催赵信，该叫三官人，缘何便叫三娘子？汝必知赵信已死了，故只叫其妻！”张潮闻此话，愕然失对。包公道：”明明是汝谋死，反陷其妻。”张潮不肯认，发打三十；不认，又夹打一百；又不认，乃监起。再拘当日水手来，一到，不问便打四十。包公道：”汝前年谋死赵信，张潮艄公诉说是你，今日汝该偿命无疑。”水手一一供招：”因见赵信四更到船，路上无人，帮船亦不觉，是艄公张潮移船深处推落水中，复撑船近岸，解衣假睡。天将亮周义乃到。此全是张潮谋人，安得陷我？”后取出张潮与水手对质，潮无言可答。将潮偿命，孙氏放回，罢朱知县为民。可谓狱无冤民，朝无昏吏矣。&lt;/p&gt;
&lt;p&gt;–《包公案·卷之七·三娘子》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《包公案》的这一话给我的印象很深。包公不止是法官，还是探长，法医，甚至是神仙。但这一话的情节丝毫不涉及传奇鬼怪，全是人的故事。有人谋害了别人，反去诬陷被害人的朋友。糊涂知县冤枉了好人。所幸的是卷宗记载有一处十分隐晦的破绽，在复核死刑时被高级法院的法官识出了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“敲门便叫三娘子，定知房内已无夫。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;便是这一句话，当真妙极。因为潜意识里知道丈夫已经不在了，所以杀人犯进门就喊三娘子的名字。(在古时，妇女一般谨守礼教，很少有外人，特别是男性与之交流) 这是印证式的发问。这位火眼金睛的大人果然明察。&lt;/p&gt;
&lt;p&gt;我觉得包公案里，这样的故事是好故事。细细体味一下杀人犯所处立场和他所说的话，顿时觉得微妙细致。如果把时代和背景一换，这完全可以是个现代心理剧。&lt;/p&gt;</description></item><item><title>了不起的葡萄——读《第九个寡妇》</title><link>https://blog.yuantops.com/opinions/the-greatness-of-widow-putao/</link><pubDate>Sun, 25 Nov 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/the-greatness-of-widow-putao/</guid><description>&lt;p&gt;《第九个寡妇》，看名字容易让人想入非非。但很遗憾，这本书讲的不是寡妇门前的风流韵事，而是一个寡妇一辈子的波折。&lt;/p&gt;
&lt;p&gt;故事发生在关中平原，时间横跨民国和红朝。一个女孩子（葡萄）在荒年被卖，给人买了作童养媳。她和买她的一家人在动荡年景里生活，历尽坎坷。她最了不起的一件事，是把在政治运动中受了枪决的公公救回来，藏在地窖里几十年。&lt;/p&gt;
&lt;p&gt;书的开头介绍了葡萄和其他八个女人成为寡妇的因由。日本人要抓”老八”（八路），但老八混进了村里的男人堆里，日本人叫把全村的媳妇叫来领走自家男人。有八个新媳妇先上前，但牵回的是老八。葡萄她牵回了自己丈夫。八个男人被媳妇推出去当了冤大头，当天归了西。葡萄的丈夫躲过了日本人的枪，但当天晚上暗中一枪子解决了他。于是，葡萄成了第九个寡妇。&lt;/p&gt;
&lt;p&gt;读到这儿，想到一个字形容她：戆。&lt;/p&gt;
&lt;p&gt;什么是戆？某年春晚有一出小品《实诚人》，说一个实心眼的人专门拣人的客套漏子，你客套我当真，占了便宜还能憋死被揩油的事主。戆人，就是把这股子实诚劲儿拿出来，虽然不专门为占便宜，但运用到待人处事上是直肠子到底。什么客套，什么敷衍，全扔掉。那还剩下什么。一个除去了无用粉饰的机灵女子，剩下的全是好货：真诚、勇气、担当、赤子心，还加上蓬勃魅力。&lt;/p&gt;
&lt;p&gt;葡萄她是戆成了寡妇。前八个媳妇，大义凛然地站在气节一边，最后能顶着光环生活。葡萄太差，觉悟丢人。丢人就丢人呗，小品《实诚人》里丢人的人能占便宜，吃饺子。讽刺又无奈的事实是，只有小便宜可以占–否则英雄寡妇如何自处？所以葡萄领回的丈夫不长久。自己不装不行，不喜欢也得装。葡萄不懂这个道理，结果她的寡妇身份在别人眼里低一等。&lt;/p&gt;
&lt;p&gt;葡萄不傻。《皇帝的新装》里，最聪明的人都去夸耀衣服的美，只有一个孩子敢喊”皇帝光着身子！”这里，耀眼的被夸耀的新衣服不断在换：从抗日的民族大义，到土改时的无产阶级立场，到大跃进时的革命热情。理直气壮的理由很多，永远不缺是不是？一波波口号喊了又喊，粉墨登场的人换了一茬又一茬。她只顾自己的事情，认定的理就难变通。她到底是觉悟低，还是世界上的大多数人觉悟高过了头？&lt;/p&gt;
&lt;p&gt;所以葡萄的戆能引起人的一点思考。她的人生轨迹，是将自己的本色活到了极致。人的本性是自私的，不忍的，作为情人是热烈的，作为母亲是怜爱的。然而最矛盾的，极度活出自己的人会与自己的社会属性冲突。葡萄的率性质朴，与她的周遭显得格格不入。社会运行的规矩在变，变得太迅速了。社会出了差错，黑白颠倒了，坚持不随之改变的人才能在世界恢复正常时保持体面。&lt;/p&gt;
&lt;p&gt;但没人能肯定，到底是世界不正常，还是自己不正常，因而这份坚持很难得。”人之初，性本善”，时间能打磨一个人，磨成现实希望他成为的模样。严歌苓创造了葡萄这个夸张的形象，她始终都是一颗真心，一枚璞玉。她是戆人。严歌苓把她放在混乱的世道里，显出她的好处，反过来又讽刺这世界的荒谬。&lt;/p&gt;
&lt;p&gt;严歌苓的这部小说，铺展在混乱的时代背景里，充满了传奇色彩。（当然了，严歌苓的作品一向传奇而浪漫。）小说的时间轴串连起情节，最先开始的日本人，之后的八路和国军，灾荒，解放，土改，大跃进，文革，再到改革开放。作为非本土创作的外籍作家，严歌苓写中国人物总显出一种隔得远远的冷静。她的视角很独到，兼具细腻，能将个人的一哭一笑展现得一毫不差。&lt;/p&gt;
&lt;p&gt;葡萄的公公藏在地窖近三十年，最后头发全白了才得见天日。当初要枪毙他、和他划清界限的儿子，还有自觉对他做过亏心事的乡党，这时候惭愧了。世事过了一轮，报应也轮过来了。但葡萄还是葡萄，时间也不能改变她一点儿。&lt;/p&gt;</description></item><item><title>为信仰感动——读《旧约 出埃及记》</title><link>https://blog.yuantops.com/opinions/moved-by-their-faith-of-god/</link><pubDate>Sun, 18 Nov 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/moved-by-their-faith-of-god/</guid><description>&lt;p&gt;圣经旧约故事里，除了亚当和夏娃的犯错，最出名的大概是《出埃及记》（ Exodus ）。上帝施大能，派摩西拯救在埃及受苦的子民，指引他们走向流着奶与蜜的应许之地。千百年来，无数民族曾于黑夜里等待光明，坚信上帝会再次施展神迹，就像他曾经所为。这个故事给了他们期望，成为他们所守护的信仰。&lt;/p&gt;
&lt;p&gt;迪斯尼以这个故事为原型出过一部动画片《埃及王子》，制作十分精良。我先的看动画，再看文字。动画本身的画面和音乐都十分精彩。还有一首歌《Exodus》，气势颇磅礴。相关的文学作品和艺术创作不胜枚举，为这个本身就很感人的故事再增添血肉。&lt;/p&gt;
&lt;p&gt;希伯来人在埃及停留，子孙生养众多，为埃及人顾忌。法老虐待他们，叫他们做苦力，吩咐产婆杀死新生的希伯来男婴。年复一年，他们都在埃及监工的皮鞭下受罪，忘记了曾经的信仰。上帝听到哭声，怜悯他的子民，就选中摩西带他们出苦海。&lt;/p&gt;
&lt;p&gt;八十岁的摩西在沙漠中牧羊，看到了火中的荆棘不损毁，知道这是神迹。上帝开口，把重担说与他听。摩西十分惶恐不敢，再三推托。上帝发怒，昭示说他将与他同在。于是摩西去和法老交涉了。上帝屡次显示神迹，法老屡次反悔。上帝降下的历次灾祸，十分详细地被记录在书中。最终的大杀器是，降下了头生子之灾。除了希伯来人，埃及境内所有的头生子都被杀死了。天亮后，哀号降落在大地，每家每户都传出悲伤的哭泣。希伯来人被允许走了。&lt;/p&gt;
&lt;p&gt;对无辜婴儿的无差别屠杀，十分恐怖。说亚伯拉罕宗教信仰的”神”是凶神，并不冤枉。上帝教希伯来人避灾：宰杀一头羊羔，将羊羔的血涂上门框，那么他就将过而不入。这是”救赎”的逻辑：羊羔的血代替了头生子的血，赎回了本该受难的人。在此之后若干年，一个犹太的年轻人被罗马人钉死在十字架上，同样流干了他的血。他为拯救世人的罪恶而降生，用血替人赎罪，人们称他为耶稣基督。对上帝的违背是所有罪恶的根源，圣经故事的主题大多如此。&lt;/p&gt;
&lt;p&gt;摩西领着希伯来人赶路，后面埃及人的军队追上来了。前面是红海，波涛汹涌。上帝再次显示施展神力，分开红海，露出大路。希伯来人在埃及停留四百多年，终于走出了埃及。上帝没有忘记他们，拯救了他们。&lt;/p&gt;
&lt;p&gt;之所以这个故事流传如此广泛，很大程度上因为其中及其详细的记录了上帝施展神迹的细节。上帝的存在，变得真实形象。在埃及受苦几百年，希伯来人还是等到了上帝带他们出走的那天。现实生活里的苦，种种的难，也许是上帝的一种考验。摩西会被上帝选中的，上帝不会忘记他的子民。&lt;/p&gt;
&lt;p&gt;我为这个故事感动。在逆境里有一个信仰支撑，就像黑夜里见到灯塔的指引。随着摩西从红海分开的大道上走过的人，他的心想必充满畏惧，又全是欣喜。他的信仰被证实，人生得到了拯救。因信仰，他们都是有福的。&lt;/p&gt;</description></item><item><title>初读莫言</title><link>https://blog.yuantops.com/opinions/first-response-to-moyan-novel/</link><pubDate>Mon, 12 Nov 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/first-response-to-moyan-novel/</guid><description>&lt;p&gt;很早之前，我在高中的一本读物上读到过莫言。这篇文章讨论到地域对作家的语言的影响，说即使是出生地那么近的两个作家，莫言的语言就明显带有故土的气息，而另一个作家（名字忘了）则淡得多。我全然没接触过莫言的作品，直到莫言得到今年的诺贝尔文学奖，我脑海中也只有个模糊印象，知道他是乡土一派的作家。&lt;/p&gt;
&lt;p&gt;最近开始读莫言的作品，最先读的小说是《牛》。之后，读了他的散文集《会唱歌的墙》和《透明的胡萝卜》。莫言是个十分高产的作家，作品的风格多变，反映的主题也十分丰富。这三本书，已经能使我印证这一点。&lt;/p&gt;
&lt;p&gt;《牛》里，村公社里一头公牛要被阉割。兽医、村干部、公社社员、我和乡干部，一群人围绕着这头动过手术后的牛，动尽形形色色的脑筋。最后，牛伤口感染死了，被乡长扣下和诸位干部饱食一顿。熟料这头死牛已经感染了病菌，毒倒了所有吃它的高级人物。牛是一个线索，透过它展现人的丑态，有小人物的斤斤计较，更多的还是为官者装模作态式的虚伪。虚伪者能当道，堂而皇之，其荒谬的根源不言而喻–整个政权是这样运作的。描写一种荒诞，其实真正想展现给读者的是反面的讽刺。&lt;/p&gt;
&lt;p&gt;体现莫言语言特色的，有这么一段描写。牛被阉割后的伤口感染，卵袋里胀满脓血，”我”戳了它一刀。杜大爷很赞赏”我”的做法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;杜大爷折了一根树枝，转到牛后，将树枝戳到牛的蛋皮里搅着。牛似乎很痛苦，想抬起后腿蹬人。但它仅有蹬人的意念，没有蹬人的力气了。它的后腿抬了抬就放下了。它只能用浑身的哆嗦表示它的痛苦。杜大爷真诚地说：”牛啊牛，你忍着点吧，这是为了你好……”蛋囊里的脏物哗哗地往外流，先是白的、黄的，最后流出了红的。杜大爷扔掉树枝，说：”好了，这一下保证好了！”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;恶心死我了。颜色词的应用，一下把场景写活，形色俱备，场面的确让人倒胃口。&lt;/p&gt;
&lt;p&gt;《透明的胡萝卜》十分晦涩，我反正没读懂。黑娃一句话也不说，行为也古古怪怪。他跟着小铁匠做学徒，从全书的角度看，似乎是以旁观者的身份围观小铁匠、小石匠、女主角之间的感情纠葛。有人说这部小说类似童话。莫言描写黑娃在火炉边，语言充满了想象力。黑娃这个默然、有神奇感觉的形象到底意味着什么，我一头雾水。&lt;/p&gt;
&lt;p&gt;《会唱歌的墙》是一本轻快的散文集子。说它轻快，是相对小说而言的。莫言写了他儿时的生活经历，创作历程，在军队里的生活。特别是关于”吃”的几篇文章，真不错。莫言的人生态度，从这本集子里能得到很多资料。他童年时家庭艰苦，为食物所受的折磨的给他的一生留下影响，在作品里体现出不可磨灭的印记（譬如，《牛》最后难免沦为食物），同时也更能反思那段荒谬时代的种种过错。他受到军队的恩惠，对军队的感情很深。但他不是单纯的党的作家，要全面地认识他的立场。他说自己的文学创作，受到福纳克的影响，致力于构建属于他自己的高密东北乡，在这片由他主宰的土地上将一切抱负付诸现实。&lt;/p&gt;
&lt;p&gt;莫言的语言，特点之一是泼辣鲜活，流畅，没有翻译腔。叙事时俗得接近口语，所以显得气势连贯。写景抒情时，又细腻贴切。他的题材，大多围绕了乡村和民俗。&lt;/p&gt;
&lt;p&gt;现在我不是很感冒他的风格。他太”土”了，我不适应，就像我不能爱上煎饼卷大葱这种吃法。他的作品追求技法，我欣赏起来常有困难。&lt;/p&gt;
&lt;p&gt;但不管我怎么看，莫言的价值和伟大摆在那儿。我还要多看些，也许逐渐我就学会了欣赏这种美。&lt;/p&gt;</description></item><item><title>一场包皮引发的抗议</title><link>https://blog.yuantops.com/opinions/a-protest-caused-by-foreskin/</link><pubDate>Fri, 26 Oct 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/a-protest-caused-by-foreskin/</guid><description>&lt;p&gt;9月15日 的《经济学人》上有一篇文章，介绍德国柏林穆斯林和犹太教徒的一起抗议：示威者们上街游行，反对当地政府新颁布的“割礼”干涉令。在我们看来难登大雅之堂的“那话儿”，居然引发了一场几百人参与的示威，不禁让人咂舌。&lt;/p&gt;
&lt;p&gt;“割礼”(circumcision)远不止割一刀那么简单。在亚伯拉罕宗教(犹太教、基督教、伊斯兰教)流行的地区，“割礼”有着特定的宗教含义。世界上大约三分之一的男子做过这个手术。&lt;/p&gt;
&lt;p&gt;根据《圣经·创世纪》17章9-14节记载，上帝吩咐亚伯兰为自己、男性子孙和仆人都要行割礼为永久之契约。这是《圣经·旧约》里，上帝降下的旨意，由此与犹太民族定下了盟约。犹太教徒的割礼仪式践行得最为严肃，一般由穆汉（Mohel）为出生后第八天的新生男童举行割礼。基督教徒和穆斯林同样很看重这个仪式。&lt;/p&gt;
&lt;p&gt;这场示威的焦点在哪儿呢？政府发布的命令里，对行割礼的条件做了限制：无菌的手术环境，“尽量不痛”，还需得到家长的一致同意。不论犹太人还是穆斯林，都认为他们的宗教自由因此受到了侵犯。为了捍卫信仰的独立地位，示威者走上街头。&lt;/p&gt;
&lt;p&gt;除了宗教原因，还有健康和人权因素卷入争论。割不割包皮对男性健康的影响孰优孰劣，尚无定论。但如果手术的卫生水平不达标，伤口感染的危险不容小视。(政府的法令，明显是从保障安全的角度出发。)&lt;/p&gt;
&lt;p&gt;人权主义者的观点又不同。他们认为，在婴儿无法反对的情况下为其手术，无疑剥夺了他们选择的权利。应该等到他们自己有能力思考时，让他们决定手术做还是不做。&lt;/p&gt;
&lt;p&gt;三方面都有自己的立场。现有局面的任何一点前进或后退，都立马能掀起一场大浪。这也是西方社会运作的一个缩影：各方势力通过不断斗争制约，而达到一个动态平衡。&lt;/p&gt;</description></item><item><title>板荡里的两代人——读《白鹿原》</title><link>https://blog.yuantops.com/opinions/two-generations-in-the-age-of-turbulence/</link><pubDate>Sun, 21 Oct 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/two-generations-in-the-age-of-turbulence/</guid><description>&lt;p&gt;近来《白鹿原》被拍成电影，宣传铺天盖地，走在大街上都能听到人议论。一部文学作品突然走红，往往是借了商业或娱乐的东风。这也勾起了我的兴趣，于是翻出书看了一遍。&lt;/p&gt;
&lt;p&gt;之前我看过陈忠实的其他几部短篇，对他笔下的黄土风情略有了解。这部蜚声文坛的《白鹿原》，的确了得，可以算作他的巅峰之作。叙事恢弘，时间跨度从晚清到红朝，基本涵盖一部中国近代史；书中白家和鹿家两个家族的诸多人物，线索繁多，被时代大浪裹挟，编织个人的家族的喜怒悲情。&lt;/p&gt;
&lt;p&gt;黄土高原上有一个白鹿原，原上有一个白鹿庄，生活着白家和鹿家两个家族，共祭一个祠堂。久远的岁月里，两家的祖先原本是兄弟。一场天灾后，原上出现了白鹿的精灵。于是兄弟俩决定改姓，求白鹿的庇佑。老大一支改姓白，老二一支改姓鹿，白家长子为族长。到了族长白嘉轩这一代，已是清末，老气沉沉的王朝一息尚存。全书的情节，就在白嘉轩的发家，他三个儿子和一个女儿的长大，鹿家鹿子霖和他两个儿子的作为中展开。全书的结局在解放后不久，以鹿子霖的疯死为止。&lt;/p&gt;
&lt;p&gt;书中出场的人物众多：族长白嘉轩，鹿家鹿子霖，大儒朱先生，长工鹿三，白家长子白孝文、三女白灵，鹿家的两个儿子鹿兆鹏、鹿兆海，鹿三之子黑娃，女子田小娥……每一个人物的形象都很生动，而其中给我留下最深印象的，是白嘉轩和朱先生。&lt;/p&gt;
&lt;p&gt;如果借用政治课里的术语做描述，白嘉轩可以算作“封建势力的顽固代表”。书的开头，他连着娶了七个老婆，描写了七次他的洞房之夜。当年的我，看到这些泛黄镜头可是有点儿羞涩。他在父亲死后继承了白鹿两家的族长身份，十分忠诚地履行自己族长的使命。他的人生观，是最传统的士人价值观：视宗法道德为天，勤俭持家，不苟言笑。年少的黑娃说，叔的腰“挺得太直太硬”，让他感到不舒服。他的能力超群，但一幅铁石心肠，在祠堂里用枣条鞭笞有伤风化的族人，废掉已经担起族长责任的长子，甚至听任长媳在饥年活活饿死。在人生的各种境遇里，他一次次验证了自己处事原则的正确性，愈发笃信笃行，直到最后。&lt;/p&gt;
&lt;p&gt;白嘉轩的人生信条，显然无法轻易用“封建”或“腐朽”简单概括。我们曾无数次在政治和历史课上批评宗法制度的惨无人道，封建道德的陈腐老旧，但从白嘉轩的故事看，这些指责未免显得苍白片面。在过去，家族作为社会的基本组织单元，保障了几千年的文明传承。在这一物质基础上形成的制度和道德，在其所属的土地上的意义是值得去体会的。&lt;/p&gt;
&lt;p&gt;朱先生，作为神一样的存在，是陈忠实笔下完美传统道德的化身。他不像是曾在现实中存在过的人，更像是三国里的诸葛孔明。他神机妙算，只身劝退二十万清军，犁毁鸦片田，住持赈灾，立志投笔从戎，编撰县志，在死后也留下圈套。塑造这样一个完美的关中大儒，陈忠实事实上倾注了自己的希望。朱先生的葬礼，是全书十分感人的部分。从白鹿书院移灵到朱家村，沿路百姓自发出来送行，五十里的路上挤满了悲伤和不舍的人，烛火香纸形成溪流。（似乎能从中看到十里长街送总理的影子。）传统中能否孕育开明的有识之士，他给出了肯定的回答。朱先生曾预言，“天下必定是朱毛的。”但之后的情形，“得了天下以后会怎样，还得看。”这样的圣人毕竟死了。&lt;/p&gt;
&lt;p&gt;百灵是死在党内斗争里的无辜人。残酷无情的政治，夺走了这个正直热情、白鹿精灵一样的女子的生命。&lt;/p&gt;
&lt;p&gt;黑娃是死在阶级斗争里的无辜人。他的一生跌宕起伏，即使最终幡然悔悟，也难逃暗算。无论哪个政权，都包藏了无数的野心家，都滴着纯粹鲜红的热血。&lt;/p&gt;
&lt;p&gt;这部书胜在它的大格局，陈忠实如何通过写笔下各色的人，重现时代的冲撞。不止有传统与革命的冲突，个人与家族的冲突，共产主义与三民主义的冲突，甚至有红党自身内部的路线冲突。能在一部作品里展现如此多的波澜，实属不易。书中白鹿两家真正唱主角的有两代人，每一个人的出场和谢幕，都带着鲜明的色彩，最终的命运亦得到读者的感慨。对过去时代的理解，通过这部书能得到更深刻直观的印证。这是一部民族作品，也许只有中国读者才能真正读出其中滋味。&lt;/p&gt;</description></item><item><title>木月之死</title><link>https://blog.yuantops.com/opinions/the-death-of-kizuki/</link><pubDate>Mon, 08 Oct 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/the-death-of-kizuki/</guid><description>&lt;p&gt;木月死了。木月永远以十七岁的年龄活在这个世界。他的死亡延续了他的生命。&lt;/p&gt;
&lt;p&gt;村上春树的《挪威的森林》，木月是未出场的主角，他的死亡被渡边无数次想起，并深深地影响了直子的人生。他不是书中唯一自杀的人，直子的姐姐，直子，初美，他们都选择了生命的另一种形式。青春的迷惘、惶然和不知所措，让他们于平静安详的决定中关上生命的大门。&lt;/p&gt;
&lt;p&gt;《挪威的森林》里，木月是第一个选择结束自己生命的人。一个晚上，他和朋友渡边玩了一盘桌球，然后毫无征兆地离开。生命，定格在17岁。整本小说里，虽然他没有正式出场，但凭借着他的死亡，他是当之无愧的主角。为什么他选择了生的另一面，而非生命本身，已经无从得知了。唯有在他生前的伙伴心中，他的形象长久持续地存在。&lt;/p&gt;
&lt;p&gt;直子说，他们两人的关系不寻常。既是朋友，又是恋人，对方像是自己灵魂的一部分。封闭自足的二人世界，伴随着时间，构成了他们生活的全部——甚至成了阻止他们与真实世界沟通的壳。&lt;/p&gt;
&lt;p&gt;一边与小世界的温暖割舍不开，一边焦虑不已地想融入现实。像是从海底转移到陆地，又急切又不得要领，还要若无其事的装作镇定。混乱的状态，一团浓墨般地卷住了他们。&lt;/p&gt;
&lt;p&gt;渡边存在的意义也就不难理解了。木月希望以他作为接触现实的链条，以维持他和直子所存在的世界的平衡。靠着微妙的角度，放些许白色阳光进来。&lt;/p&gt;
&lt;p&gt;这个世界的混乱到了何等地步，不知道。但最终，木月选择了死亡。伴着混沌嘈杂，他迈出的一步不是向前，而是退后。无边的黑暗，成了木月的归宿。&lt;/p&gt;
&lt;p&gt;死和生不是处于对立面的两个事物，生蕴含了死，死延续了生。渡边君从木月的死中学会这个道理。但对于彼时彼境的当事人，立志赴死前，难保有如此感悟。&lt;/p&gt;
&lt;p&gt;一旦在人生路上迷路，谁知道会怎样？村上试图展示的，是一个关于“混乱”的话题。这样的人生状态，你我都曾遇到，无人能避免。在无尽的森林中，如何向前走下去。木月的选择，他的死亡，是退后的结局。&lt;/p&gt;</description></item><item><title>黄土作家陈忠实</title><link>https://blog.yuantops.com/opinions/chenzhongshi-the-loess-writer/</link><pubDate>Sat, 08 Sep 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/chenzhongshi-the-loess-writer/</guid><description>&lt;p&gt;这几天看完了陈忠实的几篇中篇小说，尤以《梆子老太》《蓝袍先生》两篇给我留下的印象最深。&lt;/p&gt;
&lt;p&gt;《梆子老太》是一篇人物传记。一个脸长得像梆子的媳妇嫁给了梆子井村里一个老实人，但她不能生育，在受到各种歧视后，养成了一种“盼人穷”的怪心理。政治运动来了，这位受到各种冷眼的苦媳妇翻了身，被推为“典型”“模范”，在运动中积极表现，把村里的人几乎得罪了个遍而不觉有错。形势变了，运动冷淡下来，她又成了人人厌恶的“梆子老太”，甚至死后连帮忙抬棺材的人都没有。&lt;/p&gt;
&lt;p&gt;《蓝袍先生》是一个人的回忆录。主人公是一个书香门第的继承人，自小受父亲和祖父严格的礼教和道德训诫，在十八岁时穿上蓝袍，接受父亲为他定下的亲事，接掌父亲的教席。他被禁锢在了套子里。解放后进入师范进修，真正找到自己的爱情。想离婚，父亲不允许，以死相逼，终究告吹。在接下来的运动中他受到冲击，被划归为中右派，卑声低气地生活。最后被平反了，但他已经彻底被锁在过去，无法回来。&lt;/p&gt;
&lt;p&gt;陈忠实以一部《白鹿原》名震文坛。当年坐在新华书店的地上翻看《白鹿原》的我，还没到能欣赏这部作品的境界，看开头那些荤场面看得面红耳赤，像在偷偷做什么坏事。这部书当时没看完，现在又借不着，真遗憾。但根据最近的阅读，陈忠实的风格是明显而且一贯的，他是确确实实的黄土作家。&lt;/p&gt;
&lt;p&gt;中国当代文坛的作家，从黄土高原走出来的真不算少。贾平凹，还有已经去世的路遥，都是其中佼佼者。我很喜欢路遥的《平凡的世界》，也很喜欢贾平凹的西安韵味，最近因为《蓝袍先生》喜欢上了陈忠实。黄土作家的特点：题材上写古老的关中农村，写传统的家族纠葛，写革命和现代化冲击下的风俗转变，写时代潮流中汉子和女子的作为，主题上赞美醇厚朴实、勤恳忠义的黄土精神。&lt;/p&gt;
&lt;p&gt;中国的文明从黄河发源，关中平原上的西安是十三朝古都。这块地方的一草一木都有历史，所以显得厚重。这一方水土上的作家，深深烙印下了地域的特色。这份端庄凝重的气度，别处的作家也学不来。&lt;/p&gt;</description></item><item><title>who is afraid of Huawei</title><link>https://blog.yuantops.com/opinions/who-is-afaid-of-huawei/</link><pubDate>Sun, 12 Aug 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/who-is-afaid-of-huawei/</guid><description>&lt;p&gt;The Economist 的八月四号刊中，专题报道了中国的华为。封面标题是本文的标题，“谁在害怕华为？”。这是个很不错的话题。&lt;/p&gt;
&lt;p&gt;华为是中国新兴企业的代表。这个公司在八十年代成立，到今天不过三十多年，就从一个名不见经传的小企业发展成有十几万雇员、遍布全球的通信业巨型企业，营业额甚至一度超过了爱立信。外国人眼中的中国企业印象，不外乎抄袭、山寨、劣质，但华为不同，它走的是高科技道路，不是靠苦力挣钱，而且产品性价比高。华为在高新产业内站稳了脚跟，为新一代的中国企业树立了标杆。&lt;/p&gt;
&lt;p&gt;华为发家时的战略，《经济学人》提到，受到了毛泽东“农村包围城市”（to use countryside to encircle and finally capture cities）思想的影响。文章中没有提及华为独特的企业文化—加班文化，和它对员工脑力和体力的残酷压榨。华为的金字塔，塔基是无数基层员工的血汗和智慧铸成的。&lt;/p&gt;
&lt;p&gt;华为受到西方猜忌，主要因为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;任正非早年的军队背景，使华为蒙上一层神秘色彩；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;担心华为的设备或代码有“后门”，在关键时刻（如战争状态）会倒戈帮助中方控制网络；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;怀疑中国政府在背后大力扶持华为，违背商业竞争规则；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;华为的经营结构和权力体系始终不公开透明，外人难知底细。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基于这些原因，美英等西方政府对华为怀着戒备，不肯选择明显它来铺设国内的通信网。华为为了证明自己的设备和代码没有安装后门，花大力气请公关游说政府人士，还主动和国际检测组织合作来自证清白，但收效甚微。&lt;/p&gt;
&lt;p&gt;与其说是怕华为，不如说是怕中国。中国越强大，威胁就越大，因此捕风捉影的事情也越有市场。中国企业的特点，或者说华为的特点，在于韧性和坚持。所以，那就坚持吧，只要外国对中国的观点不变，那么对华为的猜忌永远不会停。希望华为望能坚持到那一天。&lt;/p&gt;</description></item><item><title>七月七日长生殿——读《长恨传》</title><link>https://blog.yuantops.com/opinions/story-of-song-of-eternal-sorrow/</link><pubDate>Sun, 29 Jul 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/story-of-song-of-eternal-sorrow/</guid><description>&lt;p&gt;杨贵妃是历史上的四大美女之一。她和唐明皇的爱情故事，通过白居易的一首《长恨歌》千古流传，让无数人为之心折。&lt;/p&gt;
&lt;p&gt;最近看唐人笔记《酉阳杂俎》，里面专门录有杨贵妃的故事，十分详尽。在图书馆借的一本唐人传奇，鲁迅当年校录的，里面收录了陈鸿撰的《长恨传》，语言传神，再次重温，同样感到触动。&lt;/p&gt;
&lt;p&gt;不同版本的杨贵妃和唐明皇故事，情节丰富程度不同。虽然细节处的渲染有差异，但整个故事的高潮却始终相同。唐明皇在马嵬坡赐死贵妃之后，陷入无比的伤悲中。这篇传记里，描写明皇的落魄神伤，很精彩。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时移事去，乐尽悲来。每至春之日，冬之夜，池莲夏开，宫槐秋落，梨园弟子，玉琯发音，闻《霓裳羽衣》一声，则天颜不殆，左右欷歔。三载一意，其念不衰。求之梦魂，杳不能得。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是唐明皇托人寻找贵妃的魂魄，终于方士找到了杨真人。玉环托他带去金钗，作为信物，并回忆当年故事。这里就是整个故事的最巅峰，最打动人之处。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;玉妃茫然退立，若有所思，徐而言曰：“昔天宝十载，侍辇避暑于骊山宫。秋七月，牵牛织女相见之夕，秦人风俗，是夜张锦绣，陈饮食，树瓜华，焚香于庭，号为‘乞巧’。宫掖间尤尚之。&lt;/p&gt;
&lt;p&gt;时夜殆半，休侍卫于东西厢，独侍上。上凭肩而立，因仰天感牛女事，密相誓心，愿世世为夫妇。言毕，执手各呜咽。此独君王知之耳。”因自悲曰：“由此一念，又不得居此。复堕下界，且结后缘。或为天，或为人，决再相见，好合如旧。”因言：“太上皇亦不久人间，幸惟自安，无自苦耳。”使者还奏太上皇，皇心震悼，日日不豫。其年夏四月，南宫晏驾。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想想当时的场景吧！光阴流转，一个人在回忆当年的恩爱。七夕夜里，他们两人曾经一起发誓，愿生生世世结为夫妇。穿越了时间的隧道，重温旧好，长生殿里的温柔情话，多么心伤。果真连读者也要为之“呜咽”了。&lt;/p&gt;
&lt;p&gt;爱情故事，悲剧结局会留下无限回味的空间。浪漫的帝王家的故事，痴情感人的生离死别，在时间和空间都无法企及。正如白乐天所云，“天长地久有时尽，此恨绵绵无绝期”。&lt;/p&gt;</description></item><item><title>英伦风情的奥运会</title><link>https://blog.yuantops.com/opinions/the-opening-ceremony-of-london-olympics/</link><pubDate>Sun, 29 Jul 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/the-opening-ceremony-of-london-olympics/</guid><description>&lt;p&gt;凌晨早起看奥运开幕式，见识了一把英伦风情。英国人的心态和我们当真不同，从开幕式就看出来了。&lt;/p&gt;
&lt;p&gt;伦敦奥运会，全过程视频不断。视频固然精彩，但好歹是堂堂的奥运会开幕式现场，用这种取巧的方法让人觉得不太厚道。从开始的牛羊聚会展现出的田园风情，到工业革命时竖起几根“硕大”无比的烟囱，之后信息时代里一对恋人通过互联网邂逅相爱，整个过程显得十分随意。慢悠悠不慌忙，没有架子，完全没有当年北京奥运会的那种磅礴气势。&lt;/p&gt;
&lt;p&gt;老牌的日不落帝国，经历了几个世纪的风雨，已经锻炼出了优雅从容的气派。虽然没有当年的辉煌，但老旧的派头还保持地蛮好，赏心悦目的——所谓心态好。大不列颠帝国，有值得骄傲的文化符号。憨豆先生出场，顶着灰白色的头发在现场插科打诨，全世界的观众都会心一笑。罗琳女士一出现，全世界的哈利波特迷都很激动。还有007和英女王，都是通行全世界的名片。所以，看伦敦奥运会开幕式，重头戏出来的人物，和想表达的意思，不用解释大家就能明白。最后的压轴戏，是甲壳虫乐队的经典曲目《hey,jude》，更引得全场合唱，迎来高潮。如此广泛深刻的文化影响，也难怪他们可以举重若轻，敢于向世界展示乱糟糟的舞台了。&lt;/p&gt;
&lt;p&gt;中国不同。中国是暴发户，历史的包袱和渴望证明自己的心情，造就了一场技术无与伦比、内容澎湃大气的豪华开幕式。我们擅长集体表现，讲究整体与个人的协调。张导的北京奥运，主题十分鲜明，就为了告诉世界人民我们灿烂辉煌的历史，和我们对时代的期望。毕竟我们缺席了世界文明史的现代化进程，近代的内容乏善可呈。中国人不缺人，那么用团体的展示来告诉世界我们的想法，通过整齐严谨的表演，带来震撼的体验。事实上，北京奥运会开幕式所表现的高水准，没人能否认。这是中国特色的成功。&lt;/p&gt;
&lt;p&gt;“参差多态乃是幸福本源”，罗素的话说得很对。中国有一套方式做事情，西方国家有另一套方式。两者孰优孰劣，本无法比较。从不同角度看，两者都是精彩的。赞美一方，也不一定非得诋毁另一方；相应的，诋毁一方，也并不能达到赞美的效果。&lt;/p&gt;
&lt;p&gt;灿烂的北京奥运会证明了我们的能力，我们可以做成大事，由此带来的自豪感，不是一点金钱可以替代的。但相比之下我们更需要学习，学习如何让自己变得更从容，更不卑不亢，学习如何关心更重要的民生话题。只有真正把国内的事情摆在首位，让人民满意了，才能在国际上摆正心态，不怕人挑刺。&lt;/p&gt;
&lt;p&gt;我们在不断进步，只是有时稍嫌这些步子慢了一些。什么时候我们也能拥有像英国的憨豆和007一样具有国际影响力的文化符号呢？那时我们的奥运会开幕式，就不必再把老祖宗的古董拿出来炫耀了。&lt;/p&gt;</description></item><item><title>98年的洪水记忆</title><link>https://blog.yuantops.com/life/memory-of-the-flood-in-1998/</link><pubDate>Wed, 25 Jul 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/life/memory-of-the-flood-in-1998/</guid><description>&lt;p&gt;最近北京暴雨，造成惨重的人员伤亡，由此引发了社会上对防汛和水灾的热烈讨论。多少年了，类似这样大规模的公众担忧再次出现，在互联网时代显得格外热闹。水灾其实离我们很近。长江黄河历史上都是影响国家稳定的重要因素，决堤倒口造成的流离失所和苦难，几乎是每代人都能经历的。&lt;/p&gt;
&lt;p&gt;我家在长江边上的江汉平原，属于“荆江分洪区”内。所谓“荆江分洪区”，是个近代概念。建国后，当时的领导打算治理长江水患，于是在“万里长江，险在荆江”的荆江流域，划出一块地方作缓冲区，在其四周新建一道堤，提前埋好炸药。当荆江大堤不能抗住大水时，为了保住江汉平原和大城市武汉的安全，就炸开新堤把江水泄出来。生活在这地方的八十多万人，是某种意义上的“牺牲品”。万幸分洪区建立后，只在竣工后第二年(1954年)唯一启用过一次。三峡修成前，每逢汛期，其间百姓的提心吊胆都比别处更甚。&lt;/p&gt;
&lt;p&gt;对水灾最深刻的记忆，是98年的洪水。当时我还是小孩子，夏天暑假一帮堂姐在姑姑家玩。一天晚上在睡梦中，感觉外面格外吵闹。睁开眼睛，迷迷糊糊地看到大人们翻箱倒柜，打包东西后往楼顶的天台搬。醒后我摸着上到楼顶的天台。不大的面积上挤满了各种家具箱子，还不住有人往上搬。这幢小楼一共6层，每户都可以占到一小块地方。天黑极了，手电的光晃来晃去。听大人们说话，才知道镇里某处大堤溃口了，水马上要淹过来，所以得提前做好转移。&lt;/p&gt;
&lt;p&gt;之后，姑姑领着我和表弟，穿过冷清的街道去堤面。现在只能记起来，那天夜里似乎还有点凉，姑姑给我穿上了她的一件外套，显得很大。堤面上也到处是人。然后就迷迷糊糊不知发生了什么。&lt;/p&gt;
&lt;p&gt;第二天，从家里赶过来找我们的爸妈还有叔叔，在一辆汽车下找到了还在睡觉的我们。他们听到这里溃堤，怕我们有什么闪失，着急得不行，心急如焚地赶过来。叫醒我们，我们都一脸茫然，倒是他们十分激动。家长们带着我们回家。我坐在自行车后座上，一路沿着堤面走。昨天晚上不知不觉，到了白天才真正知道什么叫“溃堤”。堤面上已经密密麻麻地挤满疏散的人家，摆满了各种生活用品。整个搬上来的床，蜂窝煤炉，衣柜，锅碗瓢盆，桌子，米袋，农具……各种乱七八糟的东西。没法骑车，得一路从人堆和杂物中拣着空隙走。堤的一边，河里的大水浑黄浑黄的，另一边，水已经过来了，放眼望去黄茫茫的一片，农田当然不见了，房子小半截泡在水中。天上有直升飞机，盘旋在低空往下投食品和救生衣。整幅景象，各种慌乱和无序，还有那些空房子的荒凉，诸般接近战乱流离的画面，是以后我再也没有见过的。&lt;/p&gt;
&lt;p&gt;回到家，同样是各种逃难的准备。家出门就是大堤，万一出事逃到高处的堤岸最方便不过。那段时间，家里堆满了各种箱子，是各种亲戚存的。隔壁有的家里，亲戚的小孩直接住进来。爸爸不在家，去别村防汛。别村来的防汛队查看堤坡的草坪，查渗水查漏水，一天好几回。晚上更热闹，防汛的人挑着马灯走来走去，换班下来的人在外面乘凉。多了这么陌生人，夜晚歇在当地人家，像过节一样。&lt;/p&gt;
&lt;p&gt;每天人们关心的话题是，今天水是涨是退？水位最疯狂的时候，站在堤面上直接可以在河水里洗脚。每天顺流而下各种杂物，据说有人看到过死人尸体。浩荡的河水使河面变得格外壮阔，真有杜甫诗中“江平两岸阔”的意思。即使只是长江的一条小支流，即已如此可观，何况烟波浩瀚的长江？&lt;/p&gt;
&lt;p&gt;人在敏感的时候，一点风吹草动就能翻江倒海。某天，有消息说远处溃堤了。一传十，十传百，接二连三地所有人都行动起来，全家老小出动转移财产。现场之混乱，人声之鼎沸，让人叹为观止。到了中午，搬得差不多了，却连水影子也见不着。燥热的盛夏中午，大家一身臭汗，打开电视才知道，是一个疯子乱喊，结果全镇都被感染，弄得一场乌龙。&lt;/p&gt;
&lt;p&gt;以后在高中的图书馆看到一本关于抗洪的书，才知道当年荆江分洪区险些真的再次发挥作用。当时坐镇前线的是温，时任国务院办公厅主任，他掌握分洪决定权。荆江大堤的水位达到可承受的极限值，最高洪峰来临，炸药都已经完全准备妥当，引爆的各种工作都到位，临近居民也通知疏散。但他犹豫再三终于没有下令。结果洪峰顺利通过，分洪区内几十万居民得以免受祸乱。&lt;/p&gt;
&lt;p&gt;直到夏天过去，洪水也没有来。有大批解放JUN投入抗洪救灾，他们作风过硬，纪律严明，真可谓是子弟兵，深受爱戴。镇上的初中就有Jun队入驻，等我上初中时老师回忆起来还盛赞他们，说他们每天都主动把校园扫得一尘不染。当时有个抗洪战士是本地人，牺牲了，全国都纪念他。他叫李向群，县里甚至用他名字命名了一所高中。98年多亏他们。&lt;/p&gt;
&lt;p&gt;当年的记忆，十分模糊，像一团连不起来的影子。但那种不安和乱象，却实实在在的留下印象。三峡之后，夏天的水再也没有那么猖狂过。但据说今年的水势又十分吓人。希望一切都不要发生，分洪区永远不要发挥作用，什么都平平安安的。&lt;/p&gt;</description></item><item><title>《戏梦人生》</title><link>https://blog.yuantops.com/opinions/the-puppet-master/</link><pubDate>Thu, 19 Jul 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/the-puppet-master/</guid><description>&lt;p&gt;候导的《戏梦人生》，是一部自传性质的电影。虽然相当于一部纪录片，但其艺术水准丝毫不差。&lt;/p&gt;
&lt;p&gt;李天禄老人是台湾的国宝级布袋艺术大师。他于日据时代出生，很小就跟着父亲学习家传手艺。母亲去世后，继母刻薄，他很小就跟着剧团演出闯荡。他之后入赘剧团团长家。此后抗战爆发，布袋戏被禁，他转战台北出演哥仔剧，结识了女朋友丽珠。布袋戏解禁，他的剧团与时俱进上演了一些日军宣传剧，和日本人有了不错交情。一家人逃避空袭到南部，失去了两个亲人，自己也染上疟疾，而事实上日军第二天就投降了。&lt;/p&gt;
&lt;p&gt;李天禄老人在《恋恋风尘》中也曾出演。那个睿智的祖父，是这部剧的旁白口述者，也是主人公原型。其实《戏梦人生》，可以看做《恋恋风尘》的前传篇，是普通台湾人在不同时代的故事（编剧也都是吴念真）。老人的一生颠沛流离，闽南语娓娓道来，平静淡泊。&lt;/p&gt;
&lt;p&gt;电影有几段很长的布袋戏。候导似乎很喜欢通过电影做记录工作，记录风景和迷人的台湾本土文化。一段是《白蛇传》里许仙和青白娘子在杭州钱塘江相遇，一段是改编后的日军洗脑宣传剧。后者值得一说。一个台湾人向日军保证，他作为第二帝国国民，一定会为大日本帝国尽忠。他独自英勇地爬上山峰据点，摧毁了敌军（即国军）的通信线路，结果被国军发现乱枪射死了。日军作为螳螂后的黄雀，又射死了这些国军。日本军人抱着奄奄一息的“勇士”，安慰他。勇士表示，他为天皇尽忠，死而光荣。最后，小戏台上升起了太阳旗，日本军人向他致敬。&lt;/p&gt;
&lt;p&gt;这部日军宣传剧，是在一个葬礼上演出的。葬礼的死者，几乎就是剧中主角的翻版。葬礼很隆重，升着太阳旗。日本人在台湾五十年，半个世纪的皇民教育，其影响不是转眼能消除的。以前是被清廷遗弃的岛民，之后被教育是日本的国民，光复后又被告诉自己是“中国人”。所以之后的二二八惨案，在于台湾人对自己身份认同的迷茫的丧失，彼此的不信任撕裂了和平。而惨案本身，又加剧了这种不信任。从李天禄老人的一生，能看出这些关系角色转换的纠葛。台湾的历史，毕竟和大陆不同，尤其在对待日本的态度上。&lt;/p&gt;
&lt;p&gt;候导的电影是真正本土化的台湾电影。毫无疑问，也是了不起的华人电影。&lt;/p&gt;</description></item><item><title>《海上花》</title><link>https://blog.yuantops.com/opinions/flowers-of-shanghai/</link><pubDate>Thu, 19 Jul 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/flowers-of-shanghai/</guid><description>&lt;p&gt;侯孝贤电影专场，今天上午连续放映《海上花》和《戏梦人生》。两部电影的长镜头，几乎达到令人发指的地步。一如既往的沉缓风格，气氛压抑。&lt;/p&gt;
&lt;p&gt;《海上花》曾经由张爱玲改编，拍成电影时又经编剧朱天文裁剪。片中人物几乎都用上海话对白，场景全在昏暗的妓院室内，不见天光，整部片子的色彩都是煤油灯下的暗黄色。真把张爱玲笔下的上海滩世界拍的生灵活现。&lt;/p&gt;
&lt;p&gt;开场的饭局，酒客先是猜拳，后来戏谑一对情人。就记得洪老爷一直在劝大家“口契 老酒”。&lt;/p&gt;
&lt;p&gt;刘嘉玲扮的周双珠，通达人情，淡薄超然，处事平坦公正；李嘉欣扮的黄翠凤，精明泼辣，性格火爆，很有打算，是戏中最西洋化的人物；还有日本女星羽田美智子扮演的沈小红，左右逢源，举棋不定，最后被甩后也还能风度依旧。梁朝伟的上海话说得很别扭，还是说起广东话来流畅爽快，演的阔公子稍显懦弱，跟本身的气质很相符。洪老爷是最出彩的人物，圆滑庸俗，人情练达，做事得体，而且一口上海话说起来很利索。片子如果少了他，上海味就淡了不少。&lt;/p&gt;
&lt;p&gt;虽然都是风流场中的妓女，人物的性格计较却分得清楚。不顾世俗礼节的束缚，男女间的勾心斗角显得肆无忌惮，因而也更率真热烈。如果不是事后看剧评解说，里面的很多机巧都不能领悟。张蕙贞被沈小红率众打后，在王老板面前不露声色，只是貌似不经意一句话，提醒沈小红可能有鬼。王老板再问，她也不肯多说了。王老板认为她“是个戆大，沈小红说了你多少坏话，你倒替她瞒着”，其实早已中了人家的套。之后疑心之下，果然被他发现沈小红姘了个戏子，两人闹翻。&lt;/p&gt;
&lt;p&gt;双玉被骗，拖着五少爷喝鸦片酒，又哭又闹。其实在小说中，鸦片酒是假酒。双玉极有心机，从发现被骗到想出这个法子，既保全自己贞洁刚烈的名声，又给自己个台阶下，还挣了讨价还价的本钱，真是心思缜密。&lt;/p&gt;
&lt;p&gt;电影展现了旧上海的风月场声色。从服装到首饰，从器物到酒局，从谈吐到行为，都是晚清风格。女子的清装，和油灯下的鸦片烟，细节处都很精心，使一股老旧味铺面而来。&lt;/p&gt;
&lt;p&gt;最后值得一提的是配乐。当然了，侯孝贤的配乐一直都很精彩。本部电影由半野喜弘配乐。每组人物的配乐都相对固定，且彼此不同，搭配性格和场景发展恰到好处。音乐烘托得片子更幽深，更暗淡。&lt;/p&gt;
&lt;p&gt;若有若无的灯光，幽深诡异的音乐，加上超长的镜头、缓慢的节奏，还是很容易使人入睡的。&lt;/p&gt;</description></item><item><title>她的故事</title><link>https://blog.yuantops.com/opinions/her-story/</link><pubDate>Tue, 19 Jun 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/her-story/</guid><description>&lt;p&gt;##一 开始&lt;/p&gt;
&lt;p&gt;午后，穿堂风吹过教室旁的走道，白色的阳光刺人眼睛。简陋的教室里传来读书声，狭小的校园格外静。我等下一节课开始，给二年级的孩子带一节英语课。时间尚早，我要找个地方坐下躲避日光。&lt;/p&gt;
&lt;p&gt;走道里坐着两个人，她们谈着什么。我走近，向她们摆摆手，在稍远点的椅子上坐下。她们一个是学校的老师，一个似乎是学者——她们礼貌性地点头，继而转过头接着说话。我戴上耳机，说话声音仍然飘进我的耳朵。&lt;/p&gt;
&lt;p&gt;女老师正在说她的故事。她说话很慢，纵使不想听，每一句也清楚听到。热浪和学生读书声，混杂着老师缓缓的叙述，耳边听到的歌曲声，一切模糊在一起，让我身处梦境。&lt;/p&gt;
&lt;p&gt;##二 镜中月&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 你问我们学校里这些个女孩子和男孩子懂不懂谈恋爱？我看不懂。他们现在只知道疯玩，哪儿想到这么多。虽说你调查过，小孩子从小学五年级开始懵懵懂懂知道那么一点儿，那他们肯定是瞎玩儿凑热闹。我肯定，起码我班上的学生是没谈恋爱的。
你问我读书时什么时候开始有这个意识，有没有谈过恋爱。嗯，这我还不好说，得想想。好久以前的事情了。有的。不过不是我喜欢别人，是班上一个男生喜欢我。我一直不知道，也是好多年后才从别人那儿听说。
我老家是湖北的，湖北一个小地方。喜欢我的那个男生，和我初中一个班。当时我不知道他喜欢我，现在回想起来，他在班上太普通太普通，我没一点印象。也记不起来他对我有过什么表示。小男生嘛，脸皮薄，也许不好意思说。我一直也不知道。初中毕业了，我考上高中，继续上学，他没考上，不读书了。
不再见面了吧，他三天两头往我家里跑，帮我家里做这做那。我们那儿很老传统，他这样做大家都晓得为什么。我妈呢，看不上他，加上性子差，脾气不好，直接不客气说了他一顿。自那以后，他也不来我家了。那时我在上学，我妈什么都瞒着我。
这样我跟他两不相见好多年。后来我毕业，大学没念上，出去打工。他留在家里。你知道，农村里结婚是很要紧的大事。在城市里三十多四十多单身的多得很，但在农村是很丢脸的。他家里催着他结了婚。他和他妻子一起奋斗，在镇上买了房，后来又买车，生孩子。在普通人眼里，他是成功了，什么都有，样样齐全。
一次我回家，看以前初中的好姐妹，她跟我说起他。她说，那时候他那么喜欢你，转眼现在都结婚有孩子了。我很奇怪，因为我是第一次知道他以前喜欢我。我仔细想，还是连他的样子也想不起来。姐妹不相信我居然一直不知道。我自己也觉得不可思议，毕竟被人喜欢是一件好事，自己竟全然被蒙在鼓里。回家问我妈，才知道所有的事情。对我来说，我只是知道了以前读书时的一件小事，对过去的少女时代多一份自豪和浪漫色彩。我妈又告诉我，他的家不太平，和老婆天天吵架打架。
我大了，他也大了。过去的事即使现在知道了，不过是增加一些青涩回忆。
至于我，马上就要说到了。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##三 爱别离&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 我打工时喜欢上了一个人。他是河南的，一米八的个子，长得很高很帅。单只是跟他站在一起，我就说不出欢喜，觉得很有安全感，面子上有光。你不要笑话，我是一个浪漫的人，喜欢长得标致的人。他对我也很好，我们两个想结婚。我带他回家见我爸妈，他们不同意。你要知道，我们那儿对河南人多少带点偏见。河南人多，他老家比我们这儿穷，条件差。我和他结婚，得住到河南。我爸妈就我和我姐，没有儿子，他们舍不得我，不想让我吃苦。
我能怎么办？我那时年轻，和他感情又好得不得了，就狠下心离开父母和他结了婚。河南的农村不如我们那儿，他家又比当地一般水平低。条件真的不好，我过得很不习惯。但是路是我自己选的，我们俩感情好，我跟着他，什么都顾不上。我每天都很开心。我们有了一个孩子，男孩儿。现在念小学，聪明绝顶，长得跟他爸一个样。我一看到他就想起他爸爸。
是的，我现在没丈夫了。他出去打工——具体做什么我不清楚，好像在建筑工地工作——在一次事故中死了。一个不知道什么东西打中他，送到医院后走的。一个活生生的人走了，我和我们的儿子留在世界上。我还得生活，就带着儿子来到北京找机会。我换过很多工作，最后才在这所小学暂时安定下来。
我的小孩子，他现在读五年级，脑瓜儿好用，就是玩性大，心思不在学习上。我将来还得花大力气好好带他。
你不要同情我，我不是那种惨兮兮以泪洗面的人。生活就是这样的。你看，我如果不说我的故事，你眼里我就是再正常不过的普通人。我不喜欢别人用一种特别的带怜悯的眼神看我。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##四 求不得&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 丈夫不在了，我也不回河南过年，我回湖北的老家。我爸妈还在，我跟他们一起。过年嘛，就是大家扯扯闲话，村里谁谁又如何如何了诸如此类。以前喜欢我的那个男生，据说他和老婆越吵越厉害。我知道，村里人肯定也谈论我的事。
过完年我回北京。一天我手机响，是一个湖北的陌生号码。真奇怪，我一下子就想到是他。我心里雪亮，料到他想说什么。果然是他，说的话和我想的丝毫不差。他跟我说，他听说了我的事，知道我现在一个人，带个小孩子。他日子过得不开心，和老婆说不上两句话就吵架，没人理解他，很憋屈。他说，他以前就喜欢我，现在喜欢我更胜从前。他愿意离婚，什么都不要，和我一起过，他肯定待我儿子跟亲儿子一样。我一口回绝了他。
你应该也支持我的做法吧！我相信他是真诚的，没有同我说谎。但我已经不是初中时他所知道的女生了。他以前就没有真正了解我，我也不了解他。过了这么多年，他对我的一份感情还停留在当年的年少冲动。要是他真的和我相处一段时间，肯定会失望我不是他想的那样。男人就是这样，对得不到的东西想得不行，一旦得到就会冷淡。我比他冷静，我知道这些。还有，他不是我喜欢的类型。我甚至回想不起他初中时是什么样子，他不出众。我是爱好浪漫的，我的感情全给了我的丈夫，现在给了我儿子。我不是年少青春了，没有耐性再跟他慢慢磨合，过平淡日子。
我拒绝了他。他很失落。对他而言，也早该跳出来。
你想的不全对，也不全错。他没有喋喋不休再打电话烦我，但也不是再无联络。他还是离婚了。他卖掉房子和车子，自己要了二十万，其余给了老婆和孩子。他来北京，和我见了一面，告诉我这些。别误会，他不是破釜沉舟来找我告白，而是跟我告别。他很苦闷，说不想在老家呆了。我问他将来要去哪里，他说随便，越苦越累越好。他那时准备去郑州，跟人做生意。后来又去四川，现在好像在陕西。
而我，你看到的，坐在这里跟你在说话。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##五 钟磬音&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 你问我现在有没有男朋友？没有。儿子是我现在的全部，我为了他也不想再结婚。我最喜欢的还是他爸爸。
我也不担心以后养老的问题，不去想以后的烦心事。我不愿意为这些琐事困扰，每天不开心。我是爱好浪漫的，过得快乐很重要。
不，不会。我跟他是永远不可能的，最多我们是好朋友。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##六 尾声&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; “叮铃铃铃……”。耳边真切响地起铃声，这节课结束，我该准备进教室上课。操场上瞬间挤满玩游戏的小孩子。我摘下耳机，更清晰感到周围的嘈杂。从梦中惊醒一般。
我忍不住看一眼这位老师。她体面坐在那儿，脸上笑眯眯的展开眉眼。她们也起身了，我们打个招呼。穿过破旧的校园，我走进教室，打开课本，脑中却静不下来。
教室里没空调，白色的阳光依旧明晃晃的。下午的世界，缺点烦躁的蝉声。
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>爸爸的十八岁</title><link>https://blog.yuantops.com/life/dad-in-his-18/</link><pubDate>Mon, 18 Jun 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/life/dad-in-his-18/</guid><description>&lt;p&gt;从客车上下来，远远看见爸爸的背影。他在街上和一个熟人说话，摩托车停在旁边。我走过去，把手搭上他肩，拍他一下。对面的叔叔一笑，打声招呼走了。爸爸转过身看到是我，十分高兴又略显局促地说，你到啦，那上车走吧，天好热。我坐上摩托车的后座，车开动。&lt;/p&gt;
&lt;p&gt;他真的老了，我在心里不情愿地承认。刚刚下车，看到他背影的第一眼，我很诧异：他显得好沧桑！站在那儿，明显不如以前挺直。我走近，他转过身，我突然意识到他居然没有我高。在印象中，我一直在仰视他。现在，我却高过他了。坐在摩托车后座上，我一边跟他说话，一边看他——在他头上竟然看到不止一根白头发。爹爹在的时候曾跟我说，我们家的遗传是不白头发，他七十多了还是满头乌。现在，他的小儿子可是真真实实长出了白头发。我心里越发不是滋味。时间真残忍，守不住岁月的秘密，任由它爬上脸庞、发梢，让人心碎。&lt;/p&gt;
&lt;p&gt;爸爸今年四十六。爹爹婆婆养育了四男三女，他是最小的儿子。他少年时贪玩，没有在学业上取得成就，成了一个称职能干的农民。记忆里的他，能种地，会钓鱼，安得好电灯泡，编得了竹工活儿。除了在我小时候有几次打得我蹦蹦跳，基本上没对我发过火。为人老实谦和，不善言辞，脾气很好，非常照顾我妈。有他在，家才显得踏实。在我心里，谁能比他更算一名成熟的男子汉？&lt;/p&gt;
&lt;p&gt;回到家，妈妈已经准备好午饭。他一般吃饭时喝点酒，因为我回来，他喝完平时的量，还想再加点儿。被妈妈埋怨说对身体不好，还喝还喝，只好作罢。饭桌上他们问我，学校怎么样，吃得怎么样，宿舍热不热，北京过得惯不惯——都是问了好多遍的问题。我嗯嗯啊啊，把以前的回答重复一遍。他们关心我过得好不好。听到我说好，就高兴。他和妈妈，认为我总是孩子，都把心整个儿放在我身上。我快二十了，一天天长大，他们却一天天衰老。&lt;/p&gt;
&lt;p&gt;屋前水泥地上摊晒着麦子，傍晚要装袋收进屋里。我帮妈妈的忙，把工具把麦子耙拢成一堆。妈妈说，这几千斤麦子天天晒和收，装袋后背进背出都是你爸一个人，今天可好，我们俩合作可以放他一次假。过一会儿，妈妈又指着装好的一袋麦子问我，一袋小麦一个人你搬得起搬不起？我瞧着满满实实的一袋，真是不太确定。弯腰一试，用尽全力踉踉跄跄才搬起来抱进屋。只能回复妈妈，我奈何不了它。妈妈一边笑，一边“嘲讽”我，真没用！爸爸在你这个年纪正当壮年，早就是家里的正式劳力，挑谷插秧样样来得活，这么一袋麦子根本不在话下！&lt;/p&gt;
&lt;p&gt;爸爸正好出来听到。他十分得意的回忆起当年勇：&lt;/p&gt;
&lt;p&gt;“我十八岁下学，在家里帮你爹爹婆婆搞农活。夏天收稻子，我心里有底，不用秤称，一担就是两百斤，挑起就走，一天也不觉累！……”&lt;/p&gt;
&lt;p&gt;我和妈妈都称赞他了不起，他说，“现在可比不得以前了。不如以前有劲儿。”他又说我，不锻炼，手膀子上肌肉都是松的。我手臂的肌肉的确是松弛的，整天不是在宿舍就是在自习室，根本没有锻炼它。不过这双手，还是和妈妈一起把装好的麦子都搬进来，没有让他插手。他背着药水机，趁着傍晚凉爽在天黑前去田里打一遍药。&lt;/p&gt;
&lt;p&gt;一共十二袋麦子，晒得结结实实，用装化肥的蛇皮袋子装着，在角落码得整整齐齐。我的手臂还有点儿酸。&lt;/p&gt;
&lt;p&gt;爸爸说他十八岁的“英勇”故事，言语中颇为自豪。还未至知天命之年，他头上已经生出白发，背也开始显得驼。他的青春，力气，还有一股子狠劲儿，都慢慢离他而去了，渐渐不见了。&lt;/p&gt;
&lt;p&gt;它们都去了哪儿?我使劲儿想，得到答案：它们到了我这儿。一个父亲十八岁的逝去，在我这个儿子身上继续。生命的加减法好残酷，让人不忍直视。&lt;/p&gt;</description></item><item><title>关于我成长经历的事</title><link>https://blog.yuantops.com/life/about-my-growing-up-experience/</link><pubDate>Sat, 09 Jun 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/life/about-my-growing-up-experience/</guid><description>&lt;blockquote&gt;
&lt;p&gt;在我们成长中，有过很多有趣的事，当然也会有一些烦恼。&lt;/p&gt;
&lt;p&gt;在这些年中，让我最难忘的还是在老家的时候，我的好朋友黄与青和我玩耍，都玩得很开心，有时也会说不做朋友的话，但是过了几天就又成了好朋友。有时我们也会去山上玩，山上有一些绿绿的草，躺上去非常舒服，好像躺在床上一样。&lt;/p&gt;
&lt;p&gt;到了春天，遍地都是鲜花，散发出许多香气。这些花美丽极了。&lt;/p&gt;
&lt;p&gt;我们最喜欢玩捉迷藏的游戏，黄与波来抓我们，都被他找了出来，大家都说他是个小侦探。&lt;/p&gt;
&lt;p&gt;黄与波与黄与青成绩都考的比我好，而我在班里考了倒数，黄与波与黄与青就帮我补习功课，让我的成绩上升。到考试的时候竟然不是倒数了。我及格了，考到了75分。&lt;/p&gt;
&lt;p&gt;自从我到了北京，就很少回老家，我与他俩也就很少有时间玩了。&lt;/p&gt;
&lt;p&gt;北京的环境不好，很脏，还不如老家的环境。我在这里的新源学校读书，我在这里也认识了一些朋友，和他们玩得很开心，天天都很快乐，也没有烦恼。有时候，父亲也会带我们去玩，让我们有些快乐。&lt;/p&gt;
&lt;p&gt;在我的成长中有快乐，有悲伤，也有一些难过的事情，不过我们不会为了这些小事不快乐，我们应该常常保持快乐，天天开开心心的。&lt;br /&gt;
新源学校 四（2）班 王××&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是我今天在一所农民工子弟学校看到的作文，它作为优秀作品被贴在学校的展示板上。小学生的作文，触动了我，于是将它记下来。&lt;/p&gt;
&lt;p&gt;北京地铁五号线到最北端，到天通苑北这么一个地方。能看到灰尘飞扬的工地，密密麻麻的楼盘，积极热情的各色黑车，沾灰破旧的招牌，还有贩卖油腻烧烤的游动小贩。出地铁站，穿马路，沿狭窄逼仄的民房夹道，在污水横流垃圾遍地的地上跳着走5分钟，左拐就能到这所小学。&lt;/p&gt;
&lt;p&gt;他是农民工子弟学校的孩子，从春天里“遍地都是鲜花”的老家，来到“很脏”的北京读书。其实北京未必很脏。国贸CBD、中关村、西单，那些白领金领们出没的地方，一点儿也不脏；优雅深沉、书香琴韵的大学城，还有衣着整洁光鲜亮丽的本地孩子们的学校，教学楼的地板都一尘不染，简直和“脏”不沾边儿。但是在一个小学生的眼中，他对这些让首都人民引以为骄傲的光鲜没有印象，因为他生活和学习的地方不是这样的。&lt;/p&gt;
&lt;p&gt;写这篇作文的小学生，就是在这样的环境里上课。他每天上学放学，都看到这些。他哪里知道，北京的同龄小学生，坐在亮堂的教室里上课，学校周边的道路都是重点整治对象，不会见到他所熟知的猖狂的垃圾。难怪他说，北京“很脏”。&lt;/p&gt;
&lt;p&gt;他的父母很可能背井离乡，在这个充满机遇的都市里谋生存。跟着父母，他也离开北京，来到书本上的首都求学。北京的富丽堂皇，他都没能看到，在脑海中留下印象。据我以前所了解的，他没资格在北京升初中，没法在北京升高中，没法在北京参加高考——他不能堂堂正正享受和本地小孩一般的待遇。&lt;/p&gt;
&lt;p&gt;虽然北京没有以前的好友，父亲也只能有时带他去玩，但生活在他看来，很快乐，也没有烦恼。&lt;/p&gt;
&lt;p&gt;就好像一只城市里的寄居蟹，寄居在这座城市里。寄居蟹能和寄主一起相存一辈子，但他总是要长大的，不知以后该去那里。他在老家出生，却在北京这座城市长大，留不住，回不去。&lt;/p&gt;
&lt;p&gt;到不了的都是远方，回不去的都是故乡。对他们而言，远方在何处，故乡在何处？&lt;/p&gt;</description></item><item><title>真诚的人死了，虚伪的人却活下来</title><link>https://blog.yuantops.com/opinions/the-honest-dead-the-hypocrisy-alive/</link><pubDate>Mon, 04 Jun 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/the-honest-dead-the-hypocrisy-alive/</guid><description>&lt;p&gt;在Facebook上看到这句话，觉得写得真好。&lt;/p&gt;
&lt;p&gt;23年前的今天，发生了世界震惊的大事件。持续将近两个月的学生的请愿活动，最终在广场上被暴力驱散。借用韩寒的一句话，“本该在心中的热血，它涂在地上”。清场前后的死伤流血，至今没有权威的统计数字；事后众“领袖”逃的逃，抓的抓，情景凄凉。直到今天，23年过去了，伤痕离愈合还远得很。&lt;/p&gt;
&lt;p&gt;站在今天看昨天，隔着重重迷雾和层层路障，想探知一份真相无比困难。现在能接触到的信息，侩子手为自己狡辩的证词不可信，冲动煽情的“公正报道”也难免掺杂感情的夸张。&lt;/p&gt;
&lt;p&gt;真相重要么？只要能铭记精神，细节的差错似乎也无关宏旨，更有甚者有人情愿相信夸张后的传言来印证内心的观点。但真相永远是真相，它是基石。观点建立在事实基础上，而非相反。最大的争议，也是最扑朔迷离之处，有两处。其一，清场当晚，熄灯之后，有没有开枪，碾没碾人；其二，死伤人数的数量级问题。&lt;/p&gt;
&lt;p&gt;是夜的问题，第一手的证词来自事件当事人。可偏偏当时的三大领袖，说法都不同。吾和柴两位，坚持确有其事，西方媒体喜欢他们的说法。但封和刘两位，却声称他们一直呆在那儿，直到最后撤出也没有见到所谓的Tu杀。（可以在油吐蕃上看到封刘二位的受访视频。）&lt;/p&gt;
&lt;p&gt;人数的问题，差别更大。上千上万的，也有几百几十的，还包括当时某发言人声称的，没有一人伤亡。这个问题永远没有共识，官方不给出具有说服力的数据，各方是不肯改变看法的。与其说是人数的认同，不如说是立场的坚持。但如果第一个问题选择相信后者，那就会得出很大可能是三位数，至多刚到四位数。&lt;/p&gt;
&lt;p&gt;我倾向于相信封刘二位的说法，因为他们的人品更可靠。刘不需多言，现在还呆在监狱里服刑——他是极少数坚持留在国内的所谓“领袖”，他的坚守温和可见一斑。相比之下，柴就差太多。当初是激进的广场派，想让同学流血而自己开溜；尔后到美国，对事实的描绘一天几变，越说越离谱，在一次国会的听证会上，她承认自己在大学时四次堕胎——她以此谴责计划生育政策。后来信教，变得更不可理喻。如此臭的人品，她口中的证言总不那么可信。&lt;/p&gt;
&lt;p&gt;柴一类的人最无耻。她始终都不真诚，或者说不像她的同学那样真诚。她的立足点不在解决问题，而在把事情闹大。坚持不撤，坚持要流血，很难让人不怀疑她是在为自己捞资本。真到临头了，溜得最快。在美国，拣媒体喜欢听的说，不管是真实性如何。时髦点的说法，她在消费，消费死者的热血和抱负，消费同情。&lt;/p&gt;
&lt;p&gt;其实柴一类的人真多。他们是当事人，受过伤，受到尊敬。在以后的时间里，他们就在这份尊敬上坐吃山空，吃空了再招摇撞骗。他们还记得当初在坐在那里的同学们的初衷么？&lt;/p&gt;
&lt;p&gt;鲁迅说过，人类血战前行的历史，正如煤的形成，当时用大量的木材，结果只是一小块。但他又说，学生的情愿是不在其中的。学生手无寸铁，很容易就受了利用。现在看来，真是不假。真诚的学生，不是伤亡就是被清算。他们做了先驱，倒在地上，后面的人然后不犹豫地踏着爬上去。&lt;/p&gt;
&lt;p&gt;不吝惜自己的热血，要为国家和民族争前途的，总是中国的年轻人。他们是火种，是希望，始终激励着前进。&lt;/p&gt;
&lt;p&gt;真诚的人倒下了，虚伪的人活下来。活得那么卑微，让人瞧不起。&lt;/p&gt;</description></item><item><title>欠蒋介石一个客观评价</title><link>https://blog.yuantops.com/opinions/own-chiang-a-fair-appraise/</link><pubDate>Sun, 27 May 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/own-chiang-a-fair-appraise/</guid><description>&lt;p&gt;蒋介石在中国近代史上地位独特。他发起北伐，基本上完成中国的统一；领导中国进行艰苦卓绝的八年抗战，取得胜利；他治下，中国成为联合国的四个创始国之一，大大提升了国际地位。但他也对共产党人和左翼知识分子进行血腥镇压。内战失利后，他从大陆退守台湾，从此再也未能踏上大陆的土地。自此，大陆和台湾两地对他的评价走向两个极端。&lt;/p&gt;
&lt;p&gt;成王败寇，原属平常，两岸皆然，况且是人生如此戏剧化的领导人。两岸在49年后所走的路线迥然不同，意识形态一度处于极端对立状态。新时期的两岸关系趋于缓和，但在历史的认识方面仍存在极大不同。两岸从学界还是民间，最集中的分歧之一就体现在对蒋介石的评价。&lt;/p&gt;
&lt;p&gt;我上学时的历史课本，称其为官僚资本主义的代理。“以蒋介石为首的国民党反动派”是一个固定短语，出现在文革年代的宣传中。直到现在，大陆课本上的蒋介石形象还是平庸玩阴谋的政客、腐败透顶的资本家、血腥的侩子手。而在台湾，他被称作“先总统”、“蒋委员长”，被尊崇到无以复加的地步。据说在文字资料中若提到其名，需要空格以示尊敬。&lt;/p&gt;
&lt;p&gt;无论是两岸哪一种评价，都算不上客观公正。蒋介石的功过是非，很大部分是国民党的功过是非。现今我们所处的时代，离当初已经将近半个世纪，言论方面的禁忌正越来越少。环境准备既已成熟，但一个客观全面深刻的评价，仍处于缺失状态。对过去，对将来，都是一件遗憾。&lt;/p&gt;
&lt;p&gt;如何评价一个人？古人的官方态度是很一致的。二十四史，评价历代王侯将相，无非是“德”与“才”。我们的传统是用道德衡量一个人的一生。攻击他的人，和赞扬他的人，都想尽法子找他道德方面的话头。更全面一些的，考量他的个人能力，指责他拉帮结派，或赞扬他个人魅力无限。做道德鉴定是我们的传统。但道德这个东西，是说不清的，像一团浆糊。蒋介石的政治生涯具有偶然性，他的个人性格固然重要，但时局的影响同样重要。所谓“时势造英雄”，蒋的功过都逃离不了他所处的时代。&lt;/p&gt;
&lt;p&gt;蒋在初登上中国最高领导之位时，他面前的中国是如此一副光景：军阀割据，中央政府的建设几乎不存在，财政收入可怜，外国势力盘综错节。中国刚刚被时代的浪潮拥挤着，艰难告别几千年的封建帝制。不久日军全面侵华，战线告急。中国几千年的历史，遇到前所未有之巨变，前无古人后无来者，在人类文明史上亦是罕见。在这场巨变中掌舵的人，正是蒋介石。经过惨淡经营，这个风雨飘摇的国家，最终居然赢得了抗战胜利，成为联合国创始国之一，疆域也得到最大程度的统一，有了真正意义上的现代政府。虽然诸项指标很粗糙，但从零到有，本身就值得赞叹。&lt;/p&gt;
&lt;p&gt;蒋领导了中国历史上极为重要的一次转变。这次转变是从旧到新，从无到有的一个尝试。中国几千年的传统轨迹，被迫转向，在新时代的浪潮里寻找方向。这些经验是宝贵的，是研究世界文明转变的标本，对中国这个大国的未来走向也有借鉴意义。&lt;/p&gt;
&lt;p&gt;研究蒋、评价蒋，不能脱离他的时代。蒋的一生是如此独特，他被卷到时代的洪流里，并影响了时代的走向。单纯一个好人或者坏人，并不足以概括他。他有他的局限性，也有他的贡献。正如黄仁宇所坚持的，站在“大历史”的角度来看他，才是对后代负责的做法。&lt;/p&gt;
&lt;p&gt;但要走的路还有很远。现在虽然意识形态的禁锢减轻了，在大陆还是存在着深厚的土壤。但起码可以开始考虑这些问题了。我们的时代是不断向前发展的，那一天终会到来。&lt;/p&gt;</description></item><item><title>要勇敢追求——有感而发</title><link>https://blog.yuantops.com/opinions/have-the-courage-to-pursue/</link><pubDate>Sat, 26 May 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/have-the-courage-to-pursue/</guid><description>&lt;p&gt;我亲眼见证了一件勇敢的追求事件，深受触动。想到自己，感到很惭愧。&lt;/p&gt;
&lt;p&gt;一个女生，在图书馆邂逅并喜欢上了我们班的一个男生，但当时没有行动，错过了。于是，她把当时照的一张相片发到微博上，求转发扩散，求联系方式。恰好我关注了她的一个室友，回复了一句。之后，这个女生持之以恒地问我那个男生的情况。我自己觉得，向一个陌生人透露同学的信息不太合适，不太肯告诉她详细信息。表达了这一想法，告诉她我们是哪个大班的后，我就准备不理她的问题了。&lt;/p&gt;
&lt;p&gt;但是我明显低估了这个女生的决心和毅力。她转而问我的姓名班级。想到有人人这一神器，我谨慎绕开了“圈套”。之后我保持静默。我新发了一条微博（无关微博），底下以前一个高中同学回复。这位女生采用迂回战术，转而向我的同学寻找突破口，问他我的班级。我的高中同学跟她开玩笑，说你打听他干嘛，如果你不承认喜欢他，我就不告诉你。结果，结果，这个女生一咬牙，居然就承认了。无奈，高中同学也不知道我的班级，转过来又来问我。&lt;/p&gt;
&lt;p&gt;估计我再不回应，以后回复我状态的同学都会被问个遍，只好妥协。&lt;/p&gt;
&lt;p&gt;但我觉得我被这位同学的勇气和战略智慧深深折服了。喜欢上一个人，就如此锲而不舍，如此主动勇敢，如此直接了当，真是了不起。而且，被打趣，咬牙承认喜欢一个不认识的人（加上我当时微博昵称非常不雅），颇有壮士断腕、卧薪尝胆的壮烈之感。这位女生说，她平时也不像在微博上表现得这么主动。但为了一件钟情的爱情，做了这么多主动勇敢的事，包括向我这个陌生人、我这个陌生人的同学打听消息，承受被婉拒的尴尬，承认喜欢不认识的脚皮大汉，实在我佩服。&lt;/p&gt;
&lt;p&gt;为了喜欢的人，改变平时的作风，勇敢主动踏出追求的步子，坚持不懈。而且是矜持的女生。真是让吾等大汉汗颜。不论最后的结果如何，但已经做了最大程度的努力。是不是有句话，叫“尽吾志也不能至者，可以无悔矣”？自己有没有这份勇气呢？&lt;/p&gt;
&lt;p&gt;爱情要靠自己争取的，主动勇敢的人让人佩服。&lt;/p&gt;
&lt;p&gt;真诚祝福这位女生。也祝福我身边的人和自己，鼓起勇气。&lt;/p&gt;</description></item><item><title>七心海棠的眼泪</title><link>https://blog.yuantops.com/opinions/love-tear-of-a-flower-like-girl/</link><pubDate>Mon, 21 May 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/love-tear-of-a-flower-like-girl/</guid><description>&lt;blockquote&gt;
&lt;p&gt;“小妹子对情郎——恩情深，
你莫负了妹子——一段情，
你见了她面时——要待她好，
你不见她面时——天天要十七八遍挂在心！”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;金庸小说里，出彩的女性角色非常多。聪明机警的黄蓉，冰清素雅的小龙女，深情谋略的赵敏，工于心计的周芷若……她们各有特色，让人着迷。她们都能吸引我，但我自己最喜欢的女性，是《飞狐外传》里的程灵素。&lt;/p&gt;
&lt;p&gt;飞狐外传》讲的是胡斐大侠少年成长的故事。程灵素在全书后半部分才出现，出场时很有特点：胡斐找毒手药王帮苗人凤治眼，路途中见到一片花圃，一个村女在整理花枝，于是向她问药王庄怎么走。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那村女抬起头来，向着胡斐一瞧，一双眼睛明亮之极，眼珠黑得像漆，这么一抬头，登时精光四射。胡斐心中一怔：
“这个乡下姑娘的眼睛，怎么亮得如此异乎寻常？”见她除了一双眼睛外，容貌却是平平，肌肤枯黄，脸有菜色，似乎终年吃不饱饭似的，头发也是又黄又稀，双肩如削，身材瘦小，显是穷村贫女，自幼便少了滋养。她相貌似乎已有十六七岁，身形却如是个十四五岁的幼女。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;借胡斐的眼，我们看到一个貌不惊人的“穷村贫女”，只有一双眼睛明亮至极。金庸笔下的女性，容貌纵然不是个个举世无双，也大都端正美丽。李莫愁心狠手辣，青春时也是江湖上的美人；金花婆婆当年位居四大法王之首，除了武功人品，也因为教中兄弟爱她美貌，甘愿臣服在石榴裙下；甚至不入流的丁敏君之辈，也是“虽非美女，却也颇有姿容，面目俊俏，颇有楚楚之致”。如此相貌，如此出身，在金庸小说中可谓独树一帜。&lt;/p&gt;
&lt;p&gt;论智慧，程灵素能在金庸笔下所有人物中排第一。“智而近乎妖”，用来形容她不为过。“灵素”取义于《灵枢》《素问》两部药学经典，正切合她身份。她是毒手药王的关门弟子，继承师父的遗作《药王神篇》；她培育出师父也没有成功的毒药之王七心海棠。她的本事，足以让她骄傲。&lt;/p&gt;
&lt;p&gt;从出场开始，她就料事如神，算无遗策。从见到胡斐第一眼，对他施以考验，之后赠花救人，不动声色指点胡斐绕开瘴气林，；她清理门户，手段利落、盘算缜密、机关精巧，将穷凶极恶的师兄师姐整的毫无招架之力，又心服口服；抢夺马春花，帮助胡斐化妆易容，在背后出谋划策，设计出逃路线，从虎口逃脱；掌门人大会，遇到石万嗔，施毒搅局，不露行踪；在庙中再遇石万嗔，设下连环局，毒死贪心的慕容景岳和薛鹤；替胡斐吸毒，怕自己死后胡斐殉情，故意不取石万嗔性命，提示胡斐真正的杀父仇人可能是石万嗔。直到临死，她还在替胡斐着想。&lt;/p&gt;
&lt;p&gt;聪明人，难得的是心好。程灵素施毒出神入化，心地却像个菩萨一般，从不滥杀一人，总留有余地。为王铁匠伸张正义。清理师门，她几次饶恕师兄师姐性命。即使在安排身后事时，也不直接点燃七心海棠的蜡烛，而是放在一边，给慕容景岳和薛鹤一个机会——如果不贪心，他们是不必点燃蜡烛看《药王神篇》的。&lt;/p&gt;
&lt;p&gt;程灵素在遇到胡斐之前，整天和一群用毒高手周旋，过着算计的日子。是以第一眼见到忠厚仗义的胡斐，就芳心暗许。可惜在她之前，胡斐已经先遇到了袁紫衣。袁紫衣貌美如天仙，武艺高超，胡斐心中始终忘不了她。而程灵素对自己容貌也颇为在意，虽倾心胡斐，将一颗心整个儿给了他，但知道终究无法占据他的心。无奈之下，只好和胡斐结成兄妹，一路陪他闯荡。&lt;/p&gt;
&lt;p&gt;胡斐是大侠，对于爱情却不能免俗。他左边是洒脱高贵的袁紫衣，右边是聪明体贴的二妹。久处之后，发现二妹虽然相貌不算丑，而且“一言一笑”，“自有一股妩媚的风致”，但她整天和毒物打交道，心思缜密，总让他感到“不妥”。说到底，胡斐终究喜欢美貌，而且二妹太过精明。精明的女人，总不讨男人欢喜。&lt;/p&gt;
&lt;p&gt;程灵素似乎也知道这些。她知道袁紫衣的存在，吃醋吃得很豁达。无论如何，胡斐心中总忘不了袁紫衣。她的付出全心全意，明知不能得到回报，还无怨无悔。&lt;/p&gt;
&lt;p&gt;在最后药王庙中，胡斐为救她出手，中了三种剧毒。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;程灵素握着胡斐的手，心如刀割，自己虽然得脱大难，可是胡斐为了相救自己，手背上已沾上了碧蚕毒蛊、鹤顶红、孔雀胆三种刚毒，《药王神篇》上说得明明白白：“剧毒入心，无药可治。”
难道挥刀立刻将他右手砍断，再让他服食“生生造化丹”，延续九年性命？三般剧毒入体，以“生生造化丹”延命九年，此后再服“生生造化丹”也是无效了。
他是自己在这世界上唯一亲人，和他相处了这些日子之后，在她心底，早已将他的一切瞧得比自己重要得多。这样好的人，难道便只再活九年？
程灵素不加多想，脑海中念头一转，早已打定了主意，取出一颗白色药丸，放在胡斐口中，颤声道：“快吞下！”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程灵素用自己的性命救了胡斐的性命。吸完毒血，她对胡斐说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“大哥，你和我都很可怜。你心中喜欢袁姑娘，那知道她却出家做了尼姑……我……我心中……”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直到最后，她丝毫没有怨恨胡斐。她爱胡斐，心中说不出话来。“可怜”是她对自己的评语。世上的剧毒无药可解，终究因为没人肯用自己的命救人。她爱胡斐，放弃了自己的命。或者是她知道无法得到胡斐的心，不如就这样了结。用情郎身上的毒血，毒死了自己，救了情郎的性命。&lt;/p&gt;
&lt;p&gt;她的柔情蜜意，她对他的好，她的痴情，胡斐在心中一遍遍想，感觉到彻骨的寒冷。&lt;/p&gt;
&lt;p&gt;七心海棠花不容易养活，是世间毒物之王。海棠花的眼泪，默默的流。它的主人，用自己性命换了情郎性命，死在了情郎面前。&lt;/p&gt;</description></item><item><title>天才都很独特</title><link>https://blog.yuantops.com/opinions/a-genius-is-always-unique/</link><pubDate>Fri, 18 May 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/a-genius-is-always-unique/</guid><description>&lt;p&gt;《月亮和六便士》是我首次接触的毛姆小说。毛姆在小说界的地位显赫，而最近才注意到。在图书馆中心书库里找到这本书的出版日期是1982年，标价0.8元。摸着发黄稍脆的纸张，看着八十年代的美术封面风格，能感受到时间的痕迹。&lt;/p&gt;
&lt;p&gt;如果要给书的体裁做个诠释，不妨看将其看做一本泛回忆性质的传记，不是自传，而是关于个性画家查理斯·斯特里克兰德。作者（或者说书的第一人称叙述者）在年轻时代开始接触查理斯·斯特里克兰德的家庭，作为一个旁观者兼朋友的角色见证了斯特里克兰德的一生。&lt;/p&gt;
&lt;p&gt;作者首次接触到斯特里克兰德时，他还是一个普通的股票经理人，妻子贤惠快乐，一对儿女乖巧可爱。他是一个普通的中产之家的经济和精神支柱，有世俗人羡慕的家庭生活。一天他留下一封平静决绝的书信，离家出走。一切毫无征兆，他很平静地投入到完全不同的潦倒生活。作者受他妻子托付去巴黎劝说他，他根本不留半丝想念牵挂。他一个人蜗居在肮脏的旅馆，画无人欣赏的画。斯特里克兰德根本也不在乎别人的评价。他生病，一个友人戴尔克·施特略夫请他住到家里照料他，结果是友人的妻子爱上了他，要跟着他走。他们两人生活在施特略夫的家里（爱妻子的懦弱丈夫主动让出了房子）。斯特里克兰德有天再次厌倦，想要离开，他这回的女人选择了自尽。他继续流浪，辗转到太平洋的一个岛屿，在那儿和一个土著少女成婚（此时他和第一任夫人的婚姻关系并未解除），继续画画，生育了一对儿女。生命的最后，他得了麻风病，甚至瞎了双眼。但他也体会到艺术的真谛，在他被隔离的木房子的墙壁上，画下伟大的画作。他去世后，妻子按照他的吩咐烧掉了房子。他离开了世界。&lt;/p&gt;
&lt;p&gt;斯特里克兰德的举止显然不被同时代的人理解。他绝情地抛弃家庭责任，在快四十岁时“不务正业”开始学绘画。他说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“我告诉你我必须画画儿。我由不了我自己。一个人要是跌进水里，他游泳游得好不好是无关紧要的，反正他得挣扎出去，不然就得淹死。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;他不点不在乎世界对他的看法，他眼中只有画画，除此之外一切都无所谓。他完全靠精神追求活着。他说话尖酸刻薄、对喜欢不喜欢的人都讽刺挖苦，言语粗鲁。“不在乎”三个字，说起来容易，做起来可难，需要与世界决裂的勇气。他的爱情观是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“我不需要爱情。我没有时间搞恋爱。这是人性的一个弱点。我是个男人，有时候我需要一个女性。但是一旦我的情欲得到了满足，我就准备做别的事情了。我无法克服自己的欲望，我恨它，它囚禁着我的精神。我希望将来能有一天，我会不再受欲望的支配，不再受任何阻碍地全心投到我的工作上去。&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;我只懂情欲。这是正常的，健康的。爱情是一种疾病。女人是我享乐的工具，我对他们提出什么事业的助手、生活的伴侣这些要求非常讨厌。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;女权主义者也许会蹦起来声讨他。他的想法不是正确的，有偏见。偏见是因为他偏执地追求他的精神世界，不能容忍羁绊和束缚。纯精神追求的人，谁也挡他不住。&lt;/p&gt;
&lt;p&gt;斯特里克兰德最后在塔希提岛定居下来。这里的生活他很喜欢，在此他画出了自己所追求的世界。感染麻风病后他双目失明，在不见光明的状态里，他平静安详的注视自己的作品。他没有慌乱，没有沮丧，也没有抱怨。他死而无憾，因为他已经找到他所追求的东西，“死而无憾”。&lt;/p&gt;
&lt;p&gt;他创造了自己的世界，而后毁掉它。他嘱咐妻子爱塔，死后放火烧掉画有壁画的房子。他带着骄傲死去。&lt;/p&gt;
&lt;p&gt;然而他死后也未能被彻底原谅。他第一任妻子和他儿女，被告知他的凄凉死状后，“有一两分钟大家都没有说话”。“上帝的磨盘转动得很慢，但是却磨得很细”，他的儿子说了这句话。斯特里克兰德背叛他原来的家庭，背弃整个世俗世界，冷静不懈地追求自己的艺术境界。&lt;/p&gt;
&lt;p&gt;世界仿佛是平行的，他漂泊，流浪，在太平洋的岛屿上和土著生活在一起，他作画直至生命的结束，在贫困的生活中感到满足；被他抛弃的家庭，按照世界的预定轨道运转，社会地位、名声、婚姻、家庭，被视为至宝。后者瞧不起前者，不肯妥协原谅。&lt;/p&gt;
&lt;p&gt;斯特里克兰德是天才，他的艺术眼光为他赢得他不屑一顾的赞誉。他似乎纯是为自己所追求的艺术而生，行为离经叛道。天才似乎都有GEEK的特质，他们生命的精力都投到自己的世界，因而“怪异”。个性的人浑身棱角，和社会格格不入。但天才大抵都是有趣的，他们有偏执，很纯粹。&lt;/p&gt;
&lt;p&gt;纯粹，是世界上多么难得的呀！&lt;/p&gt;</description></item><item><title>《边城》的文字美</title><link>https://blog.yuantops.com/opinions/the-word-beauty-of-biancheng/</link><pubDate>Wed, 16 May 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/the-word-beauty-of-biancheng/</guid><description>&lt;p&gt;沈从文，湘西凤凰人。他的代表作《边城》，开篇写道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由四川过湖南去，靠东有一条官路。这官路将临近湘西边境到了一个地方名为“茶峒”的小山城时，有一小溪，溪边有座白色小塔，塔下住了一户单独的人家。这人家只一个老人，一个女孩，一只黄狗。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;空间上的展开，寥落几笔写出一幅宁静安然的小镇格局。女孩是翠翠，老人是摆渡的爷爷。翠翠生长在山水中，机灵纯真，“俨然如一只小兽物”。美好朦胧的爱情悄然发生，翠翠被天保、傩送二老同时爱上，哥儿俩一个走马路，一个走车路，追求翠翠。翠翠懵懂害羞地爱上二老，爷爷替她担忧却受到误解。哥哥为了成全弟弟的爱情，出走下游，沉船溺亡；弟弟伤心之余，也离家出走。爷爷油尽灯枯，在风雨之夜溘然长逝。白塔塌了，渡船被冲走了，爷爷死了。翠翠想明白了很多事，守着渡口，等二老回来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个人也许永远不回来了，也许“明天”回来！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;高中的语文课本节选了《边城》的一部分。翠翠在黄昏的天色中，感到夕阳薄薄地有点凄凉，体会到生命中缺少了什么。当时深受感动，现在前后看《边城》不下五遍。山城中美好的人与物的纠缠，莫不体现一种平静悠长的态度，“不悖于人性”。每次看完，思绪都似乎飘到碧溪崌旁的白塔上，再缓缓落下。&lt;/p&gt;
&lt;p&gt;沈从文的文字风格十分独特。现代汉语的基础，虽说渊源可上溯至水浒红楼的白话小说，但真正成形并形成气候是在五四时期。胡适、鲁迅等一大批知识分子，著作等身，劈荆斩棘，奠定了当代文字的基础。沈从文出身湘西，在创作文字中吸纳了湘语的很多词汇和口语，因而《边城》读来感觉和京派海派作家的作品十分不同，别有古意。&lt;/p&gt;
&lt;p&gt;边城》的语言是和情节相生的。沈从文的用字简练，词汇活泼生动，正如茶峒的民风。语言虽简，但编排暗合音韵，字句的长短产生非常迷人的节奏。我最喜欢这一段，这段文字的美，越念越有感觉：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;黄昏照样的温柔，美丽，平静。但一个人若体念到这个当前一切时，也就照样的在这黄昏中会有点薄薄的凄凉。于是，这日子成为痛苦的东西了。翠翠觉得好像缺少了什么。好像眼见到日子过去了，像在一件新的人事上攀住它，但不成。好像生活太平凡了，忍受不住。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;到底好在哪里，说也说不出个所以然来。一道菜香，他人的评价到底不能传神。在心中念过一遍，这个韵律就留在心底。柔柔的感觉，使整个作品都沉浸在悠然安静中。&lt;/p&gt;
&lt;p&gt;小世界里的人情纠缠，在这种文字的氛围中，极其坦荡率性，不觉庸碌粗鲁。即使是妓女接客，也是“重义轻利”，“守信自约”，在眼泪与快乐所浸透。沈从文自己在回忆中曾写，自己青年时目睹平民被兵士杀头，“大致眼看杀过七百人”。战乱，剿杀，挣扎，眼泪与痛苦，这些都发生边城里，为当时的作者所见。然而沈从文在写作时，对茶峒人的血性直率，仍然给了很高的评价。对仇敌，对爱情，“遇不得已必需出手，便霍的把刀抽出”。现实的矛盾都被刻意柔化，代之以淳朴的人性的真美。&lt;/p&gt;
&lt;p&gt;沈从文自己说，想用一种“优美、健康、自然，而又不悖乎人性的形式”，来展现一个纯净优美的湘西世界。文字深情如诗，畅达简练，而且笔调写意细腻。语言的美，情节的发展，自然的景色，种种都融在一起。沈从文倾注了自己对社会的理想，隐然《边城》就是他为现实中国开出的一剂药方。&lt;/p&gt;
&lt;p&gt;沈从文的审美是东方式的审美，他的创作体现着明显的和谐意境。他为现代汉语开创了一个高峰，在语言的继承和发展、乡土与正统的结合上，他的《边城》真正是难以超越、无与伦比的。&lt;/p&gt;</description></item><item><title>刀在口上之日——纪念她</title><link>https://blog.yuantops.com/opinions/in-memory-of-linzhao/</link><pubDate>Sun, 29 Apr 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/in-memory-of-linzhao/</guid><description>&lt;p&gt;今天是林昭去世的纪念日，纪念她。&lt;/p&gt;
&lt;p&gt;林昭生于民国，少年时迎来新中国的成立，在“革命”中度过最宝贵的青年时代。&lt;/p&gt;
&lt;p&gt;在“革命”年代，她一度陷入狂热，投身到“革命”中。后来她进入北大，在北大她疯狂看书，学会思考，反省曾经的暴行，并痛下决心不再说违心话。在北大一次批判会议中，她坚持自己的观点，和组织者发生了激烈的辩论。别人问她是谁，她说，“我告诉你吧，我可以告诉你没关系，武松杀了人还写：杀人者打虎武松也呢。我林昭还没杀人，我告诉你，我姓林，双木林，昭，刀在口上之日。”字字铿锵。&lt;/p&gt;
&lt;p&gt;文革时她被投入监狱，受到极其非人道的待遇。她多次绝食未果。她用手指蘸血，在白床单上写《告人类》，被判尤其徒刑后写《判决后的申明》。最后她被枪决，没有罪名。行刑后公安人员向林昭母亲索要5分钱的子弹费。当然最后，她被平反。&lt;/p&gt;
&lt;p&gt;我敬佩她，因为她作为一个独立思考的女性，在如此昏暗的年代，能有勇气不妥协，敢发出自己的声音。即使在狱中，即使受到非人的待遇，她仍然坚持原则。&lt;/p&gt;
&lt;p&gt;林昭是真理和勇气的代表，她在黑暗中追求光明的努力，使我深受感动。真理是宝贵的，追寻她的路上充满艰难，但我们已经有了榜样。林昭就是我们的榜样。&lt;/p&gt;
&lt;p&gt;纪念她。&lt;/p&gt;</description></item><item><title>读历史-宋 武功稍逊</title><link>https://blog.yuantops.com/opinions/song-dynasty-imperfection-of-the-military/</link><pubDate>Sun, 29 Apr 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/song-dynasty-imperfection-of-the-military/</guid><description>&lt;p&gt;三岁孩童都知道，中国传统文化的代表是唐诗宋词。历史上很多政权都曾以“宋”为国号，但此处的宋指的是赵家官人建立的“赵宋”。宋朝之前的统一朝代是唐，唐灭亡后陷入四分五裂，是五代十国时期(五代在北方，十国大多在南方)。宋代开国君主赵匡胤原本是周朝大将，在陈桥“黄袍加身”，受拥为帝，之后废黜周朝君主，南征北战统一中国，建立宋朝基业。宋朝的故事正式开场。&lt;/p&gt;
&lt;p&gt;宋太祖“陈桥兵变”的故事是正史所载，历来传唱。但有人考证，所谓军士哗变、“黄袍加身”，不得已称帝，完全是赵匡胤自导自演的一出戏。起事前，赵匡胤把家人藏了起来。当时传言有契丹人入侵，城中官民人心惶惶，而周帝孤儿寡母不能支持，太祖为主持大局继位。但登基后契丹人始终不见来。至于是谁散布的谣言也无人敢追究了。这是宋朝建国的故事，颇具温情色彩。朝代的更替没有发生大规模的流血事件，在血腥的中国历史上可算独树一帜。而温和，似乎也是宋朝的基调。&lt;/p&gt;
&lt;p&gt;宋太祖暴死，传位给弟弟赵光义，是为宋太宗。兄弟相继，史所罕见，正史上将其解释为“金匮之盟”，甚是感人。这回不信的人可就多了，民间怀疑是弟弟杀死了哥哥，“斧声烛影”的典故就在此。当然，这些都是茶余饭后的谈资，没有深究的必要。&lt;/p&gt;
&lt;p&gt;我十分喜欢金庸的小说，总喜欢引用书中的故事。《天龙八部》《射雕英雄传》两部小说，就是北宋和南宋的故事。《天龙八部》里，萧峰的身世是一条线索。他本是契丹人，父母冤死于汉人之手，自己被汉人养大成为丐帮帮主。他终其一身也理不清自己的身世，在汉人和契丹人的身份之间摇摆不定，十分痛苦，最后举身跳下雁门关。&lt;/p&gt;
&lt;p&gt;读过悲壮的萧峰的故事，就对宋代的疆土和民族问题有了一个感性的认识。宋代吸取前代藩镇之乱的教训，将军权收归中央，调将指挥军队，军队战斗力不强。各位皇帝都似乎都对疆域不感兴趣，在军事上很少占上风。故事中的辽国与宋国对峙，谁也不能攻克谁。在“檀渊之盟”之后，双方缔结和约，宋方每年输辽“岁币”，双方互称兄弟，在百年时间里不动干戈。比之国境边互市所得利润和国内和平所生财富，“岁币”损失实在不值一提。这段性质奇怪的“和平”，也是褒贬不一，对之抨击严重的人多是民族自尊心上过不去。若是以一颗更平和的心看，特别在现代的视角下，“檀渊之盟，未为失策”。萧峰的悲剧，是大时代冲击的悲剧，放在今天，他是汉人契丹人都不相干，因为反正都成了中国人。&lt;/p&gt;
&lt;p&gt;因为宋朝“轻武崇文”的政策，加之百年没有过大的战役，军队在关键时刻掉了链子。岳飞的词中说道，“靖康耻，犹未雪，臣子恨，何时灭”，指的就是“靖康之难”。靖康之难，金人入侵，掳走了当时宋徽宗、宋钦宗两位皇帝，宋朝被迫迁都临安，中原衣冠引以为莫大的耻辱。《射雕英雄传》里，郭靖和杨康两人的名字正好凑成“靖康”二字，意在提醒他们勿忘国耻。南迁后的宋朝，史称“南宋”。此时北方的金国已经取代辽国，成为宋朝的最大威胁，而草原上，成吉思汗的功业正在慢慢建立。&lt;/p&gt;
&lt;p&gt;徽钦二宗的命运十分悲惨，宋徽宗据说病死后尸体被火化用来做灯油，宋钦宗在金人王族的马球比赛中跌落被践踏致死。被掳去的王子公主，命运皆然。只有钦宗的母亲、徽宗的妃子韦妃得返。据说返回时，韦妃已经在金国育有子女。&lt;/p&gt;
&lt;p&gt;南宋偏安一隅，不思收复故土，又苟且度过一个半世纪。南宋出了很多名将，最受尊敬的是岳武穆岳飞。岳飞自幼受母亲教诲，“岳母刺字”的故事里说，岳飞的母亲为提醒他勿忘报国之志，亲自在他背上刺下“精忠报国”几个大字。岳飞武艺娴熟，用兵如神，组织北伐，大破金人骑兵。他的军队人称“岳家军”。第四次北伐，岳飞军队在朱仙镇大胜，金人败走，眼看就可收复开封，高宗生忌，连发十二道金牌催回岳飞。北伐功亏一篑，金人得知后卷土重来，加倍施虐报复百姓。岳飞回到朝廷，被以谋反罪逮捕，但找不到证据，被奸相秦桧以“莫须有”的罪名判罪，于除夕夜在风波亭被赐死。这是南宋历史上最冤的政治案。后人读到岳飞的词，字句间充满豪情，又有志向不得舒展的愤懑，实在令人感到惋惜。&lt;/p&gt;
&lt;p&gt;高中时读到岳飞的《小重山》：“昨夜寒蛩不住鸣，惊回千里梦，已三更。起来独自绕阶行，人悄悄，帘外月胧明。白首为功名。旧山松竹老，阻归程。欲将心事付瑶琴，知音少，弦断有谁听。”一个寂寞的英雄身影似乎就浮现在眼前。“知音少，弦断有谁听”一句，说不尽的一种惆怅无奈。岳飞被尊为民族英雄，一腔热血和忠诚让人敬佩。&lt;/p&gt;
&lt;p&gt;高宗之后，南宋陷入内忧外患，直至蒙古人入侵。《神雕侠侣》中，郭靖大侠率领军民在襄阳城守城，城破而亡。历史上，真实的郭大侠想必也大有人在。崖山海战，陆秀夫带小皇帝还有八百皇族集体投海自尽，宋朝灭亡。&lt;/p&gt;
&lt;p&gt;宋朝建国到灭亡，超过三百年。三百年是一个坎，许多武力称雄的朝代都没有逃脱三百年的怪圈。但唯唯诺诺、不思进取的宋朝维持了超过三百年。这也算一个奇迹。&lt;/p&gt;
&lt;p&gt;宋代的文化和经济，达到中国封建时代的最巅峰。在下一节中再说。&lt;/p&gt;</description></item><item><title>读历史-宋 风流无双</title><link>https://blog.yuantops.com/opinions/song-dynasty-reaching-the-civilization-peak/</link><pubDate>Sun, 29 Apr 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/song-dynasty-reaching-the-civilization-peak/</guid><description>&lt;p&gt;宋朝是个不以武功见长的朝代。终其一朝，宋朝都没能达到其他帝国的疆域规模。先与北方辽国对峙百年，同时西方还有西夏，其后被金人赶到江南，连皇帝都被人掳走。在江南偏安又是一个半世纪，最终被蒙古人铁蹄灭了国。但另一方面，宋代的文采之胜，历代莫能与之争。&lt;/p&gt;
&lt;p&gt;武功懦弱和文采风流，很难分清二者到底是因果关系还是并列关系。宋代留给我们的，是优美的诗词、书画和文章。“好男不当兵，好铁不打钉”，宋代的民谚很好体现了当时浓厚的重文轻武思想。&lt;/p&gt;
&lt;p&gt;今天我们还在羡慕宋代宽松的文化政治环境。宋太宗为人温和，十分重视文人，他与后代订约，“不得杀士大夫及上书言事者”，由此奠定了开明的基础。宋代历代统治者的文化水平都不错，尤其以宋徽宗为代表。&lt;/p&gt;
&lt;p&gt;宋徽宗自己创了一种书法风格，笔画纤细、筋骨明朗，人称“瘦金体”，艺术水平极高。徽宗花鸟也是自成一体，颇具富贵气象。徽宗的艺术造诣高，做天子的水平低。他亲信书法水平高的丞相蔡京，生活骄奢淫逸。为建造江南园林，他下令各地进贡“花石纲”，弄得民怨四起。《水浒传》中，有名的“智取生辰纲”就是说梁山好汉用计谋劫到了献给徽宗的花石纲。宋徽宗后来在金国做俘虏，命运极其悲惨。这也是他自己的问题。&lt;/p&gt;
&lt;p&gt;统治者如此，民间的各种文采兴盛就更不必言说。词人代表柳永、王安石、苏东坡、李清照、周邦彦、辛弃疾、姜夔，历史家代表司马光，散文家代表王安石、苏轼、欧阳修、范仲淹，书法家代表“苏黄米蔡”和徽宗，画家代表张折端……不胜枚举。我学过的高中语文课本，有一册专门讲传统诗词，宋词那一课，真是美极了。譬如苏子的《念奴娇·赤壁怀古》：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大江东去，浪淘尽，千古风流人物。故垒西边，人道是、三国周郎赤壁。乱石穿空，惊涛拍岸，卷起千堆雪。 江山如画，一时多少豪杰。&lt;/p&gt;
&lt;p&gt;遥想公瑾当年，小乔初嫁了，雄姿英发。羽扇纶巾， 谈笑间、强虏灰飞烟灭。故国神游，多情应笑我，早生华发。人生如梦，一樽还酹江月。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;人生的种种境遇，都在其中。宋代因为不兴武功，所以文人的作品中多体现一种功业未成的遗憾。苏子仕途坎坷，颇为寥落，他只能在赤壁，遥想前人当年的辉煌，景与物与事与情交融在一起，最后归于一种消极的空虚感觉。中国的文学作品，最高境界就是一种归于寂寥的空虚感，是一种“夕阳无限好，只是近黄昏”的惋惜美。这是和中国的内敛性格一致的。&lt;/p&gt;
&lt;p&gt;苏东坡生活在北宋，还未曾体会到国破家亡之痛。北宋的气象，当真是蓬勃纷呈，盛世的繁荣一览无余。故宫的镇馆之宝《清明上河图》，就描绘了汴京清明时节的风物，笔触细腻，行人建筑无一不传神，让后人赞叹当时的盛况。北宋的王安石是变法家，他发起了超前于时代的财政和政治改革，但没有成功。他的散文，《游褒禅山记》，由小见大，阐述人生的道理，平实严谨。“尽吾志而无悔”，成为后世很多人的格言。&lt;/p&gt;
&lt;p&gt;南宋的艺术风格，仍然延续了北朝的辉煌，但“已显衰败气象”。李清照是杰出的女词人，她的婉约词，格律和意境都有创造。她个人也遭遇家国的双重不幸，颠簸流离，甚是可怜。南宋最值得注目的是主战派将领的豪放词，岳飞辛弃疾的词，金戈铁马，直抒胸臆。岳飞的《满江红》，千古为人所传颂：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;怒发冲冠，凭栏处，潇潇雨歇。抬望眼，仰天长啸，壮怀激烈。三十功名尘与土，八千里路云和月。莫等闲、白了少年头，空悲切。&lt;/p&gt;
&lt;p&gt;靖康耻，犹未雪；臣子恨，何时灭。驾长车踏破，贺兰山阙。壮志饥餐胡虏肉，笑谈渴饮匈奴血。待从头，收拾旧山河，朝天阙。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由词可见一个急切收复失地的将领形象。可惜南宋的君主不支持他。但无论如何这份气节都令人动容。&lt;/p&gt;
&lt;p&gt;宋朝哲学的一大产物是理学。理学代表朱熹、程颐等老夫子，成功地把中国的儒家文化套在了毫无生气的枷锁中，可谓不幸。理学禁锢人的欲望，从此中国妇女的地位开始走下坡路，甚至兴起了裹脚的陋习。&lt;/p&gt;
&lt;p&gt;宋代是中国封建历史上政治和经济的最巅峰。但相比其他朝代，宋代的历史对普通人的吸引力不算大。电视上最多放的是包公和狸猫太子的故事，完全没有挖掘其他的故事。清朝的历史快被各种穿越各种秘史说滥了，明代也有各种抗倭传说，唯独宋代默默无闻。也许是宋代的外交不够面子。想到宋代的各种文化成就，也足够自豪的了。&lt;/p&gt;</description></item><item><title>读历史-明 与崛起擦肩而过</title><link>https://blog.yuantops.com/opinions/ming-dynasty-missing-the-opportunity/</link><pubDate>Sun, 29 Apr 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/ming-dynasty-missing-the-opportunity/</guid><description>&lt;p&gt;黄仁宇先生有一本《万历十五年》，红遍大江南北。我在大二时读的这本书，感觉之后深受其影响。在这本书中，黄仁宇先生提出了“大历史”观，即用整体的眼光看待历史的发展。即使只是一个帝国毫不起眼的一年，也能看出它的脉络。这本书改变了我的历史观。我的明朝认识，主要出自这本书和当年明月的《明朝那些事儿》。&lt;/p&gt;
&lt;p&gt;明朝从放牛娃朱元璋建国，到崇祯帝煤山(现在的景山公园)自缢，持续时间两百六十多年。作为封建时代最后一个“正统”的汉人政权，其影响深远。中国在宋代达到封建时代的最顶峰，其后开始从明朝走缓慢下坡，直到清朝的败象。明代是承上启下的朝代。&lt;/p&gt;
&lt;p&gt;明朝不设宰相。历代以来，宰相的地位是很微妙的。他是百官的代表，同时又是皇帝的臣子。皇帝忙不过来，所以给他权力，让他帮忙分担政务。权力过小，形同虚设，受累的是皇帝；权力太大，又会引来皇帝的猜忌。要保持相权与皇权的微妙平衡，绝对是门艺术。明代开国太祖朱元璋直接取消了宰相的职位，代之以六部。虽然宰相的问题不好处理，但绝对不是随意取消就能解决的。一个疆域如此辽阔的国家，各种政务处理起来千头万绪，朱元璋本人精力旺盛，处理起来自得其乐，但其他养尊处优的皇帝可干不来。结果就是，虽然宰相没有了，但形成了六部长官组成的内阁，内阁权力之大，完虐宰相。内阁首辅，也成了事实上的宰相。&lt;/p&gt;
&lt;p&gt;明朝宦官是大祸害。内廷十二监，其组织结构严谨，可以和外廷相比。宦官不仅在宫内借替皇帝行“批红”程序干预政事，还常作为皇帝代表到地方上行检察之职。内廷实际上成了另一股不容小视的政治力量，司礼太监的权力有时甚至超过内阁首辅。明朝宦官掌权的机构中，最臭名昭著的是特务机关东厂，此外还有各地的特务组织。大魏说得好，“太监都是心理变态”。明代不到三百年，出的“阉党”不在少数：王振、刘瑾、冯保、魏忠贤之流，兴风作浪，倒行逆施，无一有好结果。宦官干政，历代都有防范，却屡防不止。原因不妨以人情度之，皇帝深居禁宫，身边起居的亲信，自然会得到重视。只不过明代的宦官，太无法无天了些。&lt;/p&gt;
&lt;p&gt;明朝开始定都南京，后永乐皇帝迁都北京。现在气势恢宏的紫禁城，就是朱棣主持修建的皇宫。紫禁城结构严谨，将皇权至上的等级观发挥到淋漓尽致，是中国建筑的巅峰之作。朱棣夺了侄儿的皇位，虽然不地道，他本人却是个不折不扣的英明君主。定都北京，远离安逸的南方，奠定了其后中国的政治格局，显示了他独到的战略眼光。他南征北战，开拓疆土，直到累死马背。他还给后人留下了《永乐大典》这部资料宝库。他是英明的皇帝，不输乃父。&lt;/p&gt;
&lt;p&gt;明代有郑和七下西洋。郑和是回民，在下西洋的过程中可能到过麦加朝圣。也有人说，他下海是为了寻找建文帝。无论如何，一支当时无敌、现在看来也十分可观的舰队漂洋过海，的确宣扬了国威。很多华人随舰队移民海外，现在东南亚的华人都流行崇拜郑和。可惜航海记录都被忠诚保守的官员付之一炬，以断念想了。当年的海上风光，至今都不能被后代超越。看到现在的南海争端，简直窝囊死了。&lt;/p&gt;
&lt;p&gt;明朝英宗朱祁镇曾在土木堡之变中被俺答掳走，由此可见当时的军事防线之脆弱。一介书生于谦挽狂澜于既倒，临危受命兵部尚书，另立新君，率领军民进行“北京保卫战”，挽救了局势。不能不说这是一个奇迹，唯一合理的解释，可以归功于所受的家国精神的教育。士大夫之族受到忠君爱国的礼仪熏陶，在关键时刻挺身而出，舍身为家国取义。这样的气节殊为难得。于谦不仅才能出众，而且为官清廉，人品正直，毫不居功。可惜的是，夺门之变之后英宗复位，于谦受到诬陷报复，冤死狱中。他的《石灰吟》，一直激励着后人。&lt;/p&gt;
&lt;p&gt;荒唐可爱的正德皇帝，是另类。他的时代出了王阳明这位格物致知的大哲学家。他之后是沉迷练丹而且长于谋术的嘉靖皇帝。嘉靖皇帝在位四十年，不动声色地在臣子中搞制衡，保持自己稳固的地位。他没留下子嗣。胡宗宪和徐渭在他这个时代成名。徐渭号青藤，是奇人一名，书画家、军事家，郑板桥自称“青藤门下一走狗”，指的是他的画艺。他同时也是军事家。不过晚景凄凉。&lt;/p&gt;
&lt;p&gt;明朝中兴之臣张居正是江陵人。江陵，就是现在的荆州。张居正的争议颇多。他是三朝老臣，辅政期间一转颓势，国库充盈、政令畅通、海患平息，国家井井有条。戚继光受他重用。但他似乎不讲原则地巴结内监冯保以期得到皇帝支持。他出行的排场简直不像人臣，朝廷重臣全是他扶植的人马，他的儿子也点中状元。心学领袖何心隐在他主政时被处死。到张居正54岁去世时，国库由亏损变为盈余，似乎一派欣欣向荣的景象。但之后明朝的颓势一发不可收拾。张居正呕心沥血教育长大的万历皇帝，为立太子问题赌气，在深宫中撒手消极怠工不问政事长达三十载。&lt;/p&gt;
&lt;p&gt;张居正的作用，就像一个伤痕累累的老人身上的一只蜘蛛，老人非常顺从地听任这只蜘蛛吐网裹住全身关节，然后蜘蛛绕过原有神经和血管，通过自己的蛛网操纵这个人的行动。这只蜘蛛很精明，走得很平稳，老人既然不用行动，伤痕也痊愈了，恢复得很好。但这一切的关键在于蜘蛛，蜘蛛只能操纵和维持它的网，不能改造老人的筋骨。蜘蛛倒下了，网就消亡了。更重要的是，这个老人还是得自己走路，没了蜘蛛，靠自己难以坚持。张居正当不了彻底改革者——谁也当不了彻底的改革者，他只是救火队、外科医生。他想颁布命令时，先授意门生递上奏折，然后再借皇帝的名义对奏折予以批准。这样用自己的门生系统取代效率低下的行政部门，一时的效果显著，但实际上损害了本身的行政系统，必然会受猛烈抨击，也难以形成制度令后人效仿。&lt;/p&gt;
&lt;p&gt;到明代末年，崇祯帝从他兄长手中接过皇位时，形势已不容乐观。金庸先生的《碧血剑》就发生在这个时代。虽然与其他作品相比，这部书的情节稍显平淡无奇，但其中的历史事件描述得大体不差，分析议论鞭辟入里。 崇祯皇帝性格多疑暴躁，虽然不腐败堕落，甚至颇为勤恳，但可惜没有励精图治的才能。李自成的起义，直接促成了帝国的灭亡。他性格的缺陷，在最后宁可自尽也不肯出逃南京看出。明朝的政府机构南北各有一套，逃到南京不愁不能东山再起。但他不肯，杀掉妻女，以颇为高尚的形式选择了不妥协。明朝也就此画上句号。&lt;/p&gt;
&lt;p&gt;应该这样看，明代的文官系统之发展，实际上已经相当成熟。万历帝三十年不朝，国家仍然运转。和平年代，皇帝只要不折腾，做做表面的调和工作，就可以得到令名。但这个政治体制是僵化的。明朝的时代，地球的彼端发生了文艺复兴，直接孕育了灿烂的工业文明。在中国，重农业轻工业，传统的伦理和道德使国家整体处于收缩防御态势。即使出现工业和手工业的萌芽，其结果也是可以预见的。&lt;/p&gt;
&lt;p&gt;十七世纪到十八世纪，西方迈出了文艺复兴的步子，中国依旧陷在无边际的仁义道德中。空间上，西风压倒东风，就是从此时开始，中国没有抓住机会。古老的中国，在彻底接收西方文明前，还得经历一个朝代。&lt;/p&gt;</description></item><item><title>读历史-总述 历史是中国的宗教</title><link>https://blog.yuantops.com/opinions/history-is-our-religion/</link><pubDate>Sat, 28 Apr 2012 00:00:00 +0000</pubDate><author>yuan.tops@gmail.com (yuantops)</author><guid>https://blog.yuantops.com/opinions/history-is-our-religion/</guid><description>&lt;p&gt;很多人都持有这样的观点：中国是一个没有宗教信仰的国家。大街上随便问一个人，你信什么教，他最大的可能反应是摇头。少数人会承认他是佛教徒，道教徒就更少了。就普通中国人本身而言，他的心中关于玉帝佛祖菩萨的概念是模糊的——反正我拜就是了。既然如此，这个观点似乎也并无不妥。&lt;/p&gt;
&lt;p&gt;不妨将宗教的最重要一面“信仰”取出来。从这个角度看来，中国的确能算作有宗教——历史就是中国的宗教。一个中国人，只要他不生活在深山老林里，他就一定听说过曹操和诸葛亮的故事，或者对岳飞崇拜至极，更远一点，姜太公的传说也很不错。他从历史故事中学到道德观，形成自己的善恶价值系统。&lt;/p&gt;
&lt;p&gt;世界文明史上，中国人修史的历史最长、记录最全。从公元前八百年至今，时间都在文字上有记录。这是罕见的，也足以自豪。中国人的思维方式、善恶观、价值观，体现在历史中，也受其影响。&lt;/p&gt;
&lt;p&gt;我们崇拜历史。历史虽然不是一个具体实在的偶像，但他的确传达了一种精神，宣扬一种最高价值。“人生自古谁无死，留取丹青照汗青”是士大夫的最高追求，这何异与虔诚的宗教徒的献身精神？&lt;/p&gt;
&lt;p&gt;中国经历了几千年的历史，其间中国人经历的事情千千万万。要了解中国的现在，弄清中国现在的病态根源，不妨从历史中找点蛛丝马迹。当然了，不是战战兢兢地膜拜，而是坦然地打量。&lt;/p&gt;
&lt;p&gt;自从当年明月的《明朝那些事儿》获得成功以来，越来越多人投身普及读物的编写，《宋朝那些事儿》《汉朝那些事儿》层出不穷。专业人士对此呲之以鼻，我这样的业余人士还是喜闻乐见的。北邮的图书馆里有一个书架的历史读本，其中很多属于此类。我喜欢看这样的书籍，看完之后感受很多。于是写了这些博客，是读后感。&lt;/p&gt;</description></item></channel></rss>