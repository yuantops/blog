#+author: yuan.tops@gmail.com
#+hugo_base_dir: ../
#+HUGO_SECTION: tech
# Categories
#+filetags: @Tech
#+hugo_auto_set_lastmod: t

* All about this blog                                                           :gh_pages:hugo:
** DONE How to blog with ox-hugo in Emacs                                       :Emacs:
   CLOSED: [2019-07-25 Thu 14:47]
:PROPERTIES:
:EXPORT_HUGO_CATEGORIES: Tech
:EXPORT_DATE: "2019-07-24T22:29:52+08:00"
:EXPORT_HUGO_PUBLISHDATE: "2019-07-24T22:29:52Z"
:EXPORT_FILE_NAME: blogging-with-ox-hugo
:EXPORT_DESCRIPTION: 发现一个用Emacs写blog的新工具: ox-hugo。它与org-mode融合得非常自然，更好用。本文记录如何在Emacs中配置与使用ox-hugo。
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :keywords '( "ox-hugo" )
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2019-07-25 Thu 14:47]
- State "TODO"       from "DONE"       [2019-07-25 Thu 10:05]
:END:

我的[[https://blog.yuantops.com/tech/emacs-orgmode-hugo-with-oxpandoc/][一篇老博客]]，介绍了用Emacs和Org-mode写博客的工作流。总的来说，勉强符合预期，流程稍显磕绊。今天偶然发现，用Org-mode写博客有了正规军： ~ox-hugo~ 。简单试用之后,发现 ~ox-hugo~ 表现很流畅，几乎就是对之前流程的升级，于是毫不犹豫选 ~ox-hugo~ 。

*** 安装
~ox-hugo~ 是一个工作在Org-mode的Emacs包，安装过程可以说平平无奇：
1. ~M x~ ~package-refresh-contents~ :: 更新安装源
2. 添加Emacs配置。修改细节与Emacs配置风格相关，我使用[[https://github.com/purcell/emacs.d][Purcell维护的.emacs.d配置]]，仅供参考。
   - 在 =.emacs.d/lisp/= 目录下，新增配置文件 ~init-ox-hugo.el~
     #+BEGIN_SRC emacs-lisp -n
     (require-package 'ox-hugo)

     (with-eval-after-load 'ox (require 'ox-hugo))

     (provide 'init-ox-hugo)

     #+END_SRC

   - 在入口配置文件 ~.emacs.d/init.el~ 中，引用新增的配置文件
     #+BEGIN_SRC lisp

     (require 'init-ox-hugo)

     #+END_SRC

*** 写博客旧流程
现在，org文件可以直接导出为Hugo支持的Markdown格式了。这一点 ~ox-pandoc~ 也能做到，但 ~ox-hugo~ 还能做得更多。

回顾之前的工作流:
1. 新建xx.org文件
2. 输入二级标题，接着插入 ~front matter~ 。 ~front matter~ 内容大致如下：
   #+BEGIN_SRC yaml
   +++
   title = ""
   date = ""
   Categories = ["Tech"]
   Tags = ["Emacs"]
   Description = ""
   keywords = [""]
   +++
   #+END_SRC
3. 写博客正文
4. 按下 ~C-c C-e~ , 将二级标题对应的subtree导出为Markdown格式文件
5. 将Markdown格式文件保存到contents/tech/目录。

~front matter~ 是hugo渲染文件需要的必要元信息, 例如文章标签、分类、标题等。ox-hugo改进之一，是使用org-mode语法放置元信息，不再需要手动设置 ~front matter~ 。

Org-mode支持为headline设置 tags。 ~ox-hugo~ 沿用这点，org-mode的tag就是文章标签, 以@开头的tag就是文章分类。其他例如作者、日期、文件名的元信息，通过 ~:PROPERTIES:~ 设置。在导出Markdown格式时，ox-hugo会自动提取这些数据。因为ox-hugo可以一次导出所有subtree，因此 ~ox-hugo~ 官方推荐做法是，所有文章放到一个org文件，[[https://ox-hugo.scripter.co/doc/screenshots/#screenshot-one-post-per-subtree][每个Subtree对应一篇文章]]。

对于习惯一个org文件对应一篇文章的作者而言，ox-hugo也予以尊重，[[https://ox-hugo.scripter.co/doc/org-meta-data-to-hugo-front-matter/][在文件头添加对应配置项即可]]。

*** 我的实践
对本博客而言，考虑到1)文章固定只有3个分类，2)现在已有很多存量md格式的文章，我采取一种折中做法: 一个分类对应一个org文件，org文件里每个subtree对应一篇文章。这样兼顾现状，而且新文章顺利迁移到新做法。就每个org文件来说，元信息分为两大类：
1. 对整个文件都生效的配置，放到文件开头；
   #+BEGIN_SRC yaml
   #+author: yuan.tops@gmail.com
   #+hugo_base_dir: ../
   #+HUGO_SECTION: tech
   # Categories
   #+filetags: @tech
   #+hugo_auto_set_lastmod: t
   #+END_SRC
2. 对单篇文章生效的配置，放到subtree的标题下面。
   #+BEGIN_SRC props
   :PROPERTIES:
   :EXPORT_HUGO_CATEGORIES: Tech
   :EXPORT_DATE: "2019-07-24T22:29:52+08:00"
   :EXPORT_HUGO_PUBLISHDATE: "2019-07-24T22:29:52Z"
   :EXPORT_FILE_NAME: blogging-with-ox-hugo
   :EXPORT_DESCRIPTION: 发现一个用Emacs写blog的新工具: ox-hugo。它与org-mode融合得非常自然，更好用。本文记录如何在Emacs中配置与使用ox-hugo。
   :END:
   #+END_SRC

以本文为例，配置如图:
[[file:screenshot-org-subtree.png]]

*** 总结
Emacs学习曲线盘旋上升, Org-mode也是如此。不断折腾，乐在其中！


** DONE 浏览器会处理URL里的相对路径
   CLOSED: [2019-11-21 Thu 15:53]
:PROPERTIES:
:EXPORT_HUGO_CATEGORIES: Tech
:EXPORT_FILE_NAME: how_web_broswer_handles_url_relative_path
:EXPORT_DESCRIPTION: 如果要访问的url包含相对路径，浏览器会尝试解析相对路径，再访问解析得到的地址。
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :keywords '( "http" )
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2019-11-21 Thu 15:53]
:END:

新系统上线前，安全部门扫描出一个高危漏洞：文件任意下载漏洞。渗透测试人员在URL里加上相对路径，不断发起HTTP请求，居然成功下载到Linux系统密码文件。修复漏洞挺简单，限制HTTP服务访问文件系统权限，不允许超出指定目录，几行代码搞定。

修复之后准备进行验证，第一步当然是复现漏洞。没想到，这一步就挺曲折。

*** 消失的点号
打开chrome，在地址栏输入带了相对路径( *..* )的URL。URL指向一个文件，理论上，会触发文件下载。结果是：地址栏URL路径里点号全不见了，变成了一个正常地址。多试几遍，把双点号换成单点号，仍然如此。用 wiresharks 抓包看HTTP报文，请求头 /path/ 没有点号。这说明，浏览器做了手脚。

1. Google搜之，找到一份解析URI的RFC3968标准，专门有一章论述解析点号：[[https://tools.ietf.org/html/rfc3986#section-5.2.4][Remove Dot Segments]]。经过解析，点号和双点号会消失，这个过程被称为 *remove_dot_segments* 。(RFC3968给出了这个过程的伪代码。)

2. Google官方在一篇文章里，将Chrome解析URL的过程称为 `Canonicalization` ([[https://chromium.googlesource.com/chromium/src/+/master/docs/security/url_display_guidelines/url_display_guidelines.md#display-urls-in-canonical-form][display-urls-in-canonical-form]]) 。经过解析，Chrome地址栏的点号变成实际值。

结合两篇文档，原理清楚了：浏览器遵循RFC3968规范处理URL相对路径，所以点号和双点号都被干掉了。

*** 改用Burp Suite重现问题
不能用浏览器复现问题，改尝试 *curl* 命令。结果，curl也不能复现。好在可以借助 *Burp Suite* 工具。

Burp Suite是一款攻击web服务的集成工具，一般黑客用它来渗透网络。我们牛刀小用，用来拦截、修改HTTP请求报文。过程不在此赘述。总之，用它绕过了相对路径解析、重现了漏洞。

*** 修复漏洞
略。

* Raspeberry Tutorials                                                          :树莓派:
** TODO 用树莓派和Calibre搭建电子书服务器

* Road to linux expert                                                          :Linux:
** Bash Guideline Notes
:PROPERTIES:
:EXPORT_DATE: "2019-07-25T22:29:52+08:00"
:EXPORT_HUGO_PUBLISHDATE: "2019-07-25T22:29:52Z"
:EXPORT_FILE_NAME: bash-guideline-study-notes
:EXPORT_DESCRIPTION: 《Bash Guideline》摘抄与笔记
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :keywords '( "bash" )
:END:
*** 关于重定向顺序
#+BEGIN_QUOTE

Note that the order of redirections is signi cant. For example, the command \\
\\
ls > dirlist 2>&1 \\
directs both standard output ( file descriptor 1) and standard error ( le descriptor 2) to the file dirlist, while the command ls 2>&1 > dirlist directs only the standard output to file dirlist, because the standard error was made a copy of the standard output before the standard output was redirected to dirlist. \\
#+END_QUOTE

*** 将Stdout 和 Stderr 重定向到 文件
#+BEGIN_QUOTE
This construct allows both the standard output ( file descriptor 1) and the standard error output ( file descriptor 2) to be redirected to the file whose name is the expansion of word. \\
\\
There are two formats for redirecting standard output and standard error:\\
\\
&>word and \\
\\
>&word
\\
Of the two forms, the first is preferred. This is semantically equivalent to\\
>word 2>&1\\
#+END_QUOTE

*** Here Document

#+BEGIN_SRC
Here Documents
This type of redirection instructs the shell to read input from the current source until a line containing only word (with no trailing blanks) is seen.

All of the lines read up to that point are then used as the standard input for a command.

The format of here-documents is:

          <<[-]word
                  here-document
          delimiter
No parameter expansion, command substitution, arithmetic expansion, or pathname expansion is performed on word. If any characters in word are quoted, the delimiter is the result of quote removal on word, and the lines in the here-document are not expanded. If word is unquoted, all lines of the here-document are subjected to parameter expansion, command substitution, and arithmetic expansion. In the latter case, the character sequence \<newline> is ignored, and \ must be used to quote the characters \, $, and `.

If the redirection operator is <<-, then all leading tab characters are stripped from input lines and the line containing delimiter. This allows here-documents within shell scripts to be indented in a natural fashion.

$ cat <<EOF > print.sh
#!/bin/bash
echo \$PWD
echo $PWD
EOF
#+END_SRC

** Understanding XOR
:PROPERTIES:
:EXPORT_DATE: "2019-07-25T15:29:52+08:00"
:EXPORT_HUGO_PUBLISHDATE: "2019-07-25T22:29:52Z"
:EXPORT_FILE_NAME: understanding-xor
:EXPORT_DESCRIPTION: 理解xor
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :keywords '( "xor" )
:END:

#+BEGIN_QUOTE
We can interpret the action of XOR in a number of different ways, and this helps to shed light on its properties. The most obvious way to interpret it is as its name suggests, ‘exclusive OR’: A ⊕ B is true if and only if precisely one of A and B is true. Another way to think of it is as identifying difference in a pair of bytes: A ⊕ B = ‘the bits where they differ’. This interpretation makes it obvious that A ⊕ A = 0 (byte A does not differ from itself in any bit) and A ⊕ 0 = A (byte A differs from 0 precisely in the bit positions that equal 1) and is also useful when thinking about toggling and encryption later on. \\
\\
The last, and most powerful, interpretation of XOR is in terms of parity, i.e. whether something is odd or even. For any n bits, A1 ⊕ A2 ⊕ … ⊕ An = 1 if and only if the number of 1s is odd. This can be proved quite easily by induction and use of associativity. It is the crucial observation that leads to many of the properties that follow, including error detection, data protection and adding. \\
\\
 Essentially the combined value x ^ y ‘remembers’ both states, and one state is the key to getting at the other.
#+END_QUOTE


* Golang is great                                                               :Golang:
