<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Yuantops&#39; Blog</title>
    <link>https://blog.yuantops.com/tags/golang/</link>
    <description>Recent content in Golang on Yuantops&#39; Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>yuan.tops@gmail.com (yuantops)</managingEditor>
    <webMaster>yuan.tops@gmail.com (yuantops)</webMaster>
    <copyright>All rights reserved.</copyright>
    <lastBuildDate>Fri, 11 May 2018 10:33:25 +0000</lastBuildDate>
    <atom:link href="https://blog.yuantops.com/tags/golang/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>用Benchmark验证sync.Pool对GC latency的优化效果</title>
      <link>https://blog.yuantops.com/tech/sync-pool-benchmark/</link>
      <pubDate>Fri, 11 May 2018 10:33:25 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/sync-pool-benchmark/</guid>
      <description>

&lt;p&gt;可能是为了避免重复造轮子，Go官方库推出了sync.Pool:一个thread-safe、可回收/重用对象的内存池。对性能优化狂魔而言，sync.Pool无疑是一个优化GC的好工具，因为理论上重用对象会减少了GC次数，缩短latency。这篇文章是sync.Pool的性能验证报告：sync.Pool确实能极大减少GC次数。&lt;/p&gt;

&lt;h1 id=&#34;benchmark关注什么&#34;&gt;Benchmark关注什么？&lt;/h1&gt;

&lt;p&gt;在写Benchmark代码之前，要先确定如何衡量GC效果。很直观地，GC次数越少，效果越好。但GC次数的粒度太大，说服力不够，还需要其他的指标。&lt;/p&gt;

&lt;p&gt;这篇文章&lt;a href=&#34;https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/&#34;&gt;Golang real time
gc&lt;/a&gt;
给我了答案。不断往一个size固定的buffer里覆盖写入数据，记录写入耗时。被覆盖掉的数据会变成垃圾，继而触发GC，所以耗时就是latency。&lt;/p&gt;

&lt;p&gt;原文引述如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The benchmark program repeatedly pushes messages into a size-limited buffer. Old messages constantly expire and become garbage.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是，Benchmark的实现，以及关注的指标就确定了：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;GC次数&lt;/li&gt;
&lt;li&gt;数据写入耗时&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;代码实现&#34;&gt;代码实现&lt;/h1&gt;

&lt;h2 id=&#34;不用sync-pool的实现&#34;&gt;不用sync.Pool的实现&lt;/h2&gt;

&lt;p&gt;见&lt;a href=&#34;https://play.golang.org/p/049Xmy1lTfV&#34;&gt;https://play.golang.org/p/049Xmy1lTfV&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;   package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;time&amp;quot;
)

const (
  windowSize = 200000
  msgCount   = 100000000
)

type (
  message []byte
  buffer  map[int]message
)

var worst time.Duration

func mkMessage(n int) message {
  m := make(message, 1024)
  for i := range m {
      m[i] = byte(n)
  }
  return m
}

func pushMsg(b *buffer, highID int) {
  start := time.Now()
  m := mkMessage(highID)
  (*b)[highID%windowSize] = m
  elapsed := time.Since(start)
  if elapsed &amp;gt; worst {
      worst = elapsed
  }
}

func main() {
  b := make(buffer, windowSize)
  for i := 0; i &amp;lt; msgCount; i++ {
      pushMsg(&amp;amp;b, i)
  }
  fmt.Println(&amp;quot;Worst push time: &amp;quot;, worst)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;用sync-pool的实现&#34;&gt;用sync.Pool的实现&lt;/h2&gt;

&lt;p&gt;见&lt;a href=&#34;https://play.golang.org/p/Wop29wN7&#34;&gt;https://play.golang.org/p/Wop29wN7&lt;/a&gt;&lt;sub&gt;Dp&lt;/sub&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;   package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;sync&amp;quot;
  &amp;quot;time&amp;quot;
)

const (
  windowSize = 200000
  msgCount   = 100000000
)

type (
  message []byte
  buffer  map[int]message
)

var worst time.Duration

//pool for statistics model
var statModelPool = sync.Pool{
  New: func() interface{} {
      return make(message, 1024)
  },
}

func mkMessage(n int) message {
  m := statModelPool.Get().(message)
  for i := range m {
      m[i] = byte(n)
  }
  return m
}

func pushMsg(b *buffer, highID int) {
  start := time.Now()
  m := mkMessage(highID)
  if highID &amp;gt; windowSize {
      statModelPool.Put((*b)[highID%windowSize])
  }

  (*b)[highID%windowSize] = m
  elapsed := time.Since(start)
  if elapsed &amp;gt; worst {
      worst = elapsed
  }
}

func main() {
  b := make(buffer, windowSize)
  for i := 0; i &amp;lt; msgCount; i++ {
      pushMsg(&amp;amp;b, i)
  }
  fmt.Println(&amp;quot;Worst push time: &amp;quot;, worst)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;运行代码&#34;&gt;运行代码&lt;/h1&gt;

&lt;p&gt;因为要观察GC次数，我们需要打开GODEBUG的GCTRACE开关`GODEBUG=gctrace=1`。&lt;/p&gt;

&lt;p&gt;(下面的数据是在我的Thinkpad T450上跑出来的。)&lt;/p&gt;

&lt;h2 id=&#34;不使用sync-pool的实现&#34;&gt;不使用sync.Pool的实现&lt;/h2&gt;

&lt;p&gt;触发454次GC，最差写入耗时50.40ms。&lt;/p&gt;

&lt;p&gt;摘录一部分output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ GODEBUG=gctrace=1 go run benchmark_gc.go
gc 1 @0.041s 0%: 0.044+0.39+0.037 ms clock, 0.13+0.19/0.26/0.40+0.11 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 4 P
...
gc 454 @106.994s 4%: 0.012+29+0.045 ms clock, 0.048+1.6/26/39+0.18 ms cpu, 422-&amp;gt;437-&amp;gt;219 MB, 439 MB goal, 4 P
Worst push time:  50.401524ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;用sync-pool的实现-1&#34;&gt;用sync.Pool的实现&lt;/h2&gt;

&lt;p&gt;触发22次GC，最差写入耗时36.14ms&lt;/p&gt;

&lt;p&gt;摘录一部分output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; GODEBUG=gctrace=1 go run benchmark_gc_pool.go 
gc 1 @0.045s 0%: 0.047+1.2+0.077 ms clock, 0.19+0.12/1.1/0.50+0.30 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 4 P
# command-line-arguments
gc 1 @0.007s 6%: 0.051+2.2+0.024 ms clock, 0.15+0.32/2.1/1.5+0.073 ms cpu, 4-&amp;gt;4-&amp;gt;3 MB, 5 MB goal, 4 P
.....
gc 22 @76.006s 0%: 0.015+53+0.039 ms clock, 0.062+1.7/32/0.62+0.15 ms cpu, 401-&amp;gt;401-&amp;gt;205 MB, 411 MB goal, 4 P
Worst push time:  36.141858ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;结论&#34;&gt;结论&lt;/h1&gt;

&lt;p&gt;sync.Pool的效果很不错，值得尝试。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Emacs Golang开发环境配置指南</title>
      <link>https://blog.yuantops.com/tech/emacs-config-go-dev-environ/</link>
      <pubDate>Thu, 04 Jan 2018 00:31:08 +0000</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/emacs-config-go-dev-environ/</guid>
      <description>

&lt;h1 id=&#34;安装go&#34;&gt;安装Go&lt;/h1&gt;

&lt;p&gt;虽然像是废话，但为了配置过程的完整性，还是记下来吧。&lt;/p&gt;

&lt;p&gt;官网install链接: &lt;a href=&#34;https://golang.org/doc/install&#34;&gt;https://golang.org/doc/install&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;装好后记得配置 &lt;code&gt;$GOPATH&lt;/code&gt; 。为了能在任何地方使用Go编译出来的命令，还可以把 &lt;code&gt;$GOPATH/bin&lt;/code&gt; 附到环境变量$PATH。&lt;/p&gt;

&lt;p&gt;我在Mac上使用iTerm2+oh-my-zsh，所以把它们写到 &lt;code&gt;.zshrc&lt;/code&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# go path
export GOPATH=~/go
# add go commands to system path
export PATH=$GOPATH/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;让go-get命令绕过great-wall的束缚&#34;&gt;让go get命令绕过Great Wall的束缚&lt;/h1&gt;

&lt;p&gt;有了Go的开发环境，我们就可以用它编译、安装一些十分有用的小命令了。但在此之前，还有一些客观存在的技术障碍需要扫除。&lt;/p&gt;

&lt;p&gt;一般 &lt;code&gt;go get&lt;/code&gt;
命令会自动帮我们下载源码、编译、安装命令，如果托管源码的网站被block了(如gopkg.in)，整个过程就会卡住，卡到人抓狂(记得在内心f**k
GFW哦~)。&lt;/p&gt;

&lt;p&gt;这时，如果电脑上刚好运行着shadowsocks，事情就变得简单了。go get
支持http_proxy和https_proxy，我们需要动一点手脚，把sock5协议转换成http协议。&lt;/p&gt;

&lt;p&gt;(以下步骤的前提是电脑上运行着shadowsocks。)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装 polipo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install polipo   
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置 polipo 在家目录下新建 &lt;code&gt;.polipo&lt;/code&gt; 文件，内容如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#必填
socksParentProxy = &amp;quot;localhost:1080&amp;quot;
socksProxyType = socks5
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行 polipo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;polipo &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认会监听8123端口的http请求。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在go get命令前加上http_proxy参数&lt;/p&gt;

&lt;p&gt;以不幸被墙的cobra命令为例,它的代码网址是https协议,用:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https_proxy=127.0.0.1:8123 go get -v github.com/spf13/cobra/cobra
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是http_proxy, 用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http_proxy=127.0.0.1:8123 go get -v github.com/blah/blah
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;安装goimports-gocode等有用工具&#34;&gt;安装goimports，gocode等有用工具&lt;/h1&gt;

&lt;h2 id=&#34;goimports&#34;&gt;goimports&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;goimports命令能自动格式化代码，自动添加、移除imports，而且与Emacs集成良好。可以替代官方gofmt命令。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get -u golang.org/x/tools/cmd/goimports
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;gocode&#34;&gt;gocode&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;gocode命令能为代码自动补全提供后台支持，是Emacs下Go代码补全必不可少的backend。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get -u github.com/nsf/gocode  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;godef&#34;&gt;godef&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;godef命令能在Go源码变量、函数定义间跳转，是查看变量、函数、文件定义的好助手。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/rogpeppe/godef
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;安装emacs&#34;&gt;安装Emacs&lt;/h1&gt;

&lt;p&gt;呃。。。这一步就略过吧&lt;/p&gt;

&lt;h1 id=&#34;emacs配置go-mode&#34;&gt;Emacs配置Go mode&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装go-mode&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加自动格式化的hook(需要安装goimports命令)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;;; Call Gofmt before saving
 (setq gofmt-command &amp;quot;goimports&amp;quot;)
 (add-hook &#39;before-save-hook &#39;gofmt-before-save)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置自动补齐(需要安装gocode命令)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;;;autocomplete
(set (make-local-variable &#39;company-backends) &#39;(company-go))
(company-mode)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置自动跳转按键(需要安装godef命令)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;;; Godef jump key binding
 (local-set-key (kbd &amp;quot;M-,&amp;quot;) &#39;godef-jump)
 (local-set-key (kbd &amp;quot;M-.&amp;quot;) &#39;pop-tag-mark)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>放弃Jekyll，拥抱Hugo</title>
      <link>https://blog.yuantops.com/tech/transfer-from-jekyll-to-hugo/</link>
      <pubDate>Sat, 06 May 2017 14:03:44 +0800</pubDate>
      <author>yuan.tops@gmail.com (yuantops)</author>
      <guid>https://blog.yuantops.com/tech/transfer-from-jekyll-to-hugo/</guid>
      <description>&lt;p&gt;大约半年前，我更换了自己的工作电脑。装完系统后，开始装各种常用程序。&lt;/p&gt;

&lt;p&gt;一切都是那么美好，直到我开始尝试装Jekyll。各种依赖下不下来，或者版本对不上。前者要问候GFW，后者就是Ruby自己的锅了。我，一个Ruby盲，多次被毫不留情的依赖版本问题整崩溃。哪怕一次次长夜痛哭，最终也没有成功。&lt;/p&gt;

&lt;p&gt;直到有一天，我看到小巧精炼的&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Hugo 是用Golang 写的静态网站生成器，只有一个二进制命令，开箱即用。而且，一个命令既可以生成静态文件，又可以直接开http server。所以，那些乱七八糟的gem 包， screw you!&lt;/p&gt;

&lt;p&gt;在将Jekyll迁移到Hugo的过程中，需要重新梳理一下文章的组织结构。不过这些都是小case。&lt;/p&gt;

&lt;p&gt;我的博客托管在Github Pages。Github本身支持Jekyll引擎，以前直接把markdown文件 push上去就可以，Github会自动帮忙渲染源文件。但Github不支持Hugo的文件布局，所以博客内容要先在本地生成html，再push到github。&lt;/p&gt;

&lt;p&gt;我的Github项目地址在&lt;a href=&#34;https://github.com/yuantops/blog/&#34;&gt;这里&lt;/a&gt;。&lt;code&gt;hugo&lt;/code&gt;分支存放源文件，&lt;code&gt;gh-pages&lt;/code&gt;存放编译好的html。&lt;/p&gt;

&lt;p&gt;最后，再次赞美go， 赞美Hugo!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
