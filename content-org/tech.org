#+author: yuan.tops@gmail.com
#+hugo_base_dir: ../
#+HUGO_SECTION: tech
# Categories
#+filetags: @tech
#+hugo_auto_set_lastmod: t

* All about this blog                                                           :gh_pages:hugo:@Tech:
** DONE How to blog with ox-hugo in Emacs                                       :Emacs:
   CLOSED: [2019-07-25 Thu 14:47]
:PROPERTIES:
:EXPORT_HUGO_CATEGORIES: Tech
:EXPORT_DATE: "2019-07-24T22:29:52+08:00"
:EXPORT_HUGO_PUBLISHDATE: "2019-07-24T22:29:52Z"
:EXPORT_FILE_NAME: blogging-with-ox-hugo
:EXPORT_DESCRIPTION: 发现一个用Emacs写blog的新工具: ox-hugo。它与org-mode融合得非常自然，更好用。本文记录如何在Emacs中配置与使用ox-hugo。
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :keywords '( "ox-hugo" )
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2019-07-25 Thu 14:47]
- State "TODO"       from "DONE"       [2019-07-25 Thu 10:05]
:END:

我的[[https://blog.yuantops.com/tech/emacs-orgmode-hugo-with-oxpandoc/][一篇老博客]]，介绍了用Emacs和Org-mode写博客的工作流。总的来说，勉强符合预期，流程稍显磕绊。今天偶然发现，用Org-mode写博客有了正规军： ~ox-hugo~ 。简单试用之后,发现 ~ox-hugo~ 表现很流畅，几乎就是对之前流程的升级，于是毫不犹豫选 ~ox-hugo~ 。

*** 安装
~ox-hugo~ 是一个工作在Org-mode的Emacs包，安装过程可以说平平无奇：
1. ~M x~ ~package-refresh-contents~ :: 更新安装源
2. 添加Emacs配置。修改细节与Emacs配置风格相关，我使用[[https://github.com/purcell/emacs.d][Purcell维护的.emacs.d配置]]，仅供参考。
   - 在 =.emacs.d/lisp/= 目录下，新增配置文件 ~init-ox-hugo.el~
     #+BEGIN_SRC emacs-lisp -n
     (require-package 'ox-hugo)

     (with-eval-after-load 'ox (require 'ox-hugo))

     (provide 'init-ox-hugo)

     #+END_SRC

   - 在入口配置文件 ~.emacs.d/init.el~ 中，引用新增的配置文件
     #+BEGIN_SRC lisp

     (require 'init-ox-hugo)

     #+END_SRC

*** 写博客新流程
现在，org文件可以直接导出为Hugo支持的Markdown格式了。这一点 ~ox-pandoc~ 也能做到，但 ~ox-hugo~ 还能做得更多。

回顾之前的工作流:
1. 新建xx.org文件
2. 输入二级标题，接着插入 ~front matter~ 。 ~front matter~ 内容大致如下：
   #+BEGIN_SRC yaml
   +++
   title = ""
   date = ""
   Categories = ["Tech"]
   Tags = ["Emacs"]
   Description = ""
   keywords = [""]
   +++
   #+END_SRC
3. 写博客正文
4. 按下 ~C-c C-e~ , 将二级标题对应的subtree导出为Markdown格式文件
5. 将Markdown格式文件保存到contents/tech/目录。

~front matter~ 是hugo渲染文件需要的必要元信息, 例如文章标签、分类、标题等。ox-hugo改进之一，是使用org-mode语法放置元信息，不再需要手动设置 ~front matter~ 。

Org-mode支持为headline设置 tags。 ~ox-hugo~ 沿用这点，org-mode的tag就是文章标签, 以@开头的tag就是文章分类。其他例如作者、日期、文件名的元信息，通过 ~:PROPERTIES:~ 设置。在导出Markdown格式时，ox-hugo会自动提取这些数据。因为ox-hugo可以一次导出所有subtree，因此 ~ox-hugo~ 官方推荐做法是，所有文章放到一个org文件，[[https://ox-hugo.scripter.co/doc/screenshots/#screenshot-one-post-per-subtree][每个Subtree对应一篇文章]]。

对于习惯一个org文件对应一篇文章的作者而言，ox-hugo也予以尊重，[[https://ox-hugo.scripter.co/doc/org-meta-data-to-hugo-front-matter/][在文件头添加对应配置项即可]]。

*** 我的实践
对本博客而言，考虑到1)文章固定只有3个分类，2)现在已有很多存量md格式的文章，我采取一种折中做法: 一个分类对应一个org文件，org文件里每个subtree对应一篇文章。这样兼顾现状，而且新文章顺利迁移到新做法。就每个org文件来说，元信息分为两大类：
1. 对整个文件都生效的配置，放到文件开头；
   #+BEGIN_SRC yaml
   #+author: yuan.tops@gmail.com
   #+hugo_base_dir: ../
   #+HUGO_SECTION: tech
   # Categories
   #+filetags: @tech
   #+hugo_auto_set_lastmod: t
   #+END_SRC
2. 对单篇文章生效的配置，放到subtree的标题下面。
   #+BEGIN_SRC props
   :PROPERTIES:
   :EXPORT_HUGO_CATEGORIES: Tech
   :EXPORT_DATE: "2019-07-24T22:29:52+08:00"
   :EXPORT_HUGO_PUBLISHDATE: "2019-07-24T22:29:52Z"
   :EXPORT_FILE_NAME: blogging-with-ox-hugo
   :EXPORT_DESCRIPTION: 发现一个用Emacs写blog的新工具: ox-hugo。它与org-mode融合得非常自然，更好用。本文记录如何在Emacs中配置与使用ox-hugo。
   :END:
   #+END_SRC

以本文为例，配置如图:
[[file:screenshot-org-subtree.png]]

*** 总结
Emacs学习曲线盘旋上升, Org-mode也是如此。不断折腾，乐在其中！


* Road to linux expert                                                          :Linux:
** Bash Guideline Notes
:PROPERTIES:
:EXPORT_DATE: "2019-07-25T22:29:52+08:00"
:EXPORT_HUGO_PUBLISHDATE: "2019-07-25T22:29:52Z"
:EXPORT_FILE_NAME: bash-guideline-study-notes
:EXPORT_DESCRIPTION: 《Bash Guideline》摘抄与笔记
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :keywords '( "bash" )
:END:

*** 关于重定向顺序
#+BEGIN_SRC text
Note that the order of redirections is signi cant. For example, the command

ls > dirlist 2>&1
directs both standard output ( file descriptor 1) and standard error ( le descriptor 2) to the file dirlist, while the command ls 2>&1 > dirlist directs only the standard output to file dirlist, because the standard error was made a copy of the standard output before the standard output was redirected to dirlist.
#+END_SRC

*** 将Stdout 和 Stderr 重定向到 文件
#+BEGIN_SRC text
This construct allows both the standard output ( file descriptor 1) and the standard error output ( file descriptor 2) to be redirected to the file whose name is the expansion of word.

There are two formats for redirecting standard output and standard error:

&>word and

>&word

Of the two forms, the first is preferred. This is semantically equivalent to
>word 2>&1

#+END_SRC

*** Here Document

#+BEGIN_SRC text
Here Documents
This type of redirection instructs the shell to read input from the current source until a line containing only word (with no trailing blanks) is seen.

All of the lines read up to that point are then used as the standard input for a command.

The format of here-documents is:

          <<[-]word
                  here-document
          delimiter
No parameter expansion, command substitution, arithmetic expansion, or pathname expansion is performed on word. If any characters in word are quoted, the delimiter is the result of quote removal on word, and the lines in the here-document are not expanded. If word is unquoted, all lines of the here-document are subjected to parameter expansion, command substitution, and arithmetic expansion. In the latter case, the character sequence \<newline> is ignored, and \ must be used to quote the characters \, $, and `.

If the redirection operator is <<-, then all leading tab characters are stripped from input lines and the line containing delimiter. This allows here-documents within shell scripts to be indented in a natural fashion.

$ cat <<EOF > print.sh
#!/bin/bash
echo \$PWD
echo $PWD
EOF

#+END_SRC


** Understanding XOR
:PROPERTIES:
:EXPORT_DATE: "2019-07-25T15:29:52+08:00"
:EXPORT_HUGO_PUBLISHDATE: "2019-07-25T22:29:52Z"
:EXPORT_FILE_NAME: understanding-xor
:EXPORT_DESCRIPTION: 理解xor
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :keywords '( "xor" )
:END:

#+BEGIN_SRC text
We can interpret the action of XOR in a number of different ways, and this helps to shed light on its properties. The most obvious way to interpret it is as its name suggests, ‘exclusive OR’: A ⊕ B is true if and only if precisely one of A and B is true. Another way to think of it is as identifying difference in a pair of bytes: A ⊕ B = ‘the bits where they differ’. This interpretation makes it obvious that A ⊕ A = 0 (byte A does not differ from itself in any bit) and A ⊕ 0 = A (byte A differs from 0 precisely in the bit positions that equal 1) and is also useful when thinking about toggling and encryption later on.

The last, and most powerful, interpretation of XOR is in terms of parity, i.e. whether something is odd or even. For any n bits, A1 ⊕ A2 ⊕ … ⊕ An = 1 if and only if the number of 1s is odd. This can be proved quite easily by induction and use of associativity. It is the crucial observation that leads to many of the properties that follow, including error detection, data protection and adding.

 Essentially the combined value x ^ y ‘remembers’ both states, and one state is the key to getting at the other.
#+END_SRC

* Golang is great                                                               :Golang:
