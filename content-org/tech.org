#+author: yuan.tops@gmail.com
#+hugo_base_dir: ../
#+HUGO_SECTION: tech
# Categories
#+filetags: @Tech
#+hugo_auto_set_lastmod: t

* All about this blog                                                           :gh_pages:hugo:
** DONE How to blog with ox-hugo in Emacs                                       :Emacs:
   CLOSED: [2019-07-25 Thu 14:47]
:PROPERTIES:
:EXPORT_HUGO_CATEGORIES: Tech
:EXPORT_DATE: "2019-07-24T22:29:52+08:00"
:EXPORT_HUGO_PUBLISHDATE: "2019-07-24T22:29:52Z"
:EXPORT_FILE_NAME: blogging-with-ox-hugo
:EXPORT_DESCRIPTION: 发现一个用Emacs写blog的新工具: ox-hugo。它与org-mode融合得非常自然，更好用。本文记录如何在Emacs中配置与使用ox-hugo。
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :keywords '( "ox-hugo" )
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2019-07-25 Thu 14:47]
- State "TODO"       from "DONE"       [2019-07-25 Thu 10:05]
:END:

我的[[https://blog.yuantops.com/tech/emacs-orgmode-hugo-with-oxpandoc/][一篇老博客]]，介绍了用Emacs和Org-mode写博客的工作流。总的来说，勉强符合预期，流程稍显磕绊。今天偶然发现，用Org-mode写博客有了正规军： ~ox-hugo~ 。简单试用之后,发现 ~ox-hugo~ 表现很流畅，几乎就是对之前流程的升级，于是毫不犹豫选 ~ox-hugo~ 。

*** 安装
~ox-hugo~ 是一个工作在Org-mode的Emacs包，安装过程可以说平平无奇：
1. ~M x~ ~package-refresh-contents~ :: 更新安装源
2. 添加Emacs配置。修改细节与Emacs配置风格相关，我使用[[https://github.com/purcell/emacs.d][Purcell维护的.emacs.d配置]]，仅供参考。
   - 在 =.emacs.d/lisp/= 目录下，新增配置文件 ~init-ox-hugo.el~
     #+BEGIN_SRC emacs-lisp -n
     (require-package 'ox-hugo)

     (with-eval-after-load 'ox (require 'ox-hugo))

     (provide 'init-ox-hugo)

     #+END_SRC

   - 在入口配置文件 ~.emacs.d/init.el~ 中，引用新增的配置文件
     #+BEGIN_SRC lisp

     (require 'init-ox-hugo)

     #+END_SRC

*** 写博客旧流程
现在，org文件可以直接导出为Hugo支持的Markdown格式了。这一点 ~ox-pandoc~ 也能做到，但 ~ox-hugo~ 还能做得更多。

回顾之前的工作流:
1. 新建xx.org文件
2. 输入二级标题，接着插入 ~front matter~ 。 ~front matter~ 内容大致如下：
   #+BEGIN_SRC yaml
   +++
   title = ""
   date = ""
   Categories = ["Tech"]
   Tags = ["Emacs"]
   Description = ""
   keywords = [""]
   +++
   #+END_SRC
3. 写博客正文
4. 按下 ~C-c C-e~ , 将二级标题对应的subtree导出为Markdown格式文件
5. 将Markdown格式文件保存到contents/tech/目录。

~front matter~ 是hugo渲染文件需要的必要元信息, 例如文章标签、分类、标题等。ox-hugo改进之一，是使用org-mode语法放置元信息，不再需要手动设置 ~front matter~ 。

Org-mode支持为headline设置 tags。 ~ox-hugo~ 沿用这点，org-mode的tag就是文章标签, 以@开头的tag就是文章分类。其他例如作者、日期、文件名的元信息，通过 ~:PROPERTIES:~ 设置。在导出Markdown格式时，ox-hugo会自动提取这些数据。因为ox-hugo可以一次导出所有subtree，因此 ~ox-hugo~ 官方推荐做法是，所有文章放到一个org文件，[[https://ox-hugo.scripter.co/doc/screenshots/#screenshot-one-post-per-subtree][每个Subtree对应一篇文章]]。

对于习惯一个org文件对应一篇文章的作者而言，ox-hugo也予以尊重，[[https://ox-hugo.scripter.co/doc/org-meta-data-to-hugo-front-matter/][在文件头添加对应配置项即可]]。

*** 我的实践
对本博客而言，考虑到1)文章固定只有3个分类，2)现在已有很多存量md格式的文章，我采取一种折中做法: 一个分类对应一个org文件，org文件里每个subtree对应一篇文章。这样兼顾现状，而且新文章顺利迁移到新做法。就每个org文件来说，元信息分为两大类：
1. 对整个文件都生效的配置，放到文件开头；
   #+BEGIN_SRC yaml
   #+author: yuan.tops@gmail.com
   #+hugo_base_dir: ../
   #+HUGO_SECTION: tech
   # Categories
   #+filetags: @tech
   #+hugo_auto_set_lastmod: t
   #+END_SRC
2. 对单篇文章生效的配置，放到subtree的标题下面。
   #+BEGIN_SRC props
   :PROPERTIES:
   :EXPORT_HUGO_CATEGORIES: Tech
   :EXPORT_DATE: "2019-07-24T22:29:52+08:00"
   :EXPORT_HUGO_PUBLISHDATE: "2019-07-24T22:29:52Z"
   :EXPORT_FILE_NAME: blogging-with-ox-hugo
   :EXPORT_DESCRIPTION: 发现一个用Emacs写blog的新工具: ox-hugo。它与org-mode融合得非常自然，更好用。本文记录如何在Emacs中配置与使用ox-hugo。
   :END:
   #+END_SRC

以本文为例，配置如图:
[[file:screenshot-org-subtree.png]]

*** 总结
Emacs学习曲线盘旋上升, Org-mode也是如此。不断折腾，乐在其中！


** DONE 浏览器会处理URL里的相对路径
   CLOSED: [2019-11-21 Thu 15:53]
:PROPERTIES:
:EXPORT_HUGO_CATEGORIES: Tech
:EXPORT_FILE_NAME: how_web_broswer_handles_url_relative_path
:EXPORT_DESCRIPTION: 如果要访问的url包含相对路径，浏览器会尝试解析相对路径，再访问解析得到的地址。
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :keywords '( "http" )
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2019-11-21 Thu 15:53]
:END:

新系统上线前，安全部门扫描出一个高危漏洞：文件任意下载漏洞。渗透测试人员在URL里加上相对路径，不断发起HTTP请求，居然成功下载到Linux系统密码文件。修复漏洞挺简单，限制HTTP服务访问文件系统权限，不允许超出指定目录，几行代码搞定。

修复之后准备进行验证，第一步当然是复现漏洞。没想到，这一步就挺曲折。

*** 消失的点号
打开chrome，在地址栏输入带了相对路径( *..* )的URL。URL指向一个文件，理论上，会触发文件下载。结果是：地址栏URL路径里点号全不见了，变成了一个正常地址。多试几遍，把双点号换成单点号，仍然如此。用 wiresharks 抓包看HTTP报文，请求头 /path/ 没有点号。这说明，浏览器做了手脚。

1. Google搜之，找到一份解析URI的RFC3968标准，专门有一章论述解析点号：[[https://tools.ietf.org/html/rfc3986#section-5.2.4][Remove Dot Segments]]。经过解析，点号和双点号会消失，这个过程被称为 *remove_dot_segments* 。(RFC3968给出了这个过程的伪代码。)

2. Google官方在一篇文章里，将Chrome解析URL的过程称为 `Canonicalization` ([[https://chromium.googlesource.com/chromium/src/+/master/docs/security/url_display_guidelines/url_display_guidelines.md#display-urls-in-canonical-form][display-urls-in-canonical-form]]) 。经过解析，Chrome地址栏的点号变成实际值。

结合两篇文档，原理清楚了：浏览器遵循RFC3968规范处理URL相对路径，所以点号和双点号都被干掉了。

*** 改用Burp Suite重现问题
不能用浏览器复现问题，改尝试 *curl* 命令。结果，curl也不能复现。好在可以借助 *Burp Suite* 工具。

Burp Suite是一款攻击web服务的集成工具，一般黑客用它来渗透网络。我们牛刀小用，用来拦截、修改HTTP请求报文。过程不在此赘述。总之，用它绕过了相对路径解析、重现了漏洞。

*** 修复漏洞
略。

* Raspeberry Tutorials                                                          :树莓派:
** TODO 用树莓派和Calibre搭建电子书服务器

* Road to linux expert                                                          :Linux:
** Bash Guideline Notes
:PROPERTIES:
:EXPORT_DATE: "2019-07-25T22:29:52+08:00"
:EXPORT_HUGO_PUBLISHDATE: "2019-07-25T22:29:52Z"
:EXPORT_FILE_NAME: bash-guideline-study-notes
:EXPORT_DESCRIPTION: 《Bash Guideline》摘抄与笔记
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :keywords '( "bash" )
:END:
*** 关于重定向顺序
#+BEGIN_QUOTE

Note that the order of redirections is signi cant. For example, the command \\
\\
ls > dirlist 2>&1 \\
directs both standard output ( file descriptor 1) and standard error ( le descriptor 2) to the file dirlist, while the command ls 2>&1 > dirlist directs only the standard output to file dirlist, because the standard error was made a copy of the standard output before the standard output was redirected to dirlist. \\
#+END_QUOTE

*** 将Stdout 和 Stderr 重定向到 文件
#+BEGIN_QUOTE
This construct allows both the standard output ( file descriptor 1) and the standard error output ( file descriptor 2) to be redirected to the file whose name is the expansion of word. \\
\\
There are two formats for redirecting standard output and standard error:\\
\\
&>word and \\
\\
>&word
\\
Of the two forms, the first is preferred. This is semantically equivalent to\\
>word 2>&1\\
#+END_QUOTE

*** Here Document

#+BEGIN_SRC
Here Documents
This type of redirection instructs the shell to read input from the current source until a line containing only word (with no trailing blanks) is seen.

All of the lines read up to that point are then used as the standard input for a command.

The format of here-documents is:

          <<[-]word
                  here-document
          delimiter
No parameter expansion, command substitution, arithmetic expansion, or pathname expansion is performed on word. If any characters in word are quoted, the delimiter is the result of quote removal on word, and the lines in the here-document are not expanded. If word is unquoted, all lines of the here-document are subjected to parameter expansion, command substitution, and arithmetic expansion. In the latter case, the character sequence \<newline> is ignored, and \ must be used to quote the characters \, $, and `.

If the redirection operator is <<-, then all leading tab characters are stripped from input lines and the line containing delimiter. This allows here-documents within shell scripts to be indented in a natural fashion.

$ cat <<EOF > print.sh
#!/bin/bash
echo \$PWD
echo $PWD
EOF
#+END_SRC

** Understanding XOR
:PROPERTIES:
:EXPORT_DATE: "2019-07-25T15:29:52+08:00"
:EXPORT_HUGO_PUBLISHDATE: "2019-07-25T22:29:52Z"
:EXPORT_FILE_NAME: understanding-xor
:EXPORT_DESCRIPTION: 理解xor
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :keywords '( "xor" )
:END:

#+BEGIN_QUOTE
We can interpret the action of XOR in a number of different ways, and this helps to shed light on its properties. The most obvious way to interpret it is as its name suggests, ‘exclusive OR’: A ⊕ B is true if and only if precisely one of A and B is true. Another way to think of it is as identifying difference in a pair of bytes: A ⊕ B = ‘the bits where they differ’. This interpretation makes it obvious that A ⊕ A = 0 (byte A does not differ from itself in any bit) and A ⊕ 0 = A (byte A differs from 0 precisely in the bit positions that equal 1) and is also useful when thinking about toggling and encryption later on. \\
\\
The last, and most powerful, interpretation of XOR is in terms of parity, i.e. whether something is odd or even. For any n bits, A1 ⊕ A2 ⊕ … ⊕ An = 1 if and only if the number of 1s is odd. This can be proved quite easily by induction and use of associativity. It is the crucial observation that leads to many of the properties that follow, including error detection, data protection and adding. \\
\\
 Essentially the combined value x ^ y ‘remembers’ both states, and one state is the key to getting at the other.
#+END_QUOTE

* Golang is great                                                               :Golang:
* Cryptography
** 浏览器验证SSL数字证书的步骤
:PROPERTIES:
:EXPORT_HUGO_CATEGORIES: Tech
:EXPORT_FILE_NAME: how_do_web_broswer_validate_ssl_certificates
:EXPORT_DESCRIPTION: 本文介绍通过https协议访问网站时，浏览器验证服务器SSL证书的原理，并以Chrome访问百度为例进行分析。
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :keywords '( "ssl" )
:END:

浏览器和服务器使用SSL/TLS通信时，双方首先要通过几次握手(Handshake)，建立加密信道。简单说来，分为下面３步:
1. 服务器发送自己的SSL证书；
2. 浏览器验证服务器SSL证书；
3. 证书验证成功，双方协商得到对称加密密钥，并交换。双方拿到对称加密密钥后，后续的通信都会用它做对称加密。

本文介绍的重点，在前２步。首先，转载一篇国外博客，讲述浏览器检查证书的过程；其次，会引述两个RFC协议的相关内容；最后，wireshark抓包进行验证。

*** Browsers and Certificate Validation
原文地址: https://www.ssl.com/article/browsers-and-certificate-validation/

使用[[https://www.deepl.com/en/translator][DeepL]] 翻译成中文，如下:

#+BEGIN_SRC 
## 证书和X.509格式
证书在各方面都是数字文件，这意味着它们需要遵循一种文件格式来存储信息（如签名、密钥、签发人等）。虽然私有的PKI配置可以为其证书实现任何格式，但公共信任的PKIs（即那些被浏览器信任的PKIs）必须符合RFC 5280，这就要求使用X.509 v3格式。

X.509 v3允许证书包含额外的数据，如使用限制或策略信息，作为扩展，每个扩展都是关键或非关键的。浏览器可以忽略无效的或未被识别的非关键扩展，但它们必须处理和验证所有关键扩展。

## 认证路径和路径处理
憑證機構使用私人密碼匙對所有簽發的證書進行加密簽署。这种签名可以不可撤销地证明证书是由某一特定的核证机 构签发的，而且在签署后没有被修改。

CA通过持有相应公钥的自发证书（称为根）来建立其签名密钥的所有权。憑證機構必須遵守嚴格的控制和審核程序來建立、管理和使用根證書，為了減少暴露，通常會使用根證書來簽發中間證書。这些中间证书可以用来签发客户的证书。
浏览器在出厂时都有一个内置的可信根列表。(这些根是来自通过浏览器严格标准的CA的根。) 为了验证证书，浏览器将获得一个证书序列，每个证书都签署了序列中的下一个证书，将签名CA的根与服务器的证书连接起来。

这个证书序列称为认证路径。路径的根部称为信任锚，服务器的证书称为叶子或终端实体证书。

### 路径的构造
通常情况下，浏览器必须考虑多个认证路径，直到他们能够为给定证书找到一个有效的路径。即使一个路径可能包含的证书可以正确地 "链 "到一个已知的锚，但由于路径长度、域名、证书使用或政策的限制，路径本身可能会被拒绝。

对于浏览器遇到的每一个新证书，构建和评估所有可能的路径都是一个昂贵的过程。浏览器已经实现了各种优化，以减少被拒绝的候选路径的数量，但深入探讨这些细节已经超出了本文的范围。

### 路径验证
候选认证路径构建完成后，浏览器使用证书中包含的信息对其进行验证。如果浏览器能够通过密码学的方式证明，从一个信任锚直接签署的证书开始，每个证书对应的私钥都被用来签发路径中的下一个证书，一直到叶子证书，那么这个路径就是有效的。

## 认证路径验证算法
RFC 5280描述了浏览器验证X.509证书认证路径的标准算法。

基本上，浏览器从信任锚（即根证书）开始，遍历路径中的所有证书，验证每张证书的基本信息和关键扩展。

如果该过程以路径中的最后一张证书结束，没有错误，那么该路径被接受为有效。如果产生错误，则该路径被标记为无效。

### 证书的基本处理
无论是否有任何扩展，浏览器必须始终验证基本的证书信息，如签名或签发人。下面的章节显示了浏览器执行检查的顺序。

1. 浏览器验证证书的完整性
证书上的签名可以用正常的公用钥匙加密法进行验证。如果签名无效，则认为该证书在签发后被修改，因此被拒绝。

2. 浏览器验证证书的有效性：
證書的有效期是指簽署憑證機構保證會維持其狀態資訊的時間間隔。浏览器会拒绝任何有效期在验证检查日期和时间之前或之后开始的证书。

3. 浏览器检查证书的撤销状态。
证书签发后，应该在整个有效期内使用。当然，在各种情况下，证书可能会在自然到期前失效。

这类情况可能包括主体改名或怀疑私钥泄露。在这样的情况下，CA需要撤销相应的证书，而用户也信任CA会通知浏览器其证书的撤销状态。

RFC 5280建议CA使用撤销列表来实现这一目的。

证书废止列表(CRL)
核證機關會定期發出一份經簽署、有時間標記的廢止證書清單，稱為證書廢止清單（CRL）。CRL分布在公开的存储库中，浏览器在验证证书时可以获得并查阅CA的最新CRL。

这种方法的一个缺陷是，撤销的时间粒度仅限于CRL的发布期。只有在所有当前已发布的CRL都被安排更新后，浏览器才会收到撤销的通知。根据签名CA的政策，这可能需要一个小时、一天甚至一周的时间。

在线证书状态协议(OCSP)
还有其他的方法来获取废止状态信息，其中最流行的是在线证书状态协议（OCSP）。

OCSP在标准文档RFC6960中进行了描述，它允许浏览器从在线OCSP服务器（也称为回复者）请求特定证书的撤销状态。如果配置得当，OCSP的即时性更强，而且避免了上面提到的CRL更新延迟问题。此外，OCSP Stapling还能提高性能和速度。

4. 浏览器验证发件人
证书通常与两个实体相关联。

签发人，也就是拥有签名密钥的实体，以及
主体，指的是证书认证的公钥的所有者。
浏览器会检查证书的签发人字段是否与路径中前一个证书的主题字段相同。为了增加安全性，大多数PKI实现也会验证发证者的密钥是否与签署当前证书的密钥相同。(请注意，这对于信任锚来说并不正确，因为根是自发的--即它们具有相同的签发人和主体)。

约束处理
X.509 v3格式允许CA定义约束或限制每个证书如何被验证和作为关键扩展使用。路径中的每张证书都可以施加额外的约束，所有后续证书都必须遵守。

证书约束很少影响普通互联网用户，尽管它们在企业SSL解决方案中相当常见。功能性约束可以达到多种操作目的，但其最重要的用途是缓解已知的安全问题。

5. 浏览器检查名称约束
具有适当名称限制的私有(但公众信任的)中间CA可以为组织提供对证书管理和签发的精细控制。证书可以被限制在一个公司或组织的域名的特定域或域树（即包括子域）。名称限制通常用于从公开信任的CA购买的中间CA证书，以防止中间CA为第三方域（如google.com）签发完全有效的证书。

6. 浏览器检查策略约束
證書政策是由核證機關所發表的法律文件，正式詳述其簽發及管理證書的程序。憑證機構可以根據一項或多項政策簽發證書，而每張證書都有這些政策的連結，以便信賴者在決定信任該證書前，可以評估這些政策。

出于法律和操作上的原因，证书可以对证书的政策进行限制。如果发现证书中包含关键策略约束，浏览器必须在进行之前对其进行验证。(然而，关键策略约束在现实世界中很少遇到，所以本文其余部分将不予考虑)。

7. 浏览器检查基本约束（也就是路径长度）。
X.509 v3格式允许签发人定义证书所能支持的最大路径长度。这提供了对每个证书在认证路径中可以放置多远的控制。这实际上是很重要的--浏览器曾经无视认证路径长度，直到一位研究人员在2009年的一次演讲中演示了他如何利用自己网站的叶子证书为一个大型电子商务网站伪造有效证书。

8. 浏览器验证密钥用途
钥匙用途 "扩展部分说明了证书中钥匙的用途，例如加密、签名、证书签名等。这些用途的例子包括加密、签名、证书签名等。浏览器会拒绝违反其密钥用途限制的证书，例如遇到服务器证书的密钥只用于CRL签名。

9. 浏览器继续处理所有剩余的关键扩展文件
浏览器在处理完上述扩展证书后，会继续验证当前证书指定为关键的所有剩余扩展证书，然后再进入下一个。如果浏览器到达一个路径的叶子证书时没有错误，那么该路径就会被接受为有效。如果产生任何错误，则路径被标记为无效，并且不能建立安全连接。

通过www.DeepL.com/Translator（免费版）翻译
 #+END_SRC

*** 两个重要RFC标准
上面转载的文章，详细讲述了浏览器的验证过程。细心人会发现，文章多次提到RFC 5280。这个标准定义了X.509证书格式，是互联网加密体系中处于基石地位的标准之一。除了RFC 5280，还有一个比较重要的标准 RFC 5246，定义了SSL传输层协议。

**** [RFC 5280] PKI X.509 v3规范　
https://tools.ietf.org/html/rfc5280   

***** 路径验证算法
其中，section-6 给出了证书validation算法，并给出了路径验证算法（section-6）。
在此，摘录关键部分: 
#+BEGIN_SRC  text
 (a)  for all x in {1, ..., n-1}, the subject of certificate x is
           the issuer of certificate x+1;

 (b)  certificate 1 is issued by the trust anchor;

 (c)  certificate n is the certificate to be validated (i.e., the
      target certificate); and

 (d)  for all x in {1, ..., n}, the certificate was valid at the
           time in question
#+END_SRC 

根据算法，第一个证书由trust anchor签发，下一个证书由这个证书签发……直到最后的叶子节点证书。这样由信任锚长出一个链条，一环扣一环，链条上每个节点都是可信的。

***** 证书指纹(fingerprint)验证算法
x509如何计算fingerprint?
https://stackoverflow.com/questions/4803799/how-to-calculate-x-509-certificates-sha-1-fingerprint

生成过程: 1) 根据signature算法，计算出证书TBS部分的signature 2) 证书签发者issuer用自己的私钥加密signature，得到fingerprint
验证过程: 1) 根据signature算法，计算出证书TBS部分的signature 2) 使用证书签发者issuer的公钥解密fingerprint, 得到signature 3) 比对两个signature

**** [RFC 5246] TLS 1.2规范
https://tools.ietf.org/html/rfc5246   

其中，section-7.4.2　规定，server要向client发送 /certificate_list/ 。服务器不是返回单独的某个证书，而是一个证书列表; 因为单独一个证书，没法形成certifate chain，也就无法完成validation: 这和[RFC 5280] 所述流程吻合。 

#+BEGIN_SRC text  
certificate_list
      This is a sequence (chain) of certificates.  The sender's
      certificate MUST come first in the list.  Each following
      certificate MUST directly certify the one preceding it.  Because
      certificate validation requires that root keys be distributed
      independently, the self-signed certificate that specifies the root
      certificate authority MAY be omitted from the chain, under the
      assumption that the remote end must already possess it in order to
      validate it in any case.
#+END_SRC 

这里指定了证书的顺序，第一个是叶子证书。很好理解，因为重要数据在报文中的位置往往靠前。

*** 抓包看看　
借助wireshark，我们实际操作一番。  

打开wireshark, 开始抓包，再访问百度官网(https://www.baidu.com)。抓包细节如下：　

[[file:e:/blog/static/ox-hugo/ssl_certificate_wireshark.png][wireshark抓包分析]]


** 手工验证一张数字证书的有效性
:PROPERTIES:
:EXPORT_HUGO_CATEGORIES: Tech
:EXPORT_FILE_NAME: validate_a_digital_certificate_step_by_step
:EXPORT_DESCRIPTION: 尽可能细致地实践证书验证算法
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :keywords '( "ssl" "CA" )
:END:

上一篇 [[https://blog.yuantops.com/tech/how_do_web_broswer_validate_ssl_certificates/][博客]] 讨论浏览器验证数字证书的流程。这篇文章更深入一步，用笨方法一步步手工验证证书的合法性。本文参考: [[https://security.stackexchange.com/questions/127095/manually-walking-through-the-signature-validation-of-a-certificate][回答]] 与 [[https://segmentfault.com/a/1190000019008423][X.509、PKCS文件格式介绍]]。

*** ASN.1, DER与PEM
**** PEM 
Privacy Enhanced Email
**** DER

**** PEM 与 DER 相互转换

*** 如何得到一张证书
借助浏览器，我们可以方便导出证书。

打开chrome，访问本博客网址(https://blog.yuantops.com)，地址栏最左侧有个小锁图案 —— 这是网站受到HTTPS加密保护的标志。点击小锁　-> "certificate" -> "Details" -> "Export..."，可以选择证书的导出格式。

这里稍作暂停, 先了解一下常见证书格式.



